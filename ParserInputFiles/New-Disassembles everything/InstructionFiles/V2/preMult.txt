
./preMult.ino.elf:     file format elf32-avr


Disassembly of section .data:

00800100 <__data_start>:
  800100:	a2 a1       	ldd	r26, Z+34	; 0x22

00800102 <b>:
  800102:	b2 b1       	in	r27, 0x02	; 2

00800104 <_ZTV14HardwareSerial>:
  800104:	00 00       	nop
  800106:	00 00       	nop
  800108:	6f 01       	movw	r12, r30
  80010a:	cf 00       	.word	0x00cf	; ????
  80010c:	fc 00       	.word	0x00fc	; ????
  80010e:	bc 01       	movw	r22, r24
  800110:	2d 01       	movw	r4, r26
  800112:	0b 01       	movw	r0, r22
  800114:	1f 01       	movw	r2, r30
  800116:	0d 0a       	sbc	r0, r29
  800118:	00 69       	ori	r16, 0x90	; 144
  80011a:	6e 20       	and	r6, r14
  80011c:	73 65       	ori	r23, 0x53	; 83
  80011e:	74 75       	andi	r23, 0x54	; 84
  800120:	70 00       	.word	0x0070	; ????
  800122:	74 6f       	ori	r23, 0xF4	; 244
  800124:	70 20       	and	r7, r0
  800126:	6f 66       	ori	r22, 0x6F	; 111
  800128:	20 6c       	ori	r18, 0xC0	; 192
  80012a:	6f 6f       	ori	r22, 0xFF	; 255
  80012c:	70 00       	.word	0x0070	; ????
  80012e:	45 6e       	ori	r20, 0xE5	; 229
  800130:	64 20       	and	r6, r4
  800132:	6f 66       	ori	r22, 0x6F	; 111
  800134:	20 6c       	ori	r18, 0xC0	; 192
  800136:	6f 6f       	ori	r22, 0xFF	; 255
  800138:	70 00       	.word	0x0070	; ????

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
   4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  20:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  2c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  3c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  40:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__vector_16>
  44:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  48:	0c 94 69 02 	jmp	0x4d2	; 0x4d2 <__vector_18>
  4c:	0c 94 43 02 	jmp	0x486	; 0x486 <__vector_19>
  50:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  60:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  64:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	24 00       	.word	0x0024	; ????
  6e:	27 00       	.word	0x0027	; ????
  70:	2a 00       	.word	0x002a	; ????

00000072 <port_to_output_PGM>:
  72:	00 00       	nop
  74:	00 00       	nop
  76:	25 00       	.word	0x0025	; ????
  78:	28 00       	.word	0x0028	; ????
  7a:	2b 00       	.word	0x002b	; ????

0000007c <digital_pin_to_port_PGM>:
  7c:	04 04       	cpc	r0, r4
  7e:	04 04       	cpc	r0, r4
  80:	04 04       	cpc	r0, r4
  82:	04 04       	cpc	r0, r4
  84:	02 02       	muls	r16, r18
  86:	02 02       	muls	r16, r18
  88:	02 02       	muls	r16, r18
  8a:	03 03       	mulsu	r16, r19
  8c:	03 03       	mulsu	r16, r19
  8e:	03 03       	mulsu	r16, r19

00000090 <digital_pin_to_bit_mask_PGM>:
  90:	01 02       	muls	r16, r17
  92:	04 08       	sbc	r0, r4
  94:	10 20       	and	r1, r0
  96:	40 80       	ld	r4, Z
  98:	01 02       	muls	r16, r17
  9a:	04 08       	sbc	r0, r4
  9c:	10 20       	and	r1, r0
  9e:	01 02       	muls	r16, r17
  a0:	04 08       	sbc	r0, r4
  a2:	10 20       	and	r1, r0

000000a4 <digital_pin_to_timer_PGM>:
  a4:	00 00       	nop
  a6:	00 08       	sbc	r0, r0
  a8:	00 02       	muls	r16, r16
  aa:	01 00       	.word	0x0001	; ????
  ac:	00 03       	mulsu	r16, r16
  ae:	04 07       	cpc	r16, r20
	...

000000b8 <__ctors_start>:
  b8:	2f 04       	cpc	r2, r15

000000ba <__ctors_end>:
  ba:	11 24       	eor	r1, r1
  bc:	1f be       	out	0x3f, r1	; 63
  be:	cf ef       	ldi	r28, 0xFF	; 255
  c0:	d8 e0       	ldi	r29, 0x08	; 8
  c2:	de bf       	out	0x3e, r29	; 62
  c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
  c6:	11 e0       	ldi	r17, 0x01	; 1
  c8:	a0 e0       	ldi	r26, 0x00	; 0
  ca:	b1 e0       	ldi	r27, 0x01	; 1
  cc:	e8 ec       	ldi	r30, 0xC8	; 200
  ce:	f8 e0       	ldi	r31, 0x08	; 8
  d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
  d2:	05 90       	lpm	r0, Z+
  d4:	0d 92       	st	X+, r0
  d6:	aa 33       	cpi	r26, 0x3A	; 58
  d8:	b1 07       	cpc	r27, r17
  da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
  dc:	21 e0       	ldi	r18, 0x01	; 1
  de:	aa e3       	ldi	r26, 0x3A	; 58
  e0:	b1 e0       	ldi	r27, 0x01	; 1
  e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
  e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
  e6:	a0 3e       	cpi	r26, 0xE0	; 224
  e8:	b2 07       	cpc	r27, r18
  ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>

000000ec <__do_global_ctors>:
  ec:	10 e0       	ldi	r17, 0x00	; 0
  ee:	cd e5       	ldi	r28, 0x5D	; 93
  f0:	d0 e0       	ldi	r29, 0x00	; 0
  f2:	04 c0       	rjmp	.+8      	; 0xfc <__do_global_ctors+0x10>
  f4:	21 97       	sbiw	r28, 0x01	; 1
  f6:	fe 01       	movw	r30, r28
  f8:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <__tablejump2__>
  fc:	cc 35       	cpi	r28, 0x5C	; 92
  fe:	d1 07       	cpc	r29, r17
 100:	c9 f7       	brne	.-14     	; 0xf4 <__do_global_ctors+0x8>
 102:	0e 94 9b 02 	call	0x536	; 0x536 <main>
 106:	0c 94 62 04 	jmp	0x8c4	; 0x8c4 <_exit>

0000010a <__bad_interrupt>:
 10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <digitalWrite.constprop.4>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	e1 eb       	ldi	r30, 0xB1	; 177
 110:	f0 e0       	ldi	r31, 0x00	; 0
 112:	24 91       	lpm	r18, Z
	uint8_t bit = digitalPinToBitMask(pin);
 114:	ed e9       	ldi	r30, 0x9D	; 157
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
 11a:	e9 e8       	ldi	r30, 0x89	; 137
 11c:	f0 e0       	ldi	r31, 0x00	; 0
 11e:	e4 91       	lpm	r30, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	ee 23       	and	r30, r30
 122:	c9 f0       	breq	.+50     	; 0x156 <digitalWrite.constprop.4+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	22 23       	and	r18, r18
 126:	39 f0       	breq	.+14     	; 0x136 <digitalWrite.constprop.4+0x28>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	23 30       	cpi	r18, 0x03	; 3
 12a:	01 f1       	breq	.+64     	; 0x16c <digitalWrite.constprop.4+0x5e>
 12c:	a8 f4       	brcc	.+42     	; 0x158 <digitalWrite.constprop.4+0x4a>
 12e:	21 30       	cpi	r18, 0x01	; 1
 130:	19 f1       	breq	.+70     	; 0x178 <digitalWrite.constprop.4+0x6a>
 132:	22 30       	cpi	r18, 0x02	; 2
 134:	29 f1       	breq	.+74     	; 0x180 <digitalWrite.constprop.4+0x72>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	f0 e0       	ldi	r31, 0x00	; 0
 138:	ee 0f       	add	r30, r30
 13a:	ff 1f       	adc	r31, r31
 13c:	ee 58       	subi	r30, 0x8E	; 142
 13e:	ff 4f       	sbci	r31, 0xFF	; 255
 140:	a5 91       	lpm	r26, Z+
 142:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 144:	2f b7       	in	r18, 0x3f	; 63
	cli();
 146:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
 148:	ec 91       	ld	r30, X
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	81 11       	cpse	r24, r1
 14c:	26 c0       	rjmp	.+76     	; 0x19a <digitalWrite.constprop.4+0x8c>
		*out &= ~bit;
 14e:	90 95       	com	r25
 150:	9e 23       	and	r25, r30
	} else {
		*out |= bit;
 152:	9c 93       	st	X, r25
	}

	SREG = oldSREG;
 154:	2f bf       	out	0x3f, r18	; 63
}
 156:	08 95       	ret
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	27 30       	cpi	r18, 0x07	; 7
 15a:	a9 f0       	breq	.+42     	; 0x186 <digitalWrite.constprop.4+0x78>
 15c:	28 30       	cpi	r18, 0x08	; 8
 15e:	c9 f0       	breq	.+50     	; 0x192 <digitalWrite.constprop.4+0x84>
 160:	24 30       	cpi	r18, 0x04	; 4
 162:	49 f7       	brne	.-46     	; 0x136 <digitalWrite.constprop.4+0x28>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 168:	2f 7d       	andi	r18, 0xDF	; 223
 16a:	03 c0       	rjmp	.+6      	; 0x172 <digitalWrite.constprop.4+0x64>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 170:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 176:	df cf       	rjmp	.-66     	; 0x136 <digitalWrite.constprop.4+0x28>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	24 b5       	in	r18, 0x24	; 36
 17a:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17c:	24 bd       	out	0x24, r18	; 36
 17e:	db cf       	rjmp	.-74     	; 0x136 <digitalWrite.constprop.4+0x28>
 180:	24 b5       	in	r18, 0x24	; 36
 182:	2f 7d       	andi	r18, 0xDF	; 223
 184:	fb cf       	rjmp	.-10     	; 0x17c <digitalWrite.constprop.4+0x6e>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 18a:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 190:	d2 cf       	rjmp	.-92     	; 0x136 <digitalWrite.constprop.4+0x28>
 192:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 196:	2f 7d       	andi	r18, 0xDF	; 223
 198:	f9 cf       	rjmp	.-14     	; 0x18c <digitalWrite.constprop.4+0x7e>
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	9e 2b       	or	r25, r30
 19c:	da cf       	rjmp	.-76     	; 0x152 <digitalWrite.constprop.4+0x44>

0000019e <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	af 92       	push	r10
 1a0:	bf 92       	push	r11
 1a2:	cf 92       	push	r12
 1a4:	df 92       	push	r13
 1a6:	ef 92       	push	r14
 1a8:	ff 92       	push	r15
 1aa:	0f 93       	push	r16
 1ac:	1f 93       	push	r17
 1ae:	cf 93       	push	r28
 1b0:	df 93       	push	r29
 1b2:	6c 01       	movw	r12, r24
 1b4:	7b 01       	movw	r14, r22
 1b6:	8b 01       	movw	r16, r22
 1b8:	04 0f       	add	r16, r20
 1ba:	15 1f       	adc	r17, r21
 1bc:	eb 01       	movw	r28, r22
 1be:	5e 01       	movw	r10, r28
 1c0:	ae 18       	sub	r10, r14
 1c2:	bf 08       	sbc	r11, r15
  size_t n = 0;
  while (size--) {
 1c4:	c0 17       	cp	r28, r16
 1c6:	d1 07       	cpc	r29, r17
 1c8:	59 f0       	breq	.+22     	; 0x1e0 <_ZN5Print5writeEPKhj+0x42>
    if (write(*buffer++)) n++;
 1ca:	69 91       	ld	r22, Y+
 1cc:	d6 01       	movw	r26, r12
 1ce:	ed 91       	ld	r30, X+
 1d0:	fc 91       	ld	r31, X
 1d2:	01 90       	ld	r0, Z+
 1d4:	f0 81       	ld	r31, Z
 1d6:	e0 2d       	mov	r30, r0
 1d8:	c6 01       	movw	r24, r12
 1da:	09 95       	icall
 1dc:	89 2b       	or	r24, r25
 1de:	79 f7       	brne	.-34     	; 0x1be <_ZN5Print5writeEPKhj+0x20>
    else break;
  }
  return n;
}
 1e0:	c5 01       	movw	r24, r10
 1e2:	df 91       	pop	r29
 1e4:	cf 91       	pop	r28
 1e6:	1f 91       	pop	r17
 1e8:	0f 91       	pop	r16
 1ea:	ff 90       	pop	r15
 1ec:	ef 90       	pop	r14
 1ee:	df 90       	pop	r13
 1f0:	cf 90       	pop	r12
 1f2:	bf 90       	pop	r11
 1f4:	af 90       	pop	r10
 1f6:	08 95       	ret

000001f8 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	fc 01       	movw	r30, r24
 1fa:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
 1fc:	44 8d       	ldd	r20, Z+28	; 0x1c
 1fe:	25 2f       	mov	r18, r21
 200:	30 e0       	ldi	r19, 0x00	; 0
 202:	84 2f       	mov	r24, r20
 204:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	82 1b       	sub	r24, r18
 208:	93 0b       	sbc	r25, r19
 20a:	54 17       	cp	r21, r20
 20c:	10 f0       	brcs	.+4      	; 0x212 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
 20e:	cf 96       	adiw	r24, 0x3f	; 63
 210:	08 95       	ret
  return tail - head - 1;
 212:	01 97       	sbiw	r24, 0x01	; 1
}
 214:	08 95       	ret

00000216 <_ZN14HardwareSerial4readEv>:
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	91 8d       	ldd	r25, Z+25	; 0x19
 21a:	82 8d       	ldd	r24, Z+26	; 0x1a
 21c:	98 17       	cp	r25, r24
 21e:	61 f0       	breq	.+24     	; 0x238 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	a2 8d       	ldd	r26, Z+26	; 0x1a
 222:	ae 0f       	add	r26, r30
 224:	bf 2f       	mov	r27, r31
 226:	b1 1d       	adc	r27, r1
 228:	5d 96       	adiw	r26, 0x1d	; 29
 22a:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 22c:	92 8d       	ldd	r25, Z+26	; 0x1a
 22e:	9f 5f       	subi	r25, 0xFF	; 255
 230:	9f 73       	andi	r25, 0x3F	; 63
 232:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 238:	8f ef       	ldi	r24, 0xFF	; 255
 23a:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 23c:	08 95       	ret

0000023e <_ZN14HardwareSerial4peekEv>:
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 23e:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 240:	91 8d       	ldd	r25, Z+25	; 0x19
 242:	82 8d       	ldd	r24, Z+26	; 0x1a
 244:	98 17       	cp	r25, r24
 246:	31 f0       	breq	.+12     	; 0x254 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 248:	82 8d       	ldd	r24, Z+26	; 0x1a
 24a:	e8 0f       	add	r30, r24
 24c:	f1 1d       	adc	r31, r1
 24e:	85 8d       	ldd	r24, Z+29	; 0x1d
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 254:	8f ef       	ldi	r24, 0xFF	; 255
 256:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 258:	08 95       	ret

0000025a <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 25a:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 25c:	91 8d       	ldd	r25, Z+25	; 0x19
 25e:	22 8d       	ldd	r18, Z+26	; 0x1a
 260:	89 2f       	mov	r24, r25
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	80 5c       	subi	r24, 0xC0	; 192
 266:	9f 4f       	sbci	r25, 0xFF	; 255
 268:	82 1b       	sub	r24, r18
 26a:	91 09       	sbc	r25, r1
}
 26c:	8f 73       	andi	r24, 0x3F	; 63
 26e:	99 27       	eor	r25, r25
 270:	08 95       	ret

00000272 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 272:	83 e4       	ldi	r24, 0x43	; 67
 274:	91 e0       	ldi	r25, 0x01	; 1
 276:	0e 94 2d 01 	call	0x25a	; 0x25a <_ZN14HardwareSerial9availableEv>
 27a:	21 e0       	ldi	r18, 0x01	; 1
 27c:	89 2b       	or	r24, r25
 27e:	09 f4       	brne	.+2      	; 0x282 <_Z17Serial0_availablev+0x10>
 280:	20 e0       	ldi	r18, 0x00	; 0
}
 282:	82 2f       	mov	r24, r18
 284:	08 95       	ret

00000286 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 286:	80 e0       	ldi	r24, 0x00	; 0
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	89 2b       	or	r24, r25
 28c:	29 f0       	breq	.+10     	; 0x298 <_Z14serialEventRunv+0x12>
 28e:	0e 94 39 01 	call	0x272	; 0x272 <_Z17Serial0_availablev>
 292:	81 11       	cpse	r24, r1
 294:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 298:	08 95       	ret

0000029a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 29a:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 29c:	a4 8d       	ldd	r26, Z+28	; 0x1c
 29e:	a8 0f       	add	r26, r24
 2a0:	b9 2f       	mov	r27, r25
 2a2:	b1 1d       	adc	r27, r1
 2a4:	a3 5a       	subi	r26, 0xA3	; 163
 2a6:	bf 4f       	sbci	r27, 0xFF	; 255
 2a8:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2aa:	84 8d       	ldd	r24, Z+28	; 0x1c
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	01 96       	adiw	r24, 0x01	; 1
 2b0:	8f 73       	andi	r24, 0x3F	; 63
 2b2:	99 27       	eor	r25, r25
 2b4:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
 2b6:	a6 89       	ldd	r26, Z+22	; 0x16
 2b8:	b7 89       	ldd	r27, Z+23	; 0x17
 2ba:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 2bc:	a0 89       	ldd	r26, Z+16	; 0x10
 2be:	b1 89       	ldd	r27, Z+17	; 0x11
 2c0:	8c 91       	ld	r24, X
 2c2:	83 70       	andi	r24, 0x03	; 3
 2c4:	80 64       	ori	r24, 0x40	; 64
 2c6:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 2c8:	93 8d       	ldd	r25, Z+27	; 0x1b
 2ca:	84 8d       	ldd	r24, Z+28	; 0x1c
 2cc:	98 13       	cpse	r25, r24
 2ce:	06 c0       	rjmp	.+12     	; 0x2dc <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 2d0:	02 88       	ldd	r0, Z+18	; 0x12
 2d2:	f3 89       	ldd	r31, Z+19	; 0x13
 2d4:	e0 2d       	mov	r30, r0
 2d6:	80 81       	ld	r24, Z
 2d8:	8f 7d       	andi	r24, 0xDF	; 223
 2da:	80 83       	st	Z, r24
  }
}
 2dc:	08 95       	ret

000002de <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 2de:	ef 92       	push	r14
 2e0:	ff 92       	push	r15
 2e2:	0f 93       	push	r16
 2e4:	1f 93       	push	r17
 2e6:	cf 93       	push	r28
 2e8:	df 93       	push	r29
 2ea:	ec 01       	movw	r28, r24
  _written = true;
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 2f0:	9b 8d       	ldd	r25, Y+27	; 0x1b
 2f2:	8c 8d       	ldd	r24, Y+28	; 0x1c
 2f4:	98 13       	cpse	r25, r24
 2f6:	1a c0       	rjmp	.+52     	; 0x32c <_ZN14HardwareSerial5writeEh+0x4e>
 2f8:	e8 89       	ldd	r30, Y+16	; 0x10
 2fa:	f9 89       	ldd	r31, Y+17	; 0x11
 2fc:	80 81       	ld	r24, Z
 2fe:	85 ff       	sbrs	r24, 5
 300:	15 c0       	rjmp	.+42     	; 0x32c <_ZN14HardwareSerial5writeEh+0x4e>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 302:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 304:	f8 94       	cli
      *_udr = c;
 306:	ee 89       	ldd	r30, Y+22	; 0x16
 308:	ff 89       	ldd	r31, Y+23	; 0x17
 30a:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 30c:	e8 89       	ldd	r30, Y+16	; 0x10
 30e:	f9 89       	ldd	r31, Y+17	; 0x11
 310:	80 81       	ld	r24, Z
 312:	83 70       	andi	r24, 0x03	; 3
 314:	80 64       	ori	r24, 0x40	; 64
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 316:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 318:	9f bf       	out	0x3f, r25	; 63
  }
  
  return 1;
}
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	90 e0       	ldi	r25, 0x00	; 0
 31e:	df 91       	pop	r29
 320:	cf 91       	pop	r28
 322:	1f 91       	pop	r17
 324:	0f 91       	pop	r16
 326:	ff 90       	pop	r15
 328:	ef 90       	pop	r14
 32a:	08 95       	ret
 32c:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 32e:	0b 8d       	ldd	r16, Y+27	; 0x1b
 330:	10 e0       	ldi	r17, 0x00	; 0
 332:	0f 5f       	subi	r16, 0xFF	; 255
 334:	1f 4f       	sbci	r17, 0xFF	; 255
 336:	0f 73       	andi	r16, 0x3F	; 63
 338:	11 27       	eor	r17, r17
 33a:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 33c:	8c 8d       	ldd	r24, Y+28	; 0x1c
 33e:	8e 11       	cpse	r24, r14
 340:	0c c0       	rjmp	.+24     	; 0x35a <_ZN14HardwareSerial5writeEh+0x7c>
    if (bit_is_clear(SREG, SREG_I)) {
 342:	0f b6       	in	r0, 0x3f	; 63
 344:	07 fc       	sbrc	r0, 7
 346:	fa cf       	rjmp	.-12     	; 0x33c <_ZN14HardwareSerial5writeEh+0x5e>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 348:	e8 89       	ldd	r30, Y+16	; 0x10
 34a:	f9 89       	ldd	r31, Y+17	; 0x11
 34c:	80 81       	ld	r24, Z
 34e:	85 ff       	sbrs	r24, 5
 350:	f5 cf       	rjmp	.-22     	; 0x33c <_ZN14HardwareSerial5writeEh+0x5e>
	_tx_udr_empty_irq();
 352:	ce 01       	movw	r24, r28
 354:	0e 94 4d 01 	call	0x29a	; 0x29a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 358:	f1 cf       	rjmp	.-30     	; 0x33c <_ZN14HardwareSerial5writeEh+0x5e>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 35a:	eb 8d       	ldd	r30, Y+27	; 0x1b
 35c:	ec 0f       	add	r30, r28
 35e:	fd 2f       	mov	r31, r29
 360:	f1 1d       	adc	r31, r1
 362:	e3 5a       	subi	r30, 0xA3	; 163
 364:	ff 4f       	sbci	r31, 0xFF	; 255
 366:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 368:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 36a:	f8 94       	cli
    _tx_buffer_head = i;
 36c:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
 36e:	ea 89       	ldd	r30, Y+18	; 0x12
 370:	fb 89       	ldd	r31, Y+19	; 0x13
 372:	80 81       	ld	r24, Z
 374:	80 62       	ori	r24, 0x20	; 32
 376:	cf cf       	rjmp	.-98     	; 0x316 <_ZN14HardwareSerial5writeEh+0x38>

00000378 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 378:	cf 93       	push	r28
 37a:	df 93       	push	r29
 37c:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 37e:	88 8d       	ldd	r24, Y+24	; 0x18
 380:	88 23       	and	r24, r24
 382:	b9 f0       	breq	.+46     	; 0x3b2 <_ZN14HardwareSerial5flushEv+0x3a>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 384:	aa 89       	ldd	r26, Y+18	; 0x12
 386:	bb 89       	ldd	r27, Y+19	; 0x13
 388:	e8 89       	ldd	r30, Y+16	; 0x10
 38a:	f9 89       	ldd	r31, Y+17	; 0x11
 38c:	8c 91       	ld	r24, X
 38e:	85 fd       	sbrc	r24, 5
 390:	03 c0       	rjmp	.+6      	; 0x398 <_ZN14HardwareSerial5flushEv+0x20>
 392:	80 81       	ld	r24, Z
 394:	86 fd       	sbrc	r24, 6
 396:	0d c0       	rjmp	.+26     	; 0x3b2 <_ZN14HardwareSerial5flushEv+0x3a>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 398:	0f b6       	in	r0, 0x3f	; 63
 39a:	07 fc       	sbrc	r0, 7
 39c:	f7 cf       	rjmp	.-18     	; 0x38c <_ZN14HardwareSerial5flushEv+0x14>
 39e:	8c 91       	ld	r24, X
 3a0:	85 ff       	sbrs	r24, 5
 3a2:	f2 cf       	rjmp	.-28     	; 0x388 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 3a4:	80 81       	ld	r24, Z
 3a6:	85 ff       	sbrs	r24, 5
 3a8:	ed cf       	rjmp	.-38     	; 0x384 <_ZN14HardwareSerial5flushEv+0xc>
	  _tx_udr_empty_irq();
 3aa:	ce 01       	movw	r24, r28
 3ac:	0e 94 4d 01 	call	0x29a	; 0x29a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 3b0:	e9 cf       	rjmp	.-46     	; 0x384 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3b2:	df 91       	pop	r29
 3b4:	cf 91       	pop	r28
 3b6:	08 95       	ret

000003b8 <_ZN5Print7printlnEPKc.constprop.6>:
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 3b8:	cf 93       	push	r28
 3ba:	df 93       	push	r29
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 3bc:	fc 01       	movw	r30, r24
 3be:	01 90       	ld	r0, Z+
 3c0:	00 20       	and	r0, r0
 3c2:	e9 f7       	brne	.-6      	; 0x3be <_ZN5Print7printlnEPKc.constprop.6+0x6>
 3c4:	31 97       	sbiw	r30, 0x01	; 1
 3c6:	af 01       	movw	r20, r30
 3c8:	48 1b       	sub	r20, r24
 3ca:	59 0b       	sbc	r21, r25
 3cc:	bc 01       	movw	r22, r24
 3ce:	83 e4       	ldi	r24, 0x43	; 67
 3d0:	91 e0       	ldi	r25, 0x01	; 1
 3d2:	0e 94 cf 00 	call	0x19e	; 0x19e <_ZN5Print5writeEPKhj>
 3d6:	ec 01       	movw	r28, r24
 3d8:	42 e0       	ldi	r20, 0x02	; 2
 3da:	50 e0       	ldi	r21, 0x00	; 0
 3dc:	66 e1       	ldi	r22, 0x16	; 22
 3de:	71 e0       	ldi	r23, 0x01	; 1
 3e0:	83 e4       	ldi	r24, 0x43	; 67
 3e2:	91 e0       	ldi	r25, 0x01	; 1
 3e4:	0e 94 cf 00 	call	0x19e	; 0x19e <_ZN5Print5writeEPKhj>
{
  size_t n = print(c);
  n += println();
  return n;
}
 3e8:	8c 0f       	add	r24, r28
 3ea:	9d 1f       	adc	r25, r29
 3ec:	df 91       	pop	r29
 3ee:	cf 91       	pop	r28
 3f0:	08 95       	ret

000003f2 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3f2:	1f 92       	push	r1
 3f4:	0f 92       	push	r0
 3f6:	0f b6       	in	r0, 0x3f	; 63
 3f8:	0f 92       	push	r0
 3fa:	11 24       	eor	r1, r1
 3fc:	2f 93       	push	r18
 3fe:	3f 93       	push	r19
 400:	8f 93       	push	r24
 402:	9f 93       	push	r25
 404:	af 93       	push	r26
 406:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 408:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <timer0_millis>
 40c:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <timer0_millis+0x1>
 410:	a0 91 41 01 	lds	r26, 0x0141	; 0x800141 <timer0_millis+0x2>
 414:	b0 91 42 01 	lds	r27, 0x0142	; 0x800142 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 418:	30 91 3e 01 	lds	r19, 0x013E	; 0x80013e <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
 41c:	23 e0       	ldi	r18, 0x03	; 3
 41e:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 420:	2d 37       	cpi	r18, 0x7D	; 125
 422:	58 f5       	brcc	.+86     	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 424:	01 96       	adiw	r24, 0x01	; 1
 426:	a1 1d       	adc	r26, r1
 428:	b1 1d       	adc	r27, r1
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 42a:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <timer0_fract>
	timer0_millis = m;
 42e:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <timer0_millis>
 432:	90 93 40 01 	sts	0x0140, r25	; 0x800140 <timer0_millis+0x1>
 436:	a0 93 41 01 	sts	0x0141, r26	; 0x800141 <timer0_millis+0x2>
 43a:	b0 93 42 01 	sts	0x0142, r27	; 0x800142 <timer0_millis+0x3>
	timer0_overflow_count++;
 43e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <__data_end>
 442:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <__data_end+0x1>
 446:	a0 91 3c 01 	lds	r26, 0x013C	; 0x80013c <__data_end+0x2>
 44a:	b0 91 3d 01 	lds	r27, 0x013D	; 0x80013d <__data_end+0x3>
 44e:	01 96       	adiw	r24, 0x01	; 1
 450:	a1 1d       	adc	r26, r1
 452:	b1 1d       	adc	r27, r1
 454:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <__data_end>
 458:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <__data_end+0x1>
 45c:	a0 93 3c 01 	sts	0x013C, r26	; 0x80013c <__data_end+0x2>
 460:	b0 93 3d 01 	sts	0x013D, r27	; 0x80013d <__data_end+0x3>
}
 464:	bf 91       	pop	r27
 466:	af 91       	pop	r26
 468:	9f 91       	pop	r25
 46a:	8f 91       	pop	r24
 46c:	3f 91       	pop	r19
 46e:	2f 91       	pop	r18
 470:	0f 90       	pop	r0
 472:	0f be       	out	0x3f, r0	; 63
 474:	0f 90       	pop	r0
 476:	1f 90       	pop	r1
 478:	18 95       	reti
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 47a:	26 e8       	ldi	r18, 0x86	; 134
 47c:	23 0f       	add	r18, r19
		m += 1;
 47e:	02 96       	adiw	r24, 0x02	; 2
 480:	a1 1d       	adc	r26, r1
 482:	b1 1d       	adc	r27, r1
 484:	d2 cf       	rjmp	.-92     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>

00000486 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 486:	1f 92       	push	r1
 488:	0f 92       	push	r0
 48a:	0f b6       	in	r0, 0x3f	; 63
 48c:	0f 92       	push	r0
 48e:	11 24       	eor	r1, r1
 490:	2f 93       	push	r18
 492:	3f 93       	push	r19
 494:	4f 93       	push	r20
 496:	5f 93       	push	r21
 498:	6f 93       	push	r22
 49a:	7f 93       	push	r23
 49c:	8f 93       	push	r24
 49e:	9f 93       	push	r25
 4a0:	af 93       	push	r26
 4a2:	bf 93       	push	r27
 4a4:	ef 93       	push	r30
 4a6:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 4a8:	83 e4       	ldi	r24, 0x43	; 67
 4aa:	91 e0       	ldi	r25, 0x01	; 1
 4ac:	0e 94 4d 01 	call	0x29a	; 0x29a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 4b0:	ff 91       	pop	r31
 4b2:	ef 91       	pop	r30
 4b4:	bf 91       	pop	r27
 4b6:	af 91       	pop	r26
 4b8:	9f 91       	pop	r25
 4ba:	8f 91       	pop	r24
 4bc:	7f 91       	pop	r23
 4be:	6f 91       	pop	r22
 4c0:	5f 91       	pop	r21
 4c2:	4f 91       	pop	r20
 4c4:	3f 91       	pop	r19
 4c6:	2f 91       	pop	r18
 4c8:	0f 90       	pop	r0
 4ca:	0f be       	out	0x3f, r0	; 63
 4cc:	0f 90       	pop	r0
 4ce:	1f 90       	pop	r1
 4d0:	18 95       	reti

000004d2 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4d2:	1f 92       	push	r1
 4d4:	0f 92       	push	r0
 4d6:	0f b6       	in	r0, 0x3f	; 63
 4d8:	0f 92       	push	r0
 4da:	11 24       	eor	r1, r1
 4dc:	2f 93       	push	r18
 4de:	8f 93       	push	r24
 4e0:	9f 93       	push	r25
 4e2:	ef 93       	push	r30
 4e4:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 4e6:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <Serial+0x10>
 4ea:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <Serial+0x11>
 4ee:	80 81       	ld	r24, Z
 4f0:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <Serial+0x16>
 4f4:	f0 91 5a 01 	lds	r31, 0x015A	; 0x80015a <Serial+0x17>
 4f8:	82 fd       	sbrc	r24, 2
 4fa:	1b c0       	rjmp	.+54     	; 0x532 <__vector_18+0x60>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 4fc:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 4fe:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <Serial+0x19>
 502:	8f 5f       	subi	r24, 0xFF	; 255
 504:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 506:	20 91 5d 01 	lds	r18, 0x015D	; 0x80015d <Serial+0x1a>
 50a:	82 17       	cp	r24, r18
 50c:	41 f0       	breq	.+16     	; 0x51e <__vector_18+0x4c>
      _rx_buffer[_rx_buffer_head] = c;
 50e:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <Serial+0x19>
 512:	f0 e0       	ldi	r31, 0x00	; 0
 514:	ed 5b       	subi	r30, 0xBD	; 189
 516:	fe 4f       	sbci	r31, 0xFE	; 254
 518:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
 51a:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <Serial+0x19>
    Serial._rx_complete_irq();
  }
 51e:	ff 91       	pop	r31
 520:	ef 91       	pop	r30
 522:	9f 91       	pop	r25
 524:	8f 91       	pop	r24
 526:	2f 91       	pop	r18
 528:	0f 90       	pop	r0
 52a:	0f be       	out	0x3f, r0	; 63
 52c:	0f 90       	pop	r0
 52e:	1f 90       	pop	r1
 530:	18 95       	reti
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 532:	80 81       	ld	r24, Z
 534:	f4 cf       	rjmp	.-24     	; 0x51e <__vector_18+0x4c>

00000536 <main>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 536:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 538:	84 b5       	in	r24, 0x24	; 36
 53a:	82 60       	ori	r24, 0x02	; 2
 53c:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 53e:	84 b5       	in	r24, 0x24	; 36
 540:	81 60       	ori	r24, 0x01	; 1
 542:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 544:	85 b5       	in	r24, 0x25	; 37
 546:	82 60       	ori	r24, 0x02	; 2
 548:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 54a:	85 b5       	in	r24, 0x25	; 37
 54c:	81 60       	ori	r24, 0x01	; 1
 54e:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 550:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 554:	81 60       	ori	r24, 0x01	; 1
 556:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 55a:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 55e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 562:	82 60       	ori	r24, 0x02	; 2
 564:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 568:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 56c:	81 60       	ori	r24, 0x01	; 1
 56e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 572:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 576:	81 60       	ori	r24, 0x01	; 1
 578:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 57c:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 580:	84 60       	ori	r24, 0x04	; 4
 582:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 586:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 58a:	81 60       	ori	r24, 0x01	; 1
 58c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 590:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 594:	84 60       	ori	r24, 0x04	; 4
 596:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS1);
 59a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 59e:	82 60       	ori	r24, 0x02	; 2
 5a0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS0);
 5a4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 5a8:	81 60       	ori	r24, 0x01	; 1
 5aa:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 5ae:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 5b2:	80 68       	ori	r24, 0x80	; 128
 5b4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 5b8:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 5bc:	ed e9       	ldi	r30, 0x9D	; 157
 5be:	f0 e0       	ldi	r31, 0x00	; 0
 5c0:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 5c2:	e9 e8       	ldi	r30, 0x89	; 137
 5c4:	f0 e0       	ldi	r31, 0x00	; 0
 5c6:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 5c8:	88 23       	and	r24, r24
 5ca:	99 f0       	breq	.+38     	; 0x5f2 <main+0xbc>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	88 0f       	add	r24, r24
 5d0:	99 1f       	adc	r25, r25
 5d2:	fc 01       	movw	r30, r24
 5d4:	e8 59       	subi	r30, 0x98	; 152
 5d6:	ff 4f       	sbci	r31, 0xFF	; 255
 5d8:	a5 91       	lpm	r26, Z+
 5da:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
 5dc:	fc 01       	movw	r30, r24
 5de:	ee 58       	subi	r30, 0x8E	; 142
 5e0:	ff 4f       	sbci	r31, 0xFF	; 255
 5e2:	85 91       	lpm	r24, Z+
 5e4:	94 91       	lpm	r25, Z
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 5e6:	8f b7       	in	r24, 0x3f	; 63
                cli();
 5e8:	f8 94       	cli
		*reg |= bit;
 5ea:	ec 91       	ld	r30, X
 5ec:	e2 2b       	or	r30, r18
 5ee:	ec 93       	st	X, r30
		SREG = oldSREG;
 5f0:	8f bf       	out	0x3f, r24	; 63

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 5f2:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <Serial+0x10>
 5f6:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <Serial+0x11>
 5fa:	82 e0       	ldi	r24, 0x02	; 2
 5fc:	80 83       	st	Z, r24
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5fe:	e0 91 4f 01 	lds	r30, 0x014F	; 0x80014f <Serial+0xc>
 602:	f0 91 50 01 	lds	r31, 0x0150	; 0x800150 <Serial+0xd>
 606:	10 82       	st	Z, r1
  *_ubrrl = baud_setting;
 608:	e0 91 51 01 	lds	r30, 0x0151	; 0x800151 <Serial+0xe>
 60c:	f0 91 52 01 	lds	r31, 0x0152	; 0x800152 <Serial+0xf>
 610:	8f ec       	ldi	r24, 0xCF	; 207
 612:	80 83       	st	Z, r24

  _written = false;
 614:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <Serial+0x18>

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 618:	e0 91 57 01 	lds	r30, 0x0157	; 0x800157 <Serial+0x14>
 61c:	f0 91 58 01 	lds	r31, 0x0158	; 0x800158 <Serial+0x15>
 620:	86 e0       	ldi	r24, 0x06	; 6
 622:	80 83       	st	Z, r24
  
  sbi(*_ucsrb, RXEN0);
 624:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <Serial+0x12>
 628:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <Serial+0x13>
 62c:	80 81       	ld	r24, Z
 62e:	80 61       	ori	r24, 0x10	; 16
 630:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
 632:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <Serial+0x12>
 636:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <Serial+0x13>
 63a:	80 81       	ld	r24, Z
 63c:	88 60       	ori	r24, 0x08	; 8
 63e:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
 640:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <Serial+0x12>
 644:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <Serial+0x13>
 648:	80 81       	ld	r24, Z
 64a:	80 68       	ori	r24, 0x80	; 128
 64c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
 64e:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <Serial+0x12>
 652:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <Serial+0x13>
 656:	80 81       	ld	r24, Z
 658:	8f 7d       	andi	r24, 0xDF	; 223
 65a:	80 83       	st	Z, r24
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
 65c:	89 e1       	ldi	r24, 0x19	; 25
 65e:	91 e0       	ldi	r25, 0x01	; 1
 660:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN5Print7printlnEPKc.constprop.6>

00000664 <__Noops1>:
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
 664:	00 00       	nop
 666:	00 00       	nop
 668:	00 00       	nop
 66a:	0c 94 a5 03 	jmp	0x74a	; 0x74a <__main2>
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
 66e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 672:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

00000676 <__Add>:
 676:	88 0f       	add	r24, r24
 678:	88 0f       	add	r24, r24
 67a:	88 0f       	add	r24, r24
 67c:	0c 94 32 03 	jmp	0x664	; 0x664 <__Noops1>
 680:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 684:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

00000688 <__Noops2>:
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
 688:	00 00       	nop
 68a:	00 00       	nop
 68c:	00 00       	nop
 68e:	0c 94 c7 03 	jmp	0x78e	; 0x78e <__main3>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
 692:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 696:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

0000069a <__Mult>:
 69a:	88 02       	muls	r24, r24
 69c:	88 02       	muls	r24, r24
 69e:	88 02       	muls	r24, r24
 6a0:	0c 94 44 03 	jmp	0x688	; 0x688 <__Noops2>
 6a4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 6a8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

000006ac <__Noops3>:
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
 6ac:	00 00       	nop
 6ae:	00 00       	nop
 6b0:	00 00       	nop
 6b2:	0c 94 e9 03 	jmp	0x7d2	; 0x7d2 <__main4>
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
 6b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 6ba:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

000006be <__Mov>:
 6be:	88 2f       	mov	r24, r24
 6c0:	88 2f       	mov	r24, r24
 6c2:	88 2f       	mov	r24, r24
 6c4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 6c8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

000006cc <__Noops4>:
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
 6cc:	00 00       	nop
 6ce:	00 00       	nop
 6d0:	00 00       	nop
 6d2:	0c 94 07 04 	jmp	0x80e	; 0x80e <__main5>

000006d6 <__LDST>:
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
 6d6:	8a e2       	ldi	r24, 0x2A	; 42
 6d8:	8a e2       	ldi	r24, 0x2A	; 42
 6da:	8a e2       	ldi	r24, 0x2A	; 42
 6dc:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 6e0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 6e4:	c0 e0       	ldi	r28, 0x00	; 0
 6e6:	d0 e0       	ldi	r29, 0x00	; 0
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
 6e8:	82 e2       	ldi	r24, 0x22	; 34
 6ea:	91 e0       	ldi	r25, 0x01	; 1
 6ec:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN5Print7printlnEPKc.constprop.6>
  randomSeed(0);
  noInterrupts();
 6f0:	f8 94       	cli
  
  digitalWrite(LED_BUILTIN, LOW);   
 6f2:	80 e0       	ldi	r24, 0x00	; 0
 6f4:	0e 94 87 00 	call	0x10e	; 0x10e <digitalWrite.constprop.4>
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 6f8:	81 e0       	ldi	r24, 0x01	; 1
 6fa:	0e 94 87 00 	call	0x10e	; 0x10e <digitalWrite.constprop.4>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
 6fe:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 702:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

00000706 <__main1>:
	...
 72e:	00 00       	nop
 730:	88 02       	muls	r24, r24
 732:	88 02       	muls	r24, r24
 734:	88 02       	muls	r24, r24
 736:	0e 94 3b 03 	call	0x676	; 0x676 <__Add>
 73a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 73e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
 742:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 746:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

0000074a <__main2>:
	...
 772:	00 00       	nop
 774:	88 02       	muls	r24, r24
 776:	88 02       	muls	r24, r24
 778:	88 02       	muls	r24, r24
 77a:	0e 94 4d 03 	call	0x69a	; 0x69a <__Mult>
 77e:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 782:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
 786:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 78a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

0000078e <__main3>:
	...
 7b6:	00 00       	nop
 7b8:	88 02       	muls	r24, r24
 7ba:	88 02       	muls	r24, r24
 7bc:	88 02       	muls	r24, r24
 7be:	0e 94 5f 03 	call	0x6be	; 0x6be <__Mov>
 7c2:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 7c6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
 7ca:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <b>
 7ce:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <b+0x1>

000007d2 <__main4>:
	...
 7fa:	00 00       	nop
 7fc:	88 02       	muls	r24, r24
 7fe:	88 02       	muls	r24, r24
 800:	88 02       	muls	r24, r24
 802:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <__LDST>
 806:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 80a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

0000080e <__main5>:
	...
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
  Serial.println("End of loop");
 83e:	8e e2       	ldi	r24, 0x2E	; 46
 840:	91 e0       	ldi	r25, 0x01	; 1
 842:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN5Print7printlnEPKc.constprop.6>
  interrupts();
 846:	78 94       	sei
 848:	20 97       	sbiw	r28, 0x00	; 0
 84a:	09 f4       	brne	.+2      	; 0x84e <__main5+0x40>
 84c:	4d cf       	rjmp	.-358    	; 0x6e8 <__LDST+0x12>
 84e:	0e 94 39 01 	call	0x272	; 0x272 <_Z17Serial0_availablev>
 852:	88 23       	and	r24, r24
 854:	09 f4       	brne	.+2      	; 0x858 <__main5+0x4a>
 856:	48 cf       	rjmp	.-368    	; 0x6e8 <__LDST+0x12>
 858:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 85c:	45 cf       	rjmp	.-374    	; 0x6e8 <__LDST+0x12>

0000085e <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 85e:	e3 e4       	ldi	r30, 0x43	; 67
 860:	f1 e0       	ldi	r31, 0x01	; 1
 862:	13 82       	std	Z+3, r1	; 0x03
 864:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 866:	88 ee       	ldi	r24, 0xE8	; 232
 868:	93 e0       	ldi	r25, 0x03	; 3
 86a:	a0 e0       	ldi	r26, 0x00	; 0
 86c:	b0 e0       	ldi	r27, 0x00	; 0
 86e:	84 83       	std	Z+4, r24	; 0x04
 870:	95 83       	std	Z+5, r25	; 0x05
 872:	a6 83       	std	Z+6, r26	; 0x06
 874:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 876:	88 e0       	ldi	r24, 0x08	; 8
 878:	91 e0       	ldi	r25, 0x01	; 1
 87a:	91 83       	std	Z+1, r25	; 0x01
 87c:	80 83       	st	Z, r24
 87e:	85 ec       	ldi	r24, 0xC5	; 197
 880:	90 e0       	ldi	r25, 0x00	; 0
 882:	95 87       	std	Z+13, r25	; 0x0d
 884:	84 87       	std	Z+12, r24	; 0x0c
 886:	84 ec       	ldi	r24, 0xC4	; 196
 888:	90 e0       	ldi	r25, 0x00	; 0
 88a:	97 87       	std	Z+15, r25	; 0x0f
 88c:	86 87       	std	Z+14, r24	; 0x0e
 88e:	80 ec       	ldi	r24, 0xC0	; 192
 890:	90 e0       	ldi	r25, 0x00	; 0
 892:	91 8b       	std	Z+17, r25	; 0x11
 894:	80 8b       	std	Z+16, r24	; 0x10
 896:	81 ec       	ldi	r24, 0xC1	; 193
 898:	90 e0       	ldi	r25, 0x00	; 0
 89a:	93 8b       	std	Z+19, r25	; 0x13
 89c:	82 8b       	std	Z+18, r24	; 0x12
 89e:	82 ec       	ldi	r24, 0xC2	; 194
 8a0:	90 e0       	ldi	r25, 0x00	; 0
 8a2:	95 8b       	std	Z+21, r25	; 0x15
 8a4:	84 8b       	std	Z+20, r24	; 0x14
 8a6:	86 ec       	ldi	r24, 0xC6	; 198
 8a8:	90 e0       	ldi	r25, 0x00	; 0
 8aa:	97 8b       	std	Z+23, r25	; 0x17
 8ac:	86 8b       	std	Z+22, r24	; 0x16
 8ae:	11 8e       	std	Z+25, r1	; 0x19
 8b0:	12 8e       	std	Z+26, r1	; 0x1a
 8b2:	13 8e       	std	Z+27, r1	; 0x1b
 8b4:	14 8e       	std	Z+28, r1	; 0x1c

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
 8b6:	08 95       	ret

000008b8 <__tablejump2__>:
 8b8:	ee 0f       	add	r30, r30
 8ba:	ff 1f       	adc	r31, r31
 8bc:	05 90       	lpm	r0, Z+
 8be:	f4 91       	lpm	r31, Z
 8c0:	e0 2d       	mov	r30, r0
 8c2:	09 94       	ijmp

000008c4 <_exit>:
 8c4:	f8 94       	cli

000008c6 <__stop_program>:
 8c6:	ff cf       	rjmp	.-2      	; 0x8c6 <__stop_program>

Disassembly of section .bss:

0080013a <__bss_start>:
  80013a:	00 00       	nop
	...

0080013e <timer0_fract>:
	...

0080013f <timer0_millis>:
  80013f:	00 00       	nop
	...

00800143 <Serial>:
	...

Disassembly of section .comment:

00000000 <_end-0x8001e0>:
   0:	47 43       	sbci	r20, 0x37	; 55
   2:	43 3a       	cpi	r20, 0xA3	; 163
   4:	20 28       	or	r2, r0
   6:	47 4e       	sbci	r20, 0xE7	; 231
   8:	55 29       	or	r21, r5
   a:	20 37       	cpi	r18, 0x70	; 112
   c:	2e 33       	cpi	r18, 0x3E	; 62
   e:	2e 30       	cpi	r18, 0x0E	; 14
	...

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 <.note.gnu.avr.deviceinfo>:
   0:	04 00       	.word	0x0004	; ????
   2:	00 00       	nop
   4:	2d 00       	.word	0x002d	; ????
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	00 00       	nop
   c:	41 56       	subi	r20, 0x61	; 97
   e:	52 00       	.word	0x0052	; ????
  10:	00 00       	nop
  12:	00 00       	nop
  14:	00 80       	ld	r0, Z
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	00 00       	nop
  1c:	00 08       	sbc	r0, r0
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 04       	cpc	r0, r0
  26:	00 00       	nop
  28:	08 00       	.word	0x0008	; ????
  2a:	00 00       	nop
  2c:	01 00       	.word	0x0001	; ????
  2e:	00 00       	nop
  30:	00 61       	ori	r16, 0x10	; 16
  32:	74 6d       	ori	r23, 0xD4	; 212
  34:	65 67       	ori	r22, 0x75	; 117
  36:	61 33       	cpi	r22, 0x31	; 49
  38:	32 38       	cpi	r19, 0x82	; 130
  3a:	70 00       	.word	0x0070	; ????
  3c:	00 00       	nop
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	2c 00       	.word	0x002c	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	f4 05       	cpc	r31, r4
   8:	00 00       	nop
   a:	04 00       	.word	0x0004	; ????
   c:	00 00       	nop
   e:	00 00       	nop
  10:	0e 01       	movw	r0, r28
  12:	00 00       	nop
  14:	28 04       	cpc	r2, r8
  16:	00 00       	nop
  18:	36 05       	cpc	r19, r6
  1a:	00 00       	nop
  1c:	28 03       	fmul	r18, r16
  1e:	00 00       	nop
  20:	5e 08       	sbc	r5, r14
  22:	00 00       	nop
  24:	5a 00       	.word	0x005a	; ????
	...
  2e:	00 00       	nop
  30:	1c 00       	.word	0x001c	; ????
  32:	00 00       	nop
  34:	02 00       	.word	0x0002	; ????
  36:	c3 19       	sub	r28, r3
  38:	00 00       	nop
  3a:	04 00       	.word	0x0004	; ????
  3c:	00 00       	nop
  3e:	00 00       	nop
  40:	c4 08       	sbc	r12, r4
  42:	00 00       	nop
  44:	04 00       	.word	0x0004	; ????
	...
  4e:	00 00       	nop
  50:	1c 00       	.word	0x001c	; ????
  52:	00 00       	nop
  54:	02 00       	.word	0x0002	; ????
  56:	7e 1a       	sub	r7, r30
  58:	00 00       	nop
  5a:	04 00       	.word	0x0004	; ????
  5c:	00 00       	nop
  5e:	00 00       	nop
  60:	c6 00       	.word	0x00c6	; ????
  62:	00 00       	nop
  64:	16 00       	.word	0x0016	; ????
	...
  6e:	00 00       	nop
  70:	1c 00       	.word	0x001c	; ????
  72:	00 00       	nop
  74:	02 00       	.word	0x0002	; ????
  76:	39 1b       	sub	r19, r25
  78:	00 00       	nop
  7a:	04 00       	.word	0x0004	; ????
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	dc 00       	.word	0x00dc	; ????
  82:	00 00       	nop
  84:	10 00       	.word	0x0010	; ????
	...
  8e:	00 00       	nop
  90:	1c 00       	.word	0x001c	; ????
  92:	00 00       	nop
  94:	02 00       	.word	0x0002	; ????
  96:	f4 1b       	sub	r31, r20
  98:	00 00       	nop
  9a:	04 00       	.word	0x0004	; ????
  9c:	00 00       	nop
  9e:	00 00       	nop
  a0:	ec 00       	.word	0x00ec	; ????
  a2:	00 00       	nop
  a4:	16 00       	.word	0x0016	; ????
	...
  ae:	00 00       	nop
  b0:	1c 00       	.word	0x001c	; ????
  b2:	00 00       	nop
  b4:	02 00       	.word	0x0002	; ????
  b6:	af 1c       	adc	r10, r15
  b8:	00 00       	nop
  ba:	04 00       	.word	0x0004	; ????
  bc:	00 00       	nop
  be:	00 00       	nop
  c0:	b8 08       	sbc	r11, r8
  c2:	00 00       	nop
  c4:	0c 00       	.word	0x000c	; ????
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	f0 05       	cpc	r31, r0
       2:	00 00       	nop
       4:	02 00       	.word	0x0002	; ????
       6:	00 00       	nop
       8:	00 00       	nop
       a:	04 01       	movw	r0, r8
	...
      14:	02 0f       	add	r16, r18
      16:	00 00       	nop
      18:	00 01       	movw	r0, r0
      1a:	08 03       	fmul	r16, r16
      1c:	17 00       	.word	0x0017	; ????
      1e:	00 00       	nop
      20:	02 07       	cpc	r16, r18
      22:	04 14       	cp	r0, r4
      24:	00 00       	nop
      26:	00 05       	cpc	r16, r0
      28:	1b 00       	.word	0x001b	; ????
      2a:	00 00       	nop
      2c:	ff 03       	fmulsu	r23, r23
      2e:	00 06       	cpc	r0, r16
      30:	20 00       	.word	0x0020	; ????
      32:	00 00       	nop
      34:	00 00       	nop
      36:	22 00       	.word	0x0022	; ????
      38:	00 00       	nop
      3a:	01 05       	cpc	r16, r1
      3c:	03 00       	.word	0x0003	; ????
      3e:	00 81       	ld	r16, Z
      40:	00 07       	cpc	r16, r16
      42:	29 00       	.word	0x0029	; ????
      44:	00 00       	nop
      46:	00 00       	nop
      48:	14 00       	.word	0x0014	; ????
      4a:	00 00       	nop
      4c:	01 05       	cpc	r16, r1
      4e:	03 c6       	rjmp	.+3078   	; 0xc56 <__data_load_end+0x354>
      50:	00 80       	ld	r0, Z
      52:	00 08       	sbc	r0, r0
      54:	2e 00       	.word	0x002e	; ????
      56:	00 00       	nop
      58:	00 00       	nop
      5a:	14 00       	.word	0x0014	; ????
      5c:	00 00       	nop
      5e:	01 05       	cpc	r16, r1
      60:	03 c0       	rjmp	.+6      	; 0x68 <__trampolines_end>
      62:	00 80       	ld	r0, Z
      64:	00 09       	sbc	r16, r0
      66:	35 00       	.word	0x0035	; ????
      68:	00 00       	nop
      6a:	00 00       	nop
      6c:	14 00       	.word	0x0014	; ????
      6e:	00 00       	nop
      70:	01 05       	cpc	r16, r1
      72:	03 c1       	rjmp	.+518    	; 0x27a <_Z17Serial0_availablev+0x8>
      74:	00 80       	ld	r0, Z
      76:	00 0a       	sbc	r0, r16
      78:	3c 00       	.word	0x003c	; ????
      7a:	00 00       	nop
      7c:	00 00       	nop
      7e:	14 00       	.word	0x0014	; ????
      80:	00 00       	nop
      82:	01 05       	cpc	r16, r1
      84:	03 c2       	rjmp	.+1030   	; 0x48c <__vector_19+0x6>
      86:	00 80       	ld	r0, Z
      88:	00 0b       	sbc	r16, r16
      8a:	43 00       	.word	0x0043	; ????
      8c:	00 00       	nop
      8e:	00 00       	nop
      90:	1b 00       	.word	0x001b	; ????
      92:	00 00       	nop
      94:	01 05       	cpc	r16, r1
      96:	03 c4       	rjmp	.+2054   	; 0x89e <_GLOBAL__sub_I___vector_18+0x40>
      98:	00 80       	ld	r0, Z
      9a:	00 0c       	add	r0, r0
      9c:	49 00       	.word	0x0049	; ????
      9e:	00 00       	nop
      a0:	00 00       	nop
      a2:	14 00       	.word	0x0014	; ????
      a4:	00 00       	nop
      a6:	01 05       	cpc	r16, r1
      a8:	03 bd       	out	0x23, r16	; 35
      aa:	00 80       	ld	r0, Z
      ac:	00 0d       	add	r16, r0
      ae:	4f 00       	.word	0x004f	; ????
      b0:	00 00       	nop
      b2:	00 00       	nop
      b4:	14 00       	.word	0x0014	; ????
      b6:	00 00       	nop
      b8:	01 05       	cpc	r16, r1
      ba:	03 b8       	out	0x03, r0	; 3
      bc:	00 80       	ld	r0, Z
      be:	00 0e       	add	r0, r16
      c0:	54 00       	.word	0x0054	; ????
      c2:	00 00       	nop
      c4:	00 00       	nop
      c6:	14 00       	.word	0x0014	; ????
      c8:	00 00       	nop
      ca:	01 05       	cpc	r16, r1
      cc:	03 bc       	out	0x23, r0	; 35
      ce:	00 80       	ld	r0, Z
      d0:	00 0f       	add	r16, r16
      d2:	59 00       	.word	0x0059	; ????
      d4:	00 00       	nop
      d6:	00 00       	nop
      d8:	14 00       	.word	0x0014	; ????
      da:	00 00       	nop
      dc:	01 05       	cpc	r16, r1
      de:	03 b9       	out	0x03, r16	; 3
      e0:	00 80       	ld	r0, Z
      e2:	00 10       	cpse	r0, r0
      e4:	5e 00       	.word	0x005e	; ????
      e6:	00 00       	nop
      e8:	00 00       	nop
      ea:	14 00       	.word	0x0014	; ????
      ec:	00 00       	nop
      ee:	01 05       	cpc	r16, r1
      f0:	03 bb       	out	0x13, r16	; 19
      f2:	00 80       	ld	r0, Z
      f4:	00 11       	cpse	r16, r0
      f6:	63 00       	.word	0x0063	; ????
      f8:	00 00       	nop
      fa:	00 00       	nop
      fc:	14 00       	.word	0x0014	; ????
      fe:	00 00       	nop
     100:	01 05       	cpc	r16, r1
     102:	03 ba       	out	0x13, r0	; 19
     104:	00 80       	ld	r0, Z
     106:	00 12       	cpse	r0, r16
     108:	68 00       	.word	0x0068	; ????
     10a:	00 00       	nop
     10c:	00 00       	nop
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
     10e:	14 00       	.word	0x0014	; ????
     110:	00 00       	nop
     112:	01 05       	cpc	r16, r1
	uint8_t bit = digitalPinToBitMask(pin);
     114:	03 6f       	ori	r16, 0xF3	; 243
     116:	00 80       	ld	r0, Z
     118:	00 13       	cpse	r16, r16
	uint8_t port = digitalPinToPort(pin);
     11a:	6f 00       	.word	0x006f	; ????
     11c:	00 00       	nop
     11e:	00 00       	nop
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     120:	14 00       	.word	0x0014	; ????
     122:	00 00       	nop

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     124:	01 05       	cpc	r16, r1
     126:	03 36       	cpi	r16, 0x63	; 99
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     128:	00 80       	ld	r0, Z
     12a:	00 14       	cp	r0, r0
     12c:	75 00       	.word	0x0075	; ????
     12e:	00 00       	nop
     130:	00 00       	nop
     132:	14 00       	.word	0x0014	; ????
     134:	00 00       	nop

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
     136:	01 05       	cpc	r16, r1
     138:	03 80       	ldd	r0, Z+3	; 0x03
     13a:	00 80       	ld	r0, Z
     13c:	00 15       	cp	r16, r0
     13e:	7c 00       	.word	0x007c	; ????
     140:	00 00       	nop
     142:	00 00       	nop

	uint8_t oldSREG = SREG;
     144:	14 00       	.word	0x0014	; ????
	cli();
     146:	00 00       	nop

	if (val == LOW) {
		*out &= ~bit;
     148:	01 05       	cpc	r16, r1
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
     14a:	03 81       	ldd	r16, Z+3	; 0x03
     14c:	00 80       	ld	r0, Z
		*out &= ~bit;
     14e:	00 16       	cp	r0, r16
     150:	83 00       	.word	0x0083	; ????
	} else {
		*out |= bit;
     152:	00 00       	nop
	}

	SREG = oldSREG;
     154:	00 00       	nop
}
     156:	14 00       	.word	0x0014	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     158:	00 00       	nop
     15a:	01 05       	cpc	r16, r1
     15c:	03 82       	std	Z+3, r0	; 0x03
     15e:	00 80       	ld	r0, Z
     160:	00 17       	cp	r16, r16
     162:	8a 00       	.word	0x008a	; ????
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     164:	00 00       	nop
     166:	00 00       	nop
     168:	1b 00       	.word	0x001b	; ????
     16a:	00 00       	nop
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     16c:	01 05       	cpc	r16, r1
     16e:	03 84       	ldd	r0, Z+11	; 0x0b
     170:	00 80       	ld	r0, Z
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     172:	00 18       	sub	r0, r0
     174:	90 00       	.word	0x0090	; ????
     176:	00 00       	nop
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     178:	00 00       	nop
     17a:	1b 00       	.word	0x001b	; ????
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     17c:	00 00       	nop
     17e:	01 05       	cpc	r16, r1
     180:	03 88       	ldd	r0, Z+19	; 0x13
     182:	00 80       	ld	r0, Z
     184:	00 19       	sub	r16, r0
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     186:	96 00       	.word	0x0096	; ????
     188:	00 00       	nop
     18a:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     18c:	1b 00       	.word	0x001b	; ????
     18e:	00 00       	nop
     190:	01 05       	cpc	r16, r1
     192:	03 8a       	std	Z+19, r0	; 0x13
     194:	00 80       	ld	r0, Z
     196:	00 1a       	sub	r0, r16
     198:	9c 00       	.word	0x009c	; ????
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
     19a:	00 00       	nop
     19c:	00 00       	nop

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     19e:	1b 00       	.word	0x001b	; ????
     1a0:	00 00       	nop
     1a2:	01 05       	cpc	r16, r1
     1a4:	03 86       	std	Z+11, r0	; 0x0b
     1a6:	00 80       	ld	r0, Z
     1a8:	00 1b       	sub	r16, r16
     1aa:	a1 00       	.word	0x00a1	; ????
     1ac:	00 00       	nop
     1ae:	00 00       	nop
     1b0:	14 00       	.word	0x0014	; ????
     1b2:	00 00       	nop
     1b4:	01 05       	cpc	r16, r1
     1b6:	03 43       	sbci	r16, 0x33	; 51
     1b8:	00 80       	ld	r0, Z
     1ba:	00 1c       	adc	r0, r0
     1bc:	a7 00       	.word	0x00a7	; ????
     1be:	00 00       	nop
     1c0:	00 00       	nop
     1c2:	14 00       	.word	0x0014	; ????
  size_t n = 0;
  while (size--) {
     1c4:	00 00       	nop
     1c6:	01 05       	cpc	r16, r1
     1c8:	03 70       	andi	r16, 0x03	; 3
    if (write(*buffer++)) n++;
     1ca:	00 80       	ld	r0, Z
     1cc:	00 1d       	adc	r16, r0
     1ce:	ae 00       	.word	0x00ae	; ????
     1d0:	00 00       	nop
     1d2:	00 00       	nop
     1d4:	14 00       	.word	0x0014	; ????
     1d6:	00 00       	nop
     1d8:	01 05       	cpc	r16, r1
     1da:	03 37       	cpi	r16, 0x73	; 115
     1dc:	00 80       	ld	r0, Z
     1de:	00 1e       	adc	r0, r16
    else break;
  }
  return n;
}
     1e0:	b4 00       	.word	0x00b4	; ????
     1e2:	00 00       	nop
     1e4:	00 00       	nop
     1e6:	14 00       	.word	0x0014	; ????
     1e8:	00 00       	nop
     1ea:	01 05       	cpc	r16, r1
     1ec:	03 b0       	in	r0, 0x03	; 3
     1ee:	00 80       	ld	r0, Z
     1f0:	00 1f       	adc	r16, r16
     1f2:	bb 00       	.word	0x00bb	; ????
     1f4:	00 00       	nop
     1f6:	00 00       	nop
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     1f8:	14 00       	.word	0x0014	; ????
     1fa:	00 00       	nop
    tail = _tx_buffer_tail;
     1fc:	01 05       	cpc	r16, r1
     1fe:	03 b1       	in	r16, 0x03	; 3
     200:	00 80       	ld	r0, Z
     202:	00 20       	and	r0, r0
     204:	c2 00       	.word	0x00c2	; ????
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     206:	00 00       	nop
     208:	00 00       	nop
     20a:	14 00       	.word	0x0014	; ????
     20c:	00 00       	nop
     20e:	01 05       	cpc	r16, r1
     210:	03 b2       	in	r0, 0x13	; 19
  return tail - head - 1;
     212:	00 80       	ld	r0, Z
}
     214:	00 21       	and	r16, r0
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     216:	c8 00       	.word	0x00c8	; ????
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     218:	00 00       	nop
     21a:	00 00       	nop
     21c:	14 00       	.word	0x0014	; ????
     21e:	00 00       	nop
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     220:	01 05       	cpc	r16, r1
     222:	03 b4       	in	r0, 0x23	; 35
     224:	00 80       	ld	r0, Z
     226:	00 22       	and	r0, r16
     228:	ce 00       	.word	0x00ce	; ????
     22a:	00 00       	nop
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     22c:	00 00       	nop
     22e:	14 00       	.word	0x0014	; ????
     230:	00 00       	nop
     232:	01 05       	cpc	r16, r1
    return c;
     234:	03 b3       	in	r16, 0x13	; 19
     236:	00 80       	ld	r0, Z

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     238:	00 23       	and	r16, r16
     23a:	d4 00       	.word	0x00d4	; ????
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     23c:	00 00       	nop
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     23e:	00 00       	nop
  if (_rx_buffer_head == _rx_buffer_tail) {
     240:	14 00       	.word	0x0014	; ????
     242:	00 00       	nop
     244:	01 05       	cpc	r16, r1
     246:	03 b6       	in	r0, 0x33	; 51
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     248:	00 80       	ld	r0, Z
     24a:	00 24       	eor	r0, r0
     24c:	d9 00       	.word	0x00d9	; ????
     24e:	00 00       	nop
     250:	00 00       	nop
     252:	14 00       	.word	0x0014	; ????
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     254:	00 00       	nop
     256:	01 05       	cpc	r16, r1
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     258:	03 43       	sbci	r16, 0x33	; 51
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     25a:	00 80       	ld	r0, Z
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     25c:	00 25       	eor	r16, r0
     25e:	df 00       	.word	0x00df	; ????
     260:	00 00       	nop
     262:	00 00       	nop
     264:	14 00       	.word	0x0014	; ????
     266:	00 00       	nop
     268:	01 05       	cpc	r16, r1
     26a:	03 7c       	andi	r16, 0xC3	; 195
}
     26c:	00 80       	ld	r0, Z
     26e:	00 26       	eor	r0, r16
     270:	e5 00       	.word	0x00e5	; ????
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     272:	00 00       	nop
     274:	00 00       	nop
     276:	1b 00       	.word	0x001b	; ????
     278:	00 00       	nop
     27a:	01 05       	cpc	r16, r1
     27c:	03 78       	andi	r16, 0x83	; 131
     27e:	00 80       	ld	r0, Z
     280:	00 27       	eor	r16, r16
}
     282:	e9 00       	.word	0x00e9	; ????
     284:	00 00       	nop
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     286:	00 00       	nop
     288:	14 00       	.word	0x0014	; ????
     28a:	00 00       	nop
     28c:	01 05       	cpc	r16, r1
     28e:	03 7a       	andi	r16, 0xA3	; 163
     290:	00 80       	ld	r0, Z
     292:	00 28       	or	r0, r0
     294:	f0 00       	.word	0x00f0	; ????
     296:	00 00       	nop
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     298:	00 00       	nop
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     29a:	14 00       	.word	0x0014	; ????
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     29c:	00 00       	nop
     29e:	01 05       	cpc	r16, r1
     2a0:	03 7b       	andi	r16, 0xB3	; 179
     2a2:	00 80       	ld	r0, Z
     2a4:	00 29       	or	r16, r0
     2a6:	f7 00       	.word	0x00f7	; ????
     2a8:	00 00       	nop
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     2aa:	00 00       	nop
     2ac:	14 00       	.word	0x0014	; ????
     2ae:	00 00       	nop
     2b0:	01 05       	cpc	r16, r1
     2b2:	03 7e       	andi	r16, 0xE3	; 227
     2b4:	00 80       	ld	r0, Z

  *_udr = c;
     2b6:	00 2a       	or	r0, r16
     2b8:	fd 00       	.word	0x00fd	; ????
     2ba:	00 00       	nop
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     2bc:	00 00       	nop
     2be:	14 00       	.word	0x0014	; ????
     2c0:	00 00       	nop
     2c2:	01 05       	cpc	r16, r1
     2c4:	03 50       	subi	r16, 0x03	; 3
     2c6:	00 80       	ld	r0, Z
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     2c8:	00 2b       	or	r16, r16
     2ca:	02 01       	movw	r0, r4
     2cc:	00 00       	nop
     2ce:	00 00       	nop
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     2d0:	14 00       	.word	0x0014	; ????
     2d2:	00 00       	nop
     2d4:	01 05       	cpc	r16, r1
     2d6:	03 7f       	andi	r16, 0xF3	; 243
     2d8:	00 80       	ld	r0, Z
     2da:	00 2c       	mov	r0, r0
  }
}
     2dc:	08 01       	movw	r0, r16
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     2de:	00 00       	nop
     2e0:	00 00       	nop
     2e2:	14 00       	.word	0x0014	; ????
     2e4:	00 00       	nop
     2e6:	01 05       	cpc	r16, r1
     2e8:	03 25       	eor	r16, r3
     2ea:	00 80       	ld	r0, Z
  _written = true;
     2ec:	00 2d       	mov	r16, r0
     2ee:	0e 01       	movw	r0, r28
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     2f0:	00 00       	nop
     2f2:	00 00       	nop
     2f4:	14 00       	.word	0x0014	; ????
     2f6:	00 00       	nop
     2f8:	01 05       	cpc	r16, r1
     2fa:	03 24       	eor	r0, r3
     2fc:	00 80       	ld	r0, Z
     2fe:	00 2e       	mov	r0, r16
     300:	13 01       	movw	r2, r6
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     302:	00 00       	nop
     304:	00 00       	nop
      *_udr = c;
     306:	14 00       	.word	0x0014	; ????
     308:	00 00       	nop
     30a:	01 05       	cpc	r16, r1
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     30c:	03 23       	and	r16, r19
     30e:	00 80       	ld	r0, Z
     310:	00 2f       	mov	r16, r16
     312:	18 01       	movw	r2, r16
     314:	00 00       	nop
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
     316:	00 00       	nop
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     318:	14 00       	.word	0x0014	; ????
  }
  
  return 1;
}
     31a:	00 00       	nop
     31c:	01 05       	cpc	r16, r1
     31e:	03 28       	or	r0, r3
     320:	00 80       	ld	r0, Z
     322:	00 30       	cpi	r16, 0x00	; 0
     324:	1e 01       	movw	r2, r28
     326:	00 00       	nop
     328:	00 00       	nop
     32a:	14 00       	.word	0x0014	; ????
     32c:	00 00       	nop
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     32e:	01 05       	cpc	r16, r1
     330:	03 27       	eor	r16, r19
     332:	00 80       	ld	r0, Z
     334:	00 31       	cpi	r16, 0x10	; 16
     336:	23 01       	movw	r4, r6
     338:	00 00       	nop
     33a:	00 00       	nop
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     33c:	14 00       	.word	0x0014	; ????
     33e:	00 00       	nop
     340:	01 05       	cpc	r16, r1
    if (bit_is_clear(SREG, SREG_I)) {
     342:	03 26       	eor	r0, r19
     344:	00 80       	ld	r0, Z
     346:	00 32       	cpi	r16, 0x20	; 32
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     348:	28 01       	movw	r4, r16
     34a:	00 00       	nop
     34c:	00 00       	nop
     34e:	14 00       	.word	0x0014	; ????
     350:	00 00       	nop
	_tx_udr_empty_irq();
     352:	01 05       	cpc	r16, r1
     354:	03 2b       	or	r16, r19
     356:	00 80       	ld	r0, Z
     358:	00 33       	cpi	r16, 0x30	; 48
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     35a:	2e 01       	movw	r4, r28
     35c:	00 00       	nop
     35e:	00 00       	nop
     360:	14 00       	.word	0x0014	; ????
     362:	00 00       	nop
     364:	01 05       	cpc	r16, r1
     366:	03 2a       	or	r0, r19

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     368:	00 80       	ld	r0, Z
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     36a:	00 34       	cpi	r16, 0x40	; 64
    _tx_buffer_head = i;
     36c:	33 01       	movw	r6, r6
    sbi(*_ucsrb, UDRIE0);
     36e:	00 00       	nop
     370:	00 00       	nop
     372:	14 00       	.word	0x0014	; ????
     374:	00 00       	nop
     376:	01 05       	cpc	r16, r1
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     378:	03 29       	or	r16, r3
     37a:	00 80       	ld	r0, Z
     37c:	00 35       	cpi	r16, 0x50	; 80
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     37e:	38 01       	movw	r6, r16
     380:	00 00       	nop
     382:	00 00       	nop
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     384:	14 00       	.word	0x0014	; ????
     386:	00 00       	nop
     388:	01 05       	cpc	r16, r1
     38a:	03 48       	sbci	r16, 0x83	; 131
     38c:	00 80       	ld	r0, Z
     38e:	00 36       	cpi	r16, 0x60	; 96
     390:	3e 01       	movw	r6, r28
     392:	00 00       	nop
     394:	00 00       	nop
     396:	14 00       	.word	0x0014	; ????
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     398:	00 00       	nop
     39a:	01 05       	cpc	r16, r1
     39c:	03 47       	sbci	r16, 0x73	; 115
     39e:	00 80       	ld	r0, Z
     3a0:	00 37       	cpi	r16, 0x70	; 112
     3a2:	44 01       	movw	r8, r8
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     3a4:	00 00       	nop
     3a6:	00 00       	nop
     3a8:	14 00       	.word	0x0014	; ????
	  _tx_udr_empty_irq();
     3aa:	00 00       	nop
     3ac:	01 05       	cpc	r16, r1
     3ae:	03 46       	sbci	r16, 0x63	; 99
     3b0:	00 80       	ld	r0, Z
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     3b2:	00 38       	cpi	r16, 0x80	; 128
     3b4:	4a 01       	movw	r8, r20
     3b6:	00 00       	nop
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
     3b8:	00 00       	nop
     3ba:	14 00       	.word	0x0014	; ????
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
     3bc:	00 00       	nop
     3be:	01 05       	cpc	r16, r1
     3c0:	03 45       	sbci	r16, 0x53	; 83
     3c2:	00 80       	ld	r0, Z
     3c4:	00 39       	cpi	r16, 0x90	; 144
     3c6:	51 01       	movw	r10, r2
     3c8:	00 00       	nop
     3ca:	00 00       	nop
     3cc:	14 00       	.word	0x0014	; ????
     3ce:	00 00       	nop
     3d0:	01 05       	cpc	r16, r1
     3d2:	03 44       	sbci	r16, 0x43	; 67
     3d4:	00 80       	ld	r0, Z
     3d6:	00 3a       	cpi	r16, 0xA0	; 160
     3d8:	58 01       	movw	r10, r16
     3da:	00 00       	nop
     3dc:	00 00       	nop
     3de:	14 00       	.word	0x0014	; ????
     3e0:	00 00       	nop
     3e2:	01 05       	cpc	r16, r1
     3e4:	03 6e       	ori	r16, 0xE3	; 227
     3e6:	00 80       	ld	r0, Z
{
  size_t n = print(c);
  n += println();
  return n;
}
     3e8:	00 3b       	cpi	r16, 0xB0	; 176
     3ea:	5f 01       	movw	r10, r30
     3ec:	00 00       	nop
     3ee:	00 00       	nop
     3f0:	14 00       	.word	0x0014	; ????
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     3f2:	00 00       	nop
     3f4:	01 05       	cpc	r16, r1
     3f6:	03 35       	cpi	r16, 0x53	; 83
     3f8:	00 80       	ld	r0, Z
     3fa:	00 3c       	cpi	r16, 0xC0	; 192
     3fc:	65 01       	movw	r12, r10
     3fe:	00 00       	nop
     400:	00 00       	nop
     402:	14 00       	.word	0x0014	; ????
     404:	00 00       	nop
     406:	01 05       	cpc	r16, r1
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     408:	03 43       	sbci	r16, 0x33	; 51
     40a:	00 80       	ld	r0, Z
     40c:	00 3d       	cpi	r16, 0xD0	; 208
     40e:	6b 01       	movw	r12, r22
     410:	00 00       	nop
     412:	00 00       	nop
     414:	14 00       	.word	0x0014	; ????
     416:	00 00       	nop
	unsigned char f = timer0_fract;
     418:	01 05       	cpc	r16, r1
     41a:	03 69       	ori	r16, 0x93	; 147

	m += MILLIS_INC;
	f += FRACT_INC;
     41c:	00 80       	ld	r0, Z
     41e:	00 3e       	cpi	r16, 0xE0	; 224
	if (f >= FRACT_MAX) {
     420:	71 01       	movw	r14, r2
     422:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     424:	00 00       	nop
     426:	14 00       	.word	0x0014	; ????
     428:	00 00       	nop
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
     42a:	01 05       	cpc	r16, r1
     42c:	03 3d       	cpi	r16, 0xD3	; 211
	timer0_millis = m;
     42e:	00 80       	ld	r0, Z
     430:	00 3f       	cpi	r16, 0xF0	; 240
     432:	77 01       	movw	r14, r14
     434:	00 00       	nop
     436:	00 00       	nop
     438:	14 00       	.word	0x0014	; ????
     43a:	00 00       	nop
     43c:	01 05       	cpc	r16, r1
	timer0_overflow_count++;
     43e:	03 3c       	cpi	r16, 0xC3	; 195
     440:	00 80       	ld	r0, Z
     442:	00 40       	sbci	r16, 0x00	; 0
     444:	7c 01       	movw	r14, r24
     446:	00 00       	nop
     448:	00 00       	nop
     44a:	14 00       	.word	0x0014	; ????
     44c:	00 00       	nop
     44e:	01 05       	cpc	r16, r1
     450:	03 68       	ori	r16, 0x83	; 131
     452:	00 80       	ld	r0, Z
     454:	00 41       	sbci	r16, 0x10	; 16
     456:	82 01       	movw	r16, r4
     458:	00 00       	nop
     45a:	00 00       	nop
     45c:	14 00       	.word	0x0014	; ????
     45e:	00 00       	nop
     460:	01 05       	cpc	r16, r1
     462:	03 6d       	ori	r16, 0xD3	; 211
}
     464:	00 80       	ld	r0, Z
     466:	00 42       	sbci	r16, 0x20	; 32
     468:	89 01       	movw	r16, r18
     46a:	00 00       	nop
     46c:	00 00       	nop
     46e:	14 00       	.word	0x0014	; ????
     470:	00 00       	nop
     472:	01 05       	cpc	r16, r1
     474:	03 6c       	ori	r16, 0xC3	; 195
     476:	00 80       	ld	r0, Z
     478:	00 43       	sbci	r16, 0x30	; 48
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     47a:	90 01       	movw	r18, r0
     47c:	00 00       	nop
		m += 1;
     47e:	00 00       	nop
     480:	14 00       	.word	0x0014	; ????
     482:	00 00       	nop
     484:	01 05       	cpc	r16, r1
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     486:	03 6b       	ori	r16, 0xB3	; 179
     488:	00 80       	ld	r0, Z
     48a:	00 44       	sbci	r16, 0x40	; 64
     48c:	97 01       	movw	r18, r14
     48e:	00 00       	nop
     490:	00 00       	nop
     492:	14 00       	.word	0x0014	; ????
     494:	00 00       	nop
     496:	01 05       	cpc	r16, r1
     498:	03 3b       	cpi	r16, 0xB3	; 179
     49a:	00 80       	ld	r0, Z
     49c:	00 45       	sbci	r16, 0x50	; 80
     49e:	9d 01       	movw	r18, r26
     4a0:	00 00       	nop
     4a2:	00 00       	nop
     4a4:	14 00       	.word	0x0014	; ????
     4a6:	00 00       	nop
  Serial._tx_udr_empty_irq();
     4a8:	01 05       	cpc	r16, r1
     4aa:	03 4e       	sbci	r16, 0xE3	; 227
     4ac:	00 80       	ld	r0, Z
     4ae:	00 46       	sbci	r16, 0x60	; 96
}
     4b0:	a2 01       	movw	r20, r4
     4b2:	00 00       	nop
     4b4:	00 00       	nop
     4b6:	14 00       	.word	0x0014	; ????
     4b8:	00 00       	nop
     4ba:	01 05       	cpc	r16, r1
     4bc:	03 4d       	sbci	r16, 0xD3	; 211
     4be:	00 80       	ld	r0, Z
     4c0:	00 47       	sbci	r16, 0x70	; 112
     4c2:	a7 01       	movw	r20, r14
     4c4:	00 00       	nop
     4c6:	00 00       	nop
     4c8:	14 00       	.word	0x0014	; ????
     4ca:	00 00       	nop
     4cc:	01 05       	cpc	r16, r1
     4ce:	03 4c       	sbci	r16, 0xC3	; 195
     4d0:	00 80       	ld	r0, Z
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     4d2:	00 48       	sbci	r16, 0x80	; 128
     4d4:	ac 01       	movw	r20, r24
     4d6:	00 00       	nop
     4d8:	00 00       	nop
     4da:	14 00       	.word	0x0014	; ????
     4dc:	00 00       	nop
     4de:	01 05       	cpc	r16, r1
     4e0:	03 60       	ori	r16, 0x03	; 3
     4e2:	00 80       	ld	r0, Z
     4e4:	00 49       	sbci	r16, 0x90	; 144

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     4e6:	b3 01       	movw	r22, r6
     4e8:	00 00       	nop
     4ea:	00 00       	nop
     4ec:	14 00       	.word	0x0014	; ????
     4ee:	00 00       	nop
     4f0:	01 05       	cpc	r16, r1
     4f2:	03 64       	ori	r16, 0x43	; 67
     4f4:	00 80       	ld	r0, Z
     4f6:	00 4a       	sbci	r16, 0xA0	; 160
     4f8:	b7 01       	movw	r22, r14
     4fa:	00 00       	nop
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     4fc:	00 00       	nop
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     4fe:	14 00       	.word	0x0014	; ????
     500:	00 00       	nop
     502:	01 05       	cpc	r16, r1
     504:	03 66       	ori	r16, 0x63	; 99

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     506:	00 80       	ld	r0, Z
     508:	00 4b       	sbci	r16, 0xB0	; 176
     50a:	be 01       	movw	r22, r28
     50c:	00 00       	nop
      _rx_buffer[_rx_buffer_head] = c;
     50e:	00 00       	nop
     510:	14 00       	.word	0x0014	; ????
     512:	00 00       	nop
     514:	01 05       	cpc	r16, r1
     516:	03 61       	ori	r16, 0x13	; 19
     518:	00 80       	ld	r0, Z
      _rx_buffer_head = i;
     51a:	00 4c       	sbci	r16, 0xC0	; 192
     51c:	c4 01       	movw	r24, r8
    Serial._rx_complete_irq();
  }
     51e:	00 00       	nop
     520:	00 00       	nop
     522:	14 00       	.word	0x0014	; ????
     524:	00 00       	nop
     526:	01 05       	cpc	r16, r1
     528:	03 5f       	subi	r16, 0xF3	; 243
     52a:	00 80       	ld	r0, Z
     52c:	00 4d       	sbci	r16, 0xD0	; 208
     52e:	c9 01       	movw	r24, r18
     530:	00 00       	nop
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     532:	00 00       	nop
     534:	1b 00       	.word	0x001b	; ????

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     536:	00 00       	nop
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     538:	01 05       	cpc	r16, r1
     53a:	03 5d       	subi	r16, 0xD3	; 211
     53c:	00 80       	ld	r0, Z
	sbi(TCCR0A, WGM00);
     53e:	00 4e       	sbci	r16, 0xE0	; 224
     540:	cc 01       	movw	r24, r24
     542:	00 00       	nop
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     544:	00 00       	nop
     546:	14 00       	.word	0x0014	; ????
     548:	00 00       	nop
	sbi(TCCR0B, CS00);
     54a:	01 05       	cpc	r16, r1
     54c:	03 57       	subi	r16, 0x73	; 115
     54e:	00 80       	ld	r0, Z

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     550:	00 4f       	sbci	r16, 0xF0	; 240
     552:	d3 01       	movw	r26, r6
     554:	00 00       	nop
     556:	00 00       	nop
     558:	14 00       	.word	0x0014	; ????
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     55a:	00 00       	nop
     55c:	01 05       	cpc	r16, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     55e:	03 55       	subi	r16, 0x53	; 83
     560:	00 80       	ld	r0, Z
     562:	00 50       	subi	r16, 0x00	; 0
     564:	d9 01       	movw	r26, r18
     566:	00 00       	nop
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     568:	00 00       	nop
     56a:	14 00       	.word	0x0014	; ????
     56c:	00 00       	nop
     56e:	01 05       	cpc	r16, r1
     570:	03 54       	subi	r16, 0x43	; 67
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     572:	00 80       	ld	r0, Z
     574:	00 51       	subi	r16, 0x10	; 16
     576:	df 01       	movw	r26, r30
     578:	00 00       	nop
     57a:	00 00       	nop

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     57c:	14 00       	.word	0x0014	; ????
     57e:	00 00       	nop
     580:	01 05       	cpc	r16, r1
     582:	03 53       	subi	r16, 0x33	; 51
     584:	00 80       	ld	r0, Z

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     586:	00 52       	subi	r16, 0x20	; 32
     588:	e4 01       	movw	r28, r8
     58a:	00 00       	nop
     58c:	00 00       	nop
     58e:	14 00       	.word	0x0014	; ????
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     590:	00 00       	nop
     592:	01 05       	cpc	r16, r1
     594:	03 4b       	sbci	r16, 0xB3	; 179
     596:	00 80       	ld	r0, Z
     598:	00 53       	subi	r16, 0x30	; 48
		sbi(ADCSRA, ADPS1);
     59a:	eb 01       	movw	r28, r22
     59c:	00 00       	nop
     59e:	00 00       	nop
     5a0:	14 00       	.word	0x0014	; ????
     5a2:	00 00       	nop
		sbi(ADCSRA, ADPS0);
     5a4:	01 05       	cpc	r16, r1
     5a6:	03 4a       	sbci	r16, 0xA3	; 163
     5a8:	00 80       	ld	r0, Z
     5aa:	00 54       	subi	r16, 0x40	; 64
     5ac:	f2 01       	movw	r30, r4
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     5ae:	00 00       	nop
     5b0:	00 00       	nop
     5b2:	14 00       	.word	0x0014	; ????
     5b4:	00 00       	nop
     5b6:	01 05       	cpc	r16, r1
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     5b8:	03 3e       	cpi	r16, 0xE3	; 227
     5ba:	00 80       	ld	r0, Z
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
     5bc:	00 55       	subi	r16, 0x50	; 80
     5be:	f9 01       	movw	r30, r18
     5c0:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
     5c2:	00 00       	nop
     5c4:	1b 00       	.word	0x001b	; ????
     5c6:	00 00       	nop
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     5c8:	01 05       	cpc	r16, r1
     5ca:	03 41       	sbci	r16, 0x13	; 19

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     5cc:	00 80       	ld	r0, Z
     5ce:	00 56       	subi	r16, 0x60	; 96
     5d0:	fe 01       	movw	r30, r28
     5d2:	00 00       	nop
     5d4:	00 00       	nop
     5d6:	14 00       	.word	0x0014	; ????
     5d8:	00 00       	nop
     5da:	01 05       	cpc	r16, r1
	out = portOutputRegister(port);
     5dc:	03 40       	sbci	r16, 0x03	; 3
     5de:	00 80       	ld	r0, Z
     5e0:	00 57       	subi	r16, 0x70	; 112
     5e2:	03 02       	muls	r16, r19
     5e4:	00 00       	nop
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     5e6:	00 00       	nop
                cli();
     5e8:	14 00       	.word	0x0014	; ????
		*reg |= bit;
     5ea:	00 00       	nop
     5ec:	01 05       	cpc	r16, r1
     5ee:	03 3f       	cpi	r16, 0xF3	; 243
		SREG = oldSREG;
     5f0:	00 80       	ld	r0, Z

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     5f2:	00 00       	nop
     5f4:	cb 13       	cpse	r28, r27
     5f6:	00 00       	nop
     5f8:	02 00       	.word	0x0002	; ????
     5fa:	a2 05       	cpc	r26, r2
     5fc:	00 00       	nop
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     5fe:	04 01       	movw	r0, r8
     600:	8f 06       	cpc	r8, r31
     602:	00 00       	nop
     604:	02 fe       	sbrs	r0, 2
     606:	03 00       	.word	0x0003	; ????
  *_ubrrl = baud_setting;
     608:	00 9f       	mul	r16, r16
     60a:	04 00       	.word	0x0004	; ????
     60c:	00 60       	ori	r16, 0x00	; 0
	...

  _written = false;
     616:	00 00       	nop

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     618:	00 1a       	sub	r0, r16
     61a:	00 00       	nop
     61c:	00 02       	muls	r16, r16
     61e:	1e 02       	muls	r17, r30
     620:	00 00       	nop
     622:	04 06       	cpc	r0, r20
  
  sbi(*_ucsrb, RXEN0);
     624:	25 29       	or	r18, r5
     626:	00 00       	nop
     628:	00 1f       	adc	r16, r16
     62a:	01 00       	.word	0x0001	; ????
     62c:	00 03       	mulsu	r16, r16
     62e:	18 02       	muls	r17, r24
     630:	00 00       	nop
  sbi(*_ucsrb, TXEN0);
     632:	31 01       	movw	r6, r2
     634:	00 00       	nop
     636:	02 23       	and	r16, r18
     638:	00 01       	movw	r0, r0
     63a:	04 68       	ori	r16, 0x84	; 132
     63c:	02 00       	.word	0x0002	; ????
     63e:	00 06       	cpc	r0, r16
  sbi(*_ucsrb, RXCIE0);
     640:	28 2a       	or	r2, r24
     642:	01 00       	.word	0x0001	; ????
     644:	00 02       	muls	r16, r16
     646:	23 02       	muls	r18, r19
     648:	03 05       	cpc	r16, r3
     64a:	93 05       	cpc	r25, r3
     64c:	00 00       	nop
  cbi(*_ucsrb, UDRIE0);
     64e:	02 7e       	andi	r16, 0xE2	; 226
     650:	01 7d       	andi	r16, 0xD1	; 209
     652:	04 00       	.word	0x0004	; ????
     654:	00 01       	movw	r0, r0
     656:	6a 00       	.word	0x006a	; ????
     658:	00 00       	nop
     65a:	71 00       	.word	0x0071	; ????
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
     65c:	00 00       	nop
     65e:	06 f1       	brts	.+64     	; 0x6a0 <__Mult+0x6>
     660:	07 00       	.word	0x0007	; ????
     662:	00 01       	movw	r0, r0
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
     664:	00 07       	cpc	r16, r16
     666:	ab 03       	fmulsu	r18, r19
     668:	00 00       	nop
     66a:	01 7d       	andi	r16, 0xD1	; 209
     66c:	04 00       	.word	0x0004	; ????
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
     66e:	00 01       	movw	r0, r0
     670:	01 85       	ldd	r16, Z+9	; 0x09
     672:	00 00       	nop
     674:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
     678:	00 06       	cpc	r0, r16
     67a:	f1 07       	cpc	r31, r17
     67c:	00 00       	nop
     67e:	01 08       	sbc	r0, r1
     680:	15 08       	sbc	r1, r5
     682:	00 00       	nop
     684:	00 05       	cpc	r16, r0
     686:	34 02       	muls	r19, r20
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
     688:	00 00       	nop
     68a:	06 34       	cpi	r16, 0x46	; 70
     68c:	01 7d       	andi	r16, 0xD1	; 209
     68e:	04 00       	.word	0x0004	; ????
     690:	00 01       	movw	r0, r0
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
     692:	a6 00       	.word	0x00a6	; ????
     694:	00 00       	nop
     696:	b2 00       	.word	0x00b2	; ????
     698:	00 00       	nop
     69a:	06 f1       	brts	.+64     	; 0x6dc <__LDST+0x6>
     69c:	07 00       	.word	0x0007	; ????
     69e:	00 01       	movw	r0, r0
     6a0:	08 15       	cp	r16, r8
     6a2:	08 00       	.word	0x0008	; ????
     6a4:	00 00       	nop
     6a6:	05 93       	las	Z, r16
     6a8:	05 00       	.word	0x0005	; ????
     6aa:	00 02       	muls	r16, r16
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
     6ac:	8a 01       	movw	r16, r20
     6ae:	7d 04       	cpc	r7, r13
     6b0:	00 00       	nop
     6b2:	01 c7       	rjmp	.+3586   	; 0x14b6 <__data_load_end+0xbb4>
     6b4:	00 00       	nop
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
     6b6:	00 d3       	rcall	.+1536   	; 0xcb8 <__data_load_end+0x3b6>
     6b8:	00 00       	nop
     6ba:	00 06       	cpc	r0, r16
     6bc:	f1 07       	cpc	r31, r17
     6be:	00 00       	nop
     6c0:	01 08       	sbc	r0, r1
     6c2:	15 08       	sbc	r1, r5
     6c4:	00 00       	nop
     6c6:	00 09       	sbc	r16, r0
     6c8:	34 02       	muls	r19, r20
     6ca:	00 00       	nop
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
     6cc:	02 22       	and	r0, r18
     6ce:	01 7d       	andi	r16, 0xD1	; 209
     6d0:	04 00       	.word	0x0004	; ????
     6d2:	00 01       	movw	r0, r0
     6d4:	02 10       	cpse	r0, r2
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
     6d6:	01 29       	or	r16, r1
     6d8:	00 00       	nop
     6da:	00 01       	movw	r0, r0
     6dc:	f0 00       	.word	0x00f0	; ????
     6de:	00 00       	nop
     6e0:	01 01       	movw	r0, r2
     6e2:	00 00       	nop
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     6e4:	06 f1       	brts	.+64     	; 0x726 <__main1+0x20>
     6e6:	07 00       	.word	0x0007	; ????
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
     6e8:	00 01       	movw	r0, r0
     6ea:	08 d6       	rcall	.+3088   	; 0x12fc <__data_load_end+0x9fa>
     6ec:	09 00       	.word	0x0009	; ????
     6ee:	00 08       	sbc	r0, r0
  randomSeed(0);
  noInterrupts();
     6f0:	7d 04       	cpc	r7, r13
  
  digitalWrite(LED_BUILTIN, LOW);   
     6f2:	00 00       	nop
     6f4:	00 0a       	sbc	r0, r16
     6f6:	99 04       	cpc	r9, r9
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
     6f8:	00 00       	nop
     6fa:	02 3e       	cpi	r16, 0xE2	; 226
     6fc:	01 7d       	andi	r16, 0xD1	; 209
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
     6fe:	04 00       	.word	0x0004	; ????
     700:	00 01       	movw	r0, r0
     702:	12 01       	movw	r2, r4
     704:	00 00       	nop
     706:	06 f1       	brts	.+64     	; 0x748 <__main1+0x42>
     708:	07 00       	.word	0x0007	; ????
     70a:	00 01       	movw	r0, r0
     70c:	08 15       	cp	r16, r8
     70e:	08 00       	.word	0x0008	; ????
     710:	00 00       	nop
     712:	00 0b       	sbc	r16, r16
     714:	2a 01       	movw	r4, r20
     716:	00 00       	nop
     718:	2a 01       	movw	r4, r20
     71a:	00 00       	nop
     71c:	0c 00       	.word	0x000c	; ????
     71e:	0d 02       	muls	r16, r29
     720:	05 69       	ori	r16, 0x95	; 149
     722:	6e 74       	andi	r22, 0x4E	; 78
     724:	00 0e       	add	r0, r16
     726:	02 37       	cpi	r16, 0x72	; 114
     728:	01 00       	.word	0x0001	; ????
     72a:	00 0f       	add	r16, r16
     72c:	02 bc       	out	0x22, r0	; 34
     72e:	07 00       	.word	0x0007	; ????
     730:	00 1f       	adc	r16, r16
     732:	01 00       	.word	0x0001	; ????
     734:	00 02       	muls	r16, r16
     736:	71 05       	cpc	r23, r1
     738:	00 00       	nop
     73a:	0c 0c       	add	r0, r12
     73c:	31 79       	andi	r19, 0x91	; 145
     73e:	01 00       	.word	0x0001	; ????
     740:	00 79       	andi	r16, 0x90	; 144
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
     742:	01 00       	.word	0x0001	; ????
     744:	00 10       	cpse	r0, r0
     746:	79 01       	movw	r14, r18
     748:	00 00       	nop
     74a:	02 23       	and	r16, r18
     74c:	00 01       	movw	r0, r0
     74e:	04 64       	ori	r16, 0x44	; 68
     750:	07 00       	.word	0x0007	; ????
     752:	00 0c       	add	r0, r0
     754:	34 7f       	andi	r19, 0xF4	; 244
     756:	01 00       	.word	0x0001	; ????
     758:	00 02       	muls	r16, r16
     75a:	23 04       	cpc	r2, r3
     75c:	02 04       	cpc	r0, r2
     75e:	d1 07       	cpc	r29, r17
     760:	00 00       	nop
     762:	0c 35       	cpi	r16, 0x5C	; 92
     764:	7f 01       	movw	r14, r30
     766:	00 00       	nop
     768:	02 23       	and	r16, r18
     76a:	08 02       	muls	r16, r24
     76c:	00 11       	cpse	r16, r0
     76e:	1e 02       	muls	r17, r30
     770:	00 00       	nop
     772:	01 12       	cpse	r0, r17
     774:	04 07       	cpc	r16, r20
     776:	52 06       	cpc	r5, r18
     778:	00 00       	nop
     77a:	13 3c       	cpi	r17, 0xC3	; 195
     77c:	03 00       	.word	0x0003	; ????
     77e:	00 0d       	add	r16, r0
     780:	7e 96       	adiw	r30, 0x1e	; 30
     782:	01 00       	.word	0x0001	; ????
     784:	00 14       	cp	r0, r0
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
     786:	86 01       	movw	r16, r12
     788:	00 00       	nop
     78a:	12 01       	movw	r2, r4
     78c:	08 39       	cpi	r16, 0x98	; 152
     78e:	04 00       	.word	0x0004	; ????
     790:	00 13       	cpse	r16, r16
     792:	3a 02       	muls	r19, r26
     794:	00 00       	nop
     796:	0e 3b       	cpi	r16, 0xBE	; 190
     798:	86 01       	movw	r16, r12
     79a:	00 00       	nop
     79c:	14 9d       	mul	r17, r4
     79e:	01 00       	.word	0x0001	; ????
     7a0:	00 13       	cpse	r16, r16
     7a2:	27 04       	cpc	r2, r7
     7a4:	00 00       	nop
     7a6:	0e 40       	sbci	r16, 0x0E	; 14
     7a8:	86 01       	movw	r16, r12
     7aa:	00 00       	nop
     7ac:	14 ad       	ldd	r17, Z+60	; 0x3c
     7ae:	01 00       	.word	0x0001	; ????
     7b0:	00 02       	muls	r16, r16
     7b2:	fb 05       	cpc	r31, r11
     7b4:	00 00       	nop
     7b6:	9d 0f       	add	r25, r29
     7b8:	5d 79       	andi	r21, 0x9D	; 157
     7ba:	01 00       	.word	0x0001	; ????
     7bc:	00 df       	rcall	.-512    	; 0x5be <main+0x88>
     7be:	03 00       	.word	0x0003	; ????
     7c0:	00 10       	cpse	r0, r0
     7c2:	41 01       	movw	r8, r2
     7c4:	00 00       	nop
     7c6:	02 23       	and	r16, r18
     7c8:	00 01       	movw	r0, r0
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
     7ca:	04 e6       	ldi	r16, 0x64	; 100
     7cc:	03 00       	.word	0x0003	; ????
     7ce:	00 0f       	add	r16, r16
     7d0:	60 e5       	ldi	r22, 0x50	; 80
     7d2:	03 00       	.word	0x0003	; ????
     7d4:	00 02       	muls	r16, r16
     7d6:	23 0c       	add	r2, r3
     7d8:	02 04       	cpc	r0, r2
     7da:	88 06       	cpc	r8, r24
     7dc:	00 00       	nop
     7de:	0f 61       	ori	r16, 0x1F	; 31
     7e0:	e5 03       	fmuls	r22, r21
     7e2:	00 00       	nop
     7e4:	02 23       	and	r16, r18
     7e6:	0e 02       	muls	r16, r30
     7e8:	04 a7       	std	Z+44, r16	; 0x2c
     7ea:	07 00       	.word	0x0007	; ????
     7ec:	00 0f       	add	r16, r16
     7ee:	62 e5       	ldi	r22, 0x52	; 82
     7f0:	03 00       	.word	0x0003	; ????
     7f2:	00 02       	muls	r16, r16
     7f4:	23 10       	cpse	r2, r3
     7f6:	02 04       	cpc	r0, r2
     7f8:	ae 07       	cpc	r26, r30
     7fa:	00 00       	nop
     7fc:	0f 63       	ori	r16, 0x3F	; 63
     7fe:	e5 03       	fmuls	r22, r21
     800:	00 00       	nop
     802:	02 23       	and	r16, r18
     804:	12 02       	muls	r17, r18
     806:	04 b5       	in	r16, 0x24	; 36
     808:	07 00       	.word	0x0007	; ????
     80a:	00 0f       	add	r16, r16
     80c:	64 e5       	ldi	r22, 0x54	; 84
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
     80e:	03 00       	.word	0x0003	; ????
     810:	00 02       	muls	r16, r16
     812:	23 14       	cp	r2, r3
     814:	02 04       	cpc	r0, r2
     816:	de 07       	cpc	r29, r30
     818:	00 00       	nop
     81a:	0f 65       	ori	r16, 0x5F	; 95
     81c:	e5 03       	fmuls	r22, r21
     81e:	00 00       	nop
     820:	02 23       	and	r16, r18
     822:	16 02       	muls	r17, r22
     824:	04 28       	or	r0, r4
     826:	08 00       	.word	0x0008	; ????
     828:	00 0f       	add	r16, r16
     82a:	67 ea       	ldi	r22, 0xA7	; 167
     82c:	03 00       	.word	0x0003	; ????
     82e:	00 02       	muls	r16, r16
     830:	23 18       	sub	r2, r3
     832:	02 04       	cpc	r0, r2
     834:	67 03       	mulsu	r22, r23
     836:	00 00       	nop
     838:	0f 69       	ori	r16, 0x9F	; 159
     83a:	b8 01       	movw	r22, r16
     83c:	00 00       	nop
  Serial.println("End of loop");
     83e:	02 23       	and	r16, r18
     840:	19 02       	muls	r17, r25
     842:	04 24       	eor	r0, r4
     844:	02 00       	.word	0x0002	; ????
  interrupts();
     846:	00 0f       	add	r16, r16
     848:	6a b8       	out	0x0a, r6	; 10
     84a:	01 00       	.word	0x0001	; ????
     84c:	00 02       	muls	r16, r16
     84e:	23 1a       	sub	r2, r19
     850:	02 04       	cpc	r0, r2
     852:	08 02       	muls	r16, r24
     854:	00 00       	nop
     856:	0f 6b       	ori	r16, 0xBF	; 191
     858:	a8 01       	movw	r20, r16
     85a:	00 00       	nop
     85c:	02 23       	and	r16, r18
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     85e:	1b 02       	muls	r17, r27
     860:	04 82       	std	Z+4, r0	; 0x04
     862:	04 00       	.word	0x0004	; ????
     864:	00 0f       	add	r16, r16
     866:	6c a8       	ldd	r6, Y+52	; 0x34
     868:	01 00       	.word	0x0001	; ????
     86a:	00 02       	muls	r16, r16
     86c:	23 1c       	adc	r2, r3
     86e:	02 04       	cpc	r0, r2
     870:	e3 07       	cpc	r30, r19
     872:	00 00       	nop
     874:	0f 71       	andi	r16, 0x1F	; 31
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     876:	f1 03       	fmuls	r23, r17
     878:	00 00       	nop
     87a:	02 23       	and	r16, r18
     87c:	1d 02       	muls	r17, r29
     87e:	04 3a       	cpi	r16, 0xA4	; 164
     880:	06 00       	.word	0x0006	; ????
     882:	00 0f       	add	r16, r16
     884:	72 f1       	brmi	.+92     	; 0x8e2 <__data_load_start+0x1a>
     886:	03 00       	.word	0x0003	; ????
     888:	00 02       	muls	r16, r16
     88a:	23 5d       	subi	r18, 0xD3	; 211
     88c:	02 15       	cp	r16, r2
     88e:	ad 02       	muls	r26, r29
     890:	00 00       	nop
     892:	03 75       	andi	r16, 0x53	; 83
     894:	01 01       	movw	r0, r2
     896:	aa 02       	muls	r26, r26
     898:	00 00       	nop
     89a:	bb 02       	muls	r27, r27
     89c:	00 00       	nop
     89e:	06 79       	andi	r16, 0x96	; 150
     8a0:	06 00       	.word	0x0006	; ????
     8a2:	00 01       	movw	r0, r0
     8a4:	08 7f       	andi	r16, 0xF8	; 248
     8a6:	01 00       	.word	0x0001	; ????
     8a8:	00 08       	sbc	r0, r0
     8aa:	88 04       	cpc	r8, r8
     8ac:	00 00       	nop
     8ae:	00 09       	sbc	r16, r0
     8b0:	d4 03       	fmuls	r21, r20
     8b2:	00 00       	nop
     8b4:	03 c0       	rjmp	.+6      	; 0x8bc <__tablejump2__+0x4>

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
     8b6:	01 2a       	or	r0, r17
     8b8:	01 00       	.word	0x0001	; ????
     8ba:	00 01       	movw	r0, r0
     8bc:	02 10       	cpse	r0, r2
     8be:	02 bd       	out	0x22, r16	; 34
     8c0:	01 00       	.word	0x0001	; ????
     8c2:	00 01       	movw	r0, r0
     8c4:	d8 02       	muls	r29, r24
     8c6:	00 00       	nop
     8c8:	df 02       	muls	r29, r31
     8ca:	00 00       	nop
     8cc:	06 79       	andi	r16, 0x96	; 150
     8ce:	06 00       	.word	0x0006	; ????
     8d0:	00 01       	movw	r0, r0
     8d2:	00 09       	sbc	r16, r0
     8d4:	87 03       	fmuls	r16, r23
     8d6:	00 00       	nop
     8d8:	03 b4       	in	r0, 0x23	; 35
     8da:	01 2a       	or	r0, r17
     8dc:	01 00       	.word	0x0001	; ????
     8de:	00 01       	movw	r0, r0
     8e0:	02 10       	cpse	r0, r2
     8e2:	05 bd       	out	0x25, r16	; 37
     8e4:	01 00       	.word	0x0001	; ????
     8e6:	00 01       	movw	r0, r0
     8e8:	fc 02       	muls	r31, r28
     8ea:	00 00       	nop
     8ec:	03 03       	mulsu	r16, r19
     8ee:	00 00       	nop
     8f0:	06 79       	andi	r16, 0x96	; 150
     8f2:	06 00       	.word	0x0006	; ????
     8f4:	00 01       	movw	r0, r0
     8f6:	00 09       	sbc	r16, r0
     8f8:	30 06       	cpc	r3, r16
     8fa:	00 00       	nop
     8fc:	03 ab       	std	Z+51, r16	; 0x33
     8fe:	01 2a       	or	r0, r17
     900:	01 00       	.word	0x0001	; ????
     902:	00 01       	movw	r0, r0
     904:	02 10       	cpse	r0, r2
     906:	06 bd       	out	0x26, r16	; 38
     908:	01 00       	.word	0x0001	; ????
     90a:	00 01       	movw	r0, r0
     90c:	20 03       	mulsu	r18, r16
     90e:	00 00       	nop
     910:	27 03       	mulsu	r18, r23
     912:	00 00       	nop
     914:	06 79       	andi	r16, 0x96	; 150
     916:	06 00       	.word	0x0006	; ????
     918:	00 01       	movw	r0, r0
     91a:	00 09       	sbc	r16, r0
     91c:	7c 02       	muls	r23, r28
     91e:	00 00       	nop
     920:	03 a6       	std	Z+43, r0	; 0x2b
     922:	01 2a       	or	r0, r17
     924:	01 00       	.word	0x0001	; ????
     926:	00 01       	movw	r0, r0
     928:	02 10       	cpse	r0, r2
     92a:	04 bd       	out	0x24, r16	; 36
     92c:	01 00       	.word	0x0001	; ????
     92e:	00 01       	movw	r0, r0
     930:	44 03       	mulsu	r20, r20
     932:	00 00       	nop
     934:	4b 03       	fmul	r20, r19
     936:	00 00       	nop
     938:	06 79       	andi	r16, 0x96	; 150
     93a:	06 00       	.word	0x0006	; ????
     93c:	00 01       	movw	r0, r0
     93e:	00 16       	cp	r0, r16
     940:	77 07       	cpc	r23, r23
     942:	00 00       	nop
     944:	01 01       	movw	r0, r2
     946:	01 5b       	subi	r16, 0xB1	; 177
     948:	03 00       	.word	0x0003	; ????
     94a:	00 62       	ori	r16, 0x20	; 32
     94c:	03 00       	.word	0x0003	; ????
     94e:	00 06       	cpc	r0, r16
     950:	79 06       	cpc	r7, r25
     952:	00 00       	nop
     954:	01 00       	.word	0x0001	; ????
     956:	15 81       	ldd	r17, Z+5	; 0x05
     958:	05 00       	.word	0x0005	; ????
     95a:	00 03       	mulsu	r16, r16
     95c:	59 01       	movw	r10, r18
     95e:	01 73       	andi	r16, 0x31	; 49
     960:	03 00       	.word	0x0003	; ????
     962:	00 7a       	andi	r16, 0xA0	; 160
     964:	03 00       	.word	0x0003	; ????
     966:	00 06       	cpc	r0, r16
     968:	79 06       	cpc	r7, r25
     96a:	00 00       	nop
     96c:	01 00       	.word	0x0001	; ????
     96e:	09 34       	cpi	r16, 0x49	; 73
     970:	02 00       	.word	0x0002	; ????
     972:	00 03       	mulsu	r16, r16
     974:	e1 01       	movw	r28, r2
     976:	7d 04       	cpc	r7, r13
     978:	00 00       	nop
     97a:	01 02       	muls	r16, r17
     97c:	10 00       	.word	0x0010	; ????
     97e:	bd 01       	movw	r22, r26
     980:	00 00       	nop
     982:	01 97       	sbiw	r24, 0x01	; 1
     984:	03 00       	.word	0x0003	; ????
     986:	00 a3       	std	Z+32, r16	; 0x20
     988:	03 00       	.word	0x0003	; ????
     98a:	00 06       	cpc	r0, r16
     98c:	79 06       	cpc	r7, r25
     98e:	00 00       	nop
     990:	01 08       	sbc	r0, r1
     992:	86 01       	movw	r16, r12
     994:	00 00       	nop
     996:	00 17       	cp	r16, r16
     998:	bf 02       	muls	r27, r31
     99a:	00 00       	nop
     99c:	01 01       	movw	r0, r2
     99e:	02 10       	cpse	r0, r2
     9a0:	03 bd       	out	0x23, r16	; 35
     9a2:	01 00       	.word	0x0001	; ????
     9a4:	00 01       	movw	r0, r0
     9a6:	01 bb       	out	0x11, r16	; 17
     9a8:	03 00       	.word	0x0003	; ????
     9aa:	00 c2       	rjmp	.+1024   	; 0xdac <__data_load_end+0x4aa>
     9ac:	03 00       	.word	0x0003	; ????
     9ae:	00 06       	cpc	r0, r16
     9b0:	79 06       	cpc	r7, r25
     9b2:	00 00       	nop
     9b4:	01 00       	.word	0x0001	; ????
     9b6:	18 a5       	ldd	r17, Y+40	; 0x28
     9b8:	03 00       	.word	0x0003	; ????
     9ba:	00 03       	mulsu	r16, r16
     9bc:	cd 01       	movw	r24, r26
     9be:	01 02       	muls	r16, r17
     9c0:	10 03       	mulsu	r17, r16
     9c2:	bd 01       	movw	r22, r26
     9c4:	00 00       	nop
     9c6:	01 d7       	rcall	.+3586   	; 0x17ca <__data_load_end+0xec8>
     9c8:	03 00       	.word	0x0003	; ????
     9ca:	00 06       	cpc	r0, r16
     9cc:	79 06       	cpc	r7, r25
     9ce:	00 00       	nop
     9d0:	01 00       	.word	0x0001	; ????
     9d2:	00 0e       	add	r0, r16
     9d4:	02 91       	ld	r16, -Z
     9d6:	01 00       	.word	0x0001	; ????
     9d8:	00 19       	sub	r16, r0
     9da:	df 03       	fmulsu	r21, r23
     9dc:	00 00       	nop
     9de:	12 01       	movw	r2, r4
     9e0:	02 59       	subi	r16, 0x92	; 146
     9e2:	03 00       	.word	0x0003	; ????
     9e4:	00 1a       	sub	r0, r16
     9e6:	96 01       	movw	r18, r12
     9e8:	00 00       	nop
     9ea:	01 04       	cpc	r0, r1
     9ec:	00 00       	nop
     9ee:	1b 01       	movw	r2, r22
     9f0:	04 00       	.word	0x0004	; ????
     9f2:	00 3f       	cpi	r16, 0xF0	; 240
     9f4:	00 12       	cpse	r0, r16
     9f6:	02 07       	cpc	r16, r18
     9f8:	57 06       	cpc	r5, r23
     9fa:	00 00       	nop
     9fc:	02 71       	andi	r16, 0x12	; 18
     9fe:	05 00       	.word	0x0005	; ????
     a00:	00 0c       	add	r0, r0
     a02:	0a 31       	cpi	r16, 0x1A	; 26
     a04:	59 04       	cpc	r5, r9
     a06:	00 00       	nop
     a08:	59 04       	cpc	r5, r9
     a0a:	00 00       	nop
     a0c:	10 59       	subi	r17, 0x90	; 144
     a0e:	04 00       	.word	0x0004	; ????
     a10:	00 02       	muls	r16, r16
     a12:	23 00       	.word	0x0023	; ????
     a14:	01 04       	cpc	r0, r1
     a16:	64 07       	cpc	r22, r20
     a18:	00 00       	nop
     a1a:	0a 34       	cpi	r16, 0x4A	; 74
     a1c:	7f 01       	movw	r14, r30
     a1e:	00 00       	nop
     a20:	02 23       	and	r16, r18
     a22:	04 02       	muls	r16, r20
     a24:	04 d1       	rcall	.+520    	; 0xc2e <__data_load_end+0x32c>
     a26:	07 00       	.word	0x0007	; ????
     a28:	00 0a       	sbc	r0, r16
     a2a:	35 7f       	andi	r19, 0xF5	; 245
     a2c:	01 00       	.word	0x0001	; ????
     a2e:	00 02       	muls	r16, r16
     a30:	23 08       	sbc	r2, r3
     a32:	02 1c       	adc	r0, r2
     a34:	01 45       	sbci	r16, 0x51	; 81
     a36:	06 00       	.word	0x0006	; ????
     a38:	00 0a       	sbc	r0, r16
     a3a:	3f 4c       	sbci	r19, 0xCF	; 207
     a3c:	02 00       	.word	0x0002	; ????
     a3e:	00 01       	movw	r0, r0
     a40:	01 51       	subi	r16, 0x11	; 17
     a42:	04 00       	.word	0x0004	; ????
     a44:	00 06       	cpc	r0, r16
     a46:	27 12       	cpse	r2, r23
     a48:	00 00       	nop
     a4a:	01 00       	.word	0x0001	; ????
     a4c:	00 1d       	adc	r16, r0
     a4e:	1e 02       	muls	r17, r30
     a50:	00 00       	nop
     a52:	01 7d       	andi	r16, 0xD1	; 209
     a54:	04 00       	.word	0x0004	; ????
     a56:	00 1c       	adc	r0, r0
     a58:	01 45       	sbci	r16, 0x51	; 81
     a5a:	06 00       	.word	0x0006	; ????
     a5c:	00 06       	cpc	r0, r16
     a5e:	2e 0a       	sbc	r2, r30
     a60:	06 00       	.word	0x0006	; ????
     a62:	00 01       	movw	r0, r0
     a64:	01 75       	andi	r16, 0x51	; 81
     a66:	04 00       	.word	0x0004	; ????
     a68:	00 06       	cpc	r0, r16
     a6a:	33 12       	cpse	r3, r19
     a6c:	00 00       	nop
     a6e:	01 00       	.word	0x0001	; ????
     a70:	00 13       	cpse	r16, r16
     a72:	86 02       	muls	r24, r22
     a74:	00 00       	nop
     a76:	10 d8       	rcall	.-4064   	; 0xfffffa98 <__eeprom_end+0xff7efa98>
     a78:	01 04       	cpc	r0, r1
     a7a:	00 00       	nop
     a7c:	13 72       	andi	r17, 0x23	; 35
     a7e:	07 00       	.word	0x0007	; ????
     a80:	00 11       	cpse	r16, r0
     a82:	7e 86       	std	Y+14, r7	; 0x0e
     a84:	01 00       	.word	0x0001	; ????
     a86:	00 13       	cpse	r16, r16
     a88:	78 05       	cpc	r23, r8
     a8a:	00 00       	nop
     a8c:	0d 80       	ldd	r0, Y+5	; 0x05
     a8e:	01 04       	cpc	r0, r1
     a90:	00 00       	nop
     a92:	19 93       	st	Y+, r17
     a94:	04 00       	.word	0x0004	; ????
     a96:	00 1d       	adc	r16, r0
     a98:	fb 05       	cpc	r31, r11
     a9a:	00 00       	nop
     a9c:	01 14       	cp	r0, r1
     a9e:	05 00       	.word	0x0005	; ????
     aa0:	00 16       	cp	r0, r16
     aa2:	47 04       	cpc	r4, r7
     aa4:	00 00       	nop
     aa6:	01 01       	movw	r0, r2
     aa8:	01 bd       	out	0x21, r16	; 33
     aaa:	04 00       	.word	0x0004	; ????
     aac:	00 c4       	rjmp	.+2048   	; 0x12ae <__data_load_end+0x9ac>
     aae:	04 00       	.word	0x0004	; ????
     ab0:	00 06       	cpc	r0, r16
     ab2:	14 05       	cpc	r17, r4
     ab4:	00 00       	nop
     ab6:	01 00       	.word	0x0001	; ????
     ab8:	15 94       	asr	r1
     aba:	03 00       	.word	0x0003	; ????
     abc:	00 0b       	sbc	r16, r16
     abe:	65 01       	movw	r12, r10
     ac0:	01 d5       	rcall	.+2562   	; 0x14c4 <__data_load_end+0xbc2>
     ac2:	04 00       	.word	0x0004	; ????
     ac4:	00 dc       	rcall	.-2048   	; 0x2c6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x2c>
     ac6:	04 00       	.word	0x0004	; ????
     ac8:	00 06       	cpc	r0, r16
     aca:	14 05       	cpc	r17, r4
     acc:	00 00       	nop
     ace:	01 00       	.word	0x0001	; ????
     ad0:	1c 01       	movw	r2, r24
     ad2:	45 06       	cpc	r4, r21
     ad4:	00 00       	nop
     ad6:	0b 57       	subi	r16, 0x7B	; 123
     ad8:	e2 02       	muls	r30, r18
     ada:	00 00       	nop
     adc:	01 01       	movw	r0, r2
     ade:	ee 04       	cpc	r14, r14
     ae0:	00 00       	nop
     ae2:	06 14       	cp	r0, r6
     ae4:	05 00       	.word	0x0005	; ????
     ae6:	00 01       	movw	r0, r0
     ae8:	08 df       	rcall	.-496    	; 0x8fa <__data_load_start+0x32>
     aea:	03 00       	.word	0x0003	; ????
     aec:	00 08       	sbc	r0, r0
     aee:	df 03       	fmulsu	r21, r23
     af0:	00 00       	nop
     af2:	08 df       	rcall	.-496    	; 0x904 <__data_load_end+0x2>
     af4:	03 00       	.word	0x0003	; ????
     af6:	00 08       	sbc	r0, r0
     af8:	df 03       	fmulsu	r21, r23
     afa:	00 00       	nop
     afc:	08 df       	rcall	.-496    	; 0x90e <__data_load_end+0xc>
     afe:	03 00       	.word	0x0003	; ????
     b00:	00 08       	sbc	r0, r0
     b02:	df 03       	fmulsu	r21, r23
     b04:	00 00       	nop
     b06:	00 00       	nop
     b08:	0e 02       	muls	r16, r30
     b0a:	a3 04       	cpc	r10, r3
     b0c:	00 00       	nop
     b0e:	19 14       	cp	r1, r9
     b10:	05 00       	.word	0x0005	; ????
     b12:	00 1e       	adc	r0, r16
     b14:	ad 04       	cpc	r10, r13
     b16:	00 00       	nop
     b18:	0b 65       	ori	r16, 0x5B	; 91
     b1a:	03 2f       	mov	r16, r19
     b1c:	05 00       	.word	0x0005	; ????
     b1e:	00 4e       	sbci	r16, 0xE0	; 224
     b20:	05 00       	.word	0x0005	; ????
     b22:	00 1f       	adc	r16, r16
     b24:	d0 05       	cpc	r29, r0
     b26:	00 00       	nop
     b28:	1a 05       	cpc	r17, r10
     b2a:	00 00       	nop
     b2c:	01 20       	and	r0, r1
     b2e:	21 63       	ori	r18, 0x31	; 49
     b30:	00 0b       	sbc	r16, r16
     b32:	6a 96       	adiw	r28, 0x1a	; 26
     b34:	01 00       	.word	0x0001	; ????
     b36:	00 21       	and	r16, r0
     b38:	69 00       	.word	0x0069	; ????
     b3a:	0b 6b       	ori	r16, 0xBB	; 187
     b3c:	ad 01       	movw	r20, r26
     b3e:	00 00       	nop
     b40:	00 00       	nop
     b42:	22 c4       	rjmp	.+2116   	; 0x1388 <__data_load_end+0xa86>
     b44:	04 00       	.word	0x0004	; ????
     b46:	00 03       	mulsu	r16, r16
     b48:	5c 05       	cpc	r21, r12
     b4a:	00 00       	nop
     b4c:	67 05       	cpc	r22, r7
     b4e:	00 00       	nop
     b50:	1f d0       	rcall	.+62     	; 0xb90 <__data_load_end+0x28e>
     b52:	05 00       	.word	0x0005	; ????
     b54:	00 1a       	sub	r0, r16
     b56:	05 00       	.word	0x0005	; ????
     b58:	00 01       	movw	r0, r0
     b5a:	00 23       	and	r16, r16
     b5c:	9b 05       	cpc	r25, r11
     b5e:	00 00       	nop
     b60:	01 01       	movw	r0, r2
     b62:	01 8a       	std	Z+17, r0	; 0x11
     b64:	05 00       	.word	0x0005	; ????
     b66:	00 24       	eor	r0, r0
     b68:	18 04       	cpc	r1, r8
     b6a:	00 00       	nop
     b6c:	04 4d       	sbci	r16, 0xD4	; 212
     b6e:	2a 01       	movw	r4, r20
     b70:	00 00       	nop
     b72:	24 c5       	rjmp	.+2632   	; 0x15bc <__data_load_end+0xcba>
     b74:	05 00       	.word	0x0005	; ????
     b76:	00 04       	cpc	r0, r0
     b78:	4d 2a       	or	r4, r29
     b7a:	01 00       	.word	0x0001	; ????
     b7c:	00 00       	nop
     b7e:	25 8c       	ldd	r2, Z+29	; 0x1d
     b80:	03 00       	.word	0x0003	; ????
     b82:	00 01       	movw	r0, r0
     b84:	1d 01       	movw	r2, r26
     b86:	01 79       	andi	r16, 0x91	; 145
     b88:	06 00       	.word	0x0006	; ????
     b8a:	00 26       	eor	r0, r16
     b8c:	70 69       	ori	r23, 0x90	; 144
     b8e:	6e 00       	.word	0x006e	; ????
     b90:	01 1d       	adc	r16, r1
     b92:	86 01       	movw	r16, r12
     b94:	00 00       	nop
     b96:	24 17       	cp	r18, r20
     b98:	03 00       	.word	0x0003	; ????
     b9a:	00 01       	movw	r0, r0
     b9c:	1d 86       	std	Y+13, r1	; 0x0d
     b9e:	01 00       	.word	0x0001	; ????
     ba0:	00 21       	and	r16, r0
     ba2:	62 69       	ori	r22, 0x92	; 146
     ba4:	74 00       	.word	0x0074	; ????
     ba6:	01 1f       	adc	r16, r17
     ba8:	86 01       	movw	r16, r12
     baa:	00 00       	nop
     bac:	27 35       	cpi	r18, 0x57	; 87
     bae:	06 00       	.word	0x0006	; ????
     bb0:	00 01       	movw	r0, r0
     bb2:	20 86       	std	Z+8, r2	; 0x08
     bb4:	01 00       	.word	0x0001	; ????
     bb6:	00 21       	and	r16, r0
     bb8:	72 65       	ori	r23, 0x52	; 82
     bba:	67 00       	.word	0x0067	; ????
     bbc:	01 21       	and	r16, r1
     bbe:	df 03       	fmulsu	r21, r23
     bc0:	00 00       	nop
     bc2:	21 6f       	ori	r18, 0xF1	; 241
     bc4:	75 74       	andi	r23, 0x45	; 69
     bc6:	00 01       	movw	r0, r0
     bc8:	21 df       	rcall	.-446    	; 0xa0c <__data_load_end+0x10a>
     bca:	03 00       	.word	0x0003	; ????
     bcc:	00 28       	or	r0, r0
     bce:	ea 05       	cpc	r30, r10
     bd0:	00 00       	nop
     bd2:	27 10       	cpse	r2, r7
     bd4:	04 00       	.word	0x0004	; ????
     bd6:	00 01       	movw	r0, r0
     bd8:	36 86       	std	Z+14, r3	; 0x0e
     bda:	01 00       	.word	0x0001	; ????
     bdc:	00 00       	nop
     bde:	28 fb       	.word	0xfb28	; ????
     be0:	05 00       	.word	0x0005	; ????
     be2:	00 27       	eor	r16, r16
     be4:	10 04       	cpc	r1, r0
     be6:	00 00       	nop
     be8:	01 30       	cpi	r16, 0x01	; 1
     bea:	86 01       	movw	r16, r12
     bec:	00 00       	nop
     bee:	00 28       	or	r0, r0
     bf0:	0c 06       	cpc	r0, r28
     bf2:	00 00       	nop
     bf4:	27 10       	cpse	r2, r7
     bf6:	04 00       	.word	0x0004	; ????
     bf8:	00 01       	movw	r0, r0
     bfa:	2a 86       	std	Y+10, r2	; 0x0a
     bfc:	01 00       	.word	0x0001	; ????
     bfe:	00 00       	nop
     c00:	28 28       	or	r2, r8
     c02:	06 00       	.word	0x0006	; ????
     c04:	00 27       	eor	r16, r16
     c06:	5e 03       	fmul	r21, r22
     c08:	00 00       	nop
     c0a:	01 27       	eor	r16, r17
     c0c:	93 04       	cpc	r9, r3
     c0e:	00 00       	nop
     c10:	27 40       	sbci	r18, 0x07	; 7
     c12:	05 00       	.word	0x0005	; ????
     c14:	00 01       	movw	r0, r0
     c16:	27 93       	lat	Z, r18
     c18:	04 00       	.word	0x0004	; ????
     c1a:	00 00       	nop
     c1c:	28 44       	sbci	r18, 0x48	; 72
     c1e:	06 00       	.word	0x0006	; ????
     c20:	00 27       	eor	r16, r16
     c22:	5e 03       	fmul	r21, r22
     c24:	00 00       	nop
     c26:	01 26       	eor	r0, r17
     c28:	93 04       	cpc	r9, r3
     c2a:	00 00       	nop
     c2c:	27 40       	sbci	r18, 0x07	; 7
     c2e:	05 00       	.word	0x0005	; ????
     c30:	00 01       	movw	r0, r0
     c32:	26 93       	lac	Z, r18
     c34:	04 00       	.word	0x0004	; ????
     c36:	00 00       	nop
     c38:	28 60       	ori	r18, 0x08	; 8
     c3a:	06 00       	.word	0x0006	; ????
     c3c:	00 27       	eor	r16, r16
     c3e:	5e 03       	fmul	r21, r22
     c40:	00 00       	nop
     c42:	01 20       	and	r0, r1
     c44:	93 04       	cpc	r9, r3
     c46:	00 00       	nop
     c48:	27 40       	sbci	r18, 0x07	; 7
     c4a:	05 00       	.word	0x0005	; ????
     c4c:	00 01       	movw	r0, r0
     c4e:	20 86       	std	Z+8, r2	; 0x08
     c50:	01 00       	.word	0x0001	; ????
     c52:	00 00       	nop
     c54:	20 27       	eor	r18, r16
     c56:	5e 03       	fmul	r21, r22
     c58:	00 00       	nop
     c5a:	01 1f       	adc	r16, r17
     c5c:	93 04       	cpc	r9, r3
     c5e:	00 00       	nop
     c60:	27 40       	sbci	r18, 0x07	; 7
     c62:	05 00       	.word	0x0005	; ????
     c64:	00 01       	movw	r0, r0
     c66:	1f 86       	std	Y+15, r1	; 0x0f
     c68:	01 00       	.word	0x0001	; ????
     c6a:	00 00       	nop
     c6c:	00 0e       	add	r0, r16
     c6e:	02 bd       	out	0x22, r16	; 34
     c70:	01 00       	.word	0x0001	; ????
     c72:	00 19       	sub	r16, r0
     c74:	79 06       	cpc	r7, r25
     c76:	00 00       	nop
     c78:	22 99       	sbic	0x04, 2	; 4
     c7a:	02 00       	.word	0x0002	; ????
     c7c:	00 01       	movw	r0, r0
     c7e:	92 06       	cpc	r9, r18
     c80:	00 00       	nop
     c82:	be 06       	cpc	r11, r30
     c84:	00 00       	nop
     c86:	1f d0       	rcall	.+62     	; 0xcc6 <__data_load_end+0x3c4>
     c88:	05 00       	.word	0x0005	; ????
     c8a:	00 7f       	andi	r16, 0xF0	; 240
     c8c:	06 00       	.word	0x0006	; ????
     c8e:	00 01       	movw	r0, r0
     c90:	24 0b       	sbc	r18, r20
     c92:	04 00       	.word	0x0004	; ????
     c94:	00 03       	mulsu	r16, r16
     c96:	75 7f       	andi	r23, 0xF5	; 245
     c98:	01 00       	.word	0x0001	; ????
     c9a:	00 24       	eor	r0, r0
     c9c:	35 03       	mulsu	r19, r21
     c9e:	00 00       	nop
     ca0:	03 75       	andi	r16, 0x53	; 83
     ca2:	88 04       	cpc	r8, r8
     ca4:	00 00       	nop
     ca6:	27 28       	or	r2, r7
     ca8:	05 00       	.word	0x0005	; ????
     caa:	00 03       	mulsu	r16, r16
     cac:	78 93       	.word	0x9378	; ????
     cae:	04 00       	.word	0x0004	; ????
     cb0:	00 00       	nop
     cb2:	1d fb       	.word	0xfb1d	; ????
     cb4:	05 00       	.word	0x0005	; ????
     cb6:	00 01       	movw	r0, r0
     cb8:	e2 06       	cpc	r14, r18
     cba:	00 00       	nop
     cbc:	29 ad       	ldd	r18, Y+57	; 0x39
     cbe:	02 00       	.word	0x0002	; ????
     cc0:	00 0e       	add	r0, r16
     cc2:	79 01       	movw	r14, r18
     cc4:	01 d5       	rcall	.+2562   	; 0x16c8 <__data_load_end+0xdc6>
     cc6:	06 00       	.word	0x0006	; ????
     cc8:	00 06       	cpc	r0, r16
     cca:	e2 06       	cpc	r14, r18
     ccc:	00 00       	nop
     cce:	01 08       	sbc	r0, r1
     cd0:	7f 01       	movw	r14, r30
     cd2:	00 00       	nop
     cd4:	00 00       	nop
     cd6:	0e 02       	muls	r16, r30
     cd8:	be 06       	cpc	r11, r30
     cda:	00 00       	nop
     cdc:	19 e2       	ldi	r17, 0x29	; 41
     cde:	06 00       	.word	0x0006	; ????
     ce0:	00 22       	and	r0, r16
     ce2:	c8 06       	cpc	r12, r24
     ce4:	00 00       	nop
     ce6:	03 fb       	bst	r16, 3
     ce8:	06 00       	.word	0x0006	; ????
     cea:	00 11       	cpse	r16, r0
     cec:	07 00       	.word	0x0007	; ????
     cee:	00 1f       	adc	r16, r16
     cf0:	d0 05       	cpc	r29, r0
     cf2:	00 00       	nop
     cf4:	e8 06       	cpc	r14, r24
     cf6:	00 00       	nop
     cf8:	01 24       	eor	r0, r1
     cfa:	0b 04       	cpc	r0, r11
     cfc:	00 00       	nop
     cfe:	0e 79       	andi	r16, 0x9E	; 158
     d00:	7f 01       	movw	r14, r30
     d02:	00 00       	nop
     d04:	00 25       	eor	r16, r0
     d06:	18 06       	cpc	r1, r24
     d08:	00 00       	nop
     d0a:	12 1c       	adc	r1, r2
     d0c:	01 01       	movw	r0, r2
     d0e:	2a 07       	cpc	r18, r26
     d10:	00 00       	nop
     d12:	24 23       	and	r18, r20
     d14:	08 00       	.word	0x0008	; ????
     d16:	00 12       	cpse	r0, r16
     d18:	1c 7f       	andi	r17, 0xFC	; 252
     d1a:	01 00       	.word	0x0001	; ????
     d1c:	00 00       	nop
     d1e:	25 23       	and	r18, r21
     d20:	06 00       	.word	0x0006	; ????
     d22:	00 01       	movw	r0, r0
     d24:	8a 01       	movw	r16, r20
     d26:	01 f1       	breq	.+64     	; 0xd68 <__data_load_end+0x466>
     d28:	07 00       	.word	0x0007	; ????
     d2a:	00 26       	eor	r0, r16
     d2c:	70 69       	ori	r23, 0x90	; 144
     d2e:	6e 00       	.word	0x006e	; ????
     d30:	01 8a       	std	Z+17, r0	; 0x11
     d32:	86 01       	movw	r16, r12
     d34:	00 00       	nop
     d36:	26 76       	andi	r18, 0x66	; 102
     d38:	61 6c       	ori	r22, 0xC1	; 193
     d3a:	00 01       	movw	r0, r0
     d3c:	8a 86       	std	Y+10, r8	; 0x0a
     d3e:	01 00       	.word	0x0001	; ????
     d40:	00 27       	eor	r16, r16
     d42:	53 03       	mulsu	r21, r19
     d44:	00 00       	nop
     d46:	01 8c       	ldd	r0, Z+25	; 0x19
     d48:	86 01       	movw	r16, r12
     d4a:	00 00       	nop
     d4c:	21 62       	ori	r18, 0x21	; 33
     d4e:	69 74       	andi	r22, 0x49	; 73
     d50:	00 01       	movw	r0, r0
     d52:	8d 86       	std	Y+13, r8	; 0x0d
     d54:	01 00       	.word	0x0001	; ????
     d56:	00 27       	eor	r16, r16
     d58:	35 06       	cpc	r3, r21
     d5a:	00 00       	nop
     d5c:	01 8e       	std	Z+25, r0	; 0x19
     d5e:	86 01       	movw	r16, r12
     d60:	00 00       	nop
     d62:	21 6f       	ori	r18, 0xF1	; 241
     d64:	75 74       	andi	r23, 0x45	; 69
     d66:	00 01       	movw	r0, r0
     d68:	8f df       	rcall	.-226    	; 0xc88 <__data_load_end+0x386>
     d6a:	03 00       	.word	0x0003	; ????
     d6c:	00 27       	eor	r16, r16
     d6e:	10 04       	cpc	r1, r0
     d70:	00 00       	nop
     d72:	01 99       	sbic	0x00, 1	; 0
     d74:	86 01       	movw	r16, r12
     d76:	00 00       	nop
     d78:	28 a0       	ldd	r2, Y+32	; 0x20
     d7a:	07 00       	.word	0x0007	; ????
     d7c:	00 27       	eor	r16, r16
     d7e:	5e 03       	fmul	r21, r22
     d80:	00 00       	nop
     d82:	01 97       	sbiw	r24, 0x01	; 1
     d84:	93 04       	cpc	r9, r3
     d86:	00 00       	nop
     d88:	27 40       	sbci	r18, 0x07	; 7
     d8a:	05 00       	.word	0x0005	; ????
     d8c:	00 01       	movw	r0, r0
     d8e:	97 93       	lat	Z, r25
     d90:	04 00       	.word	0x0004	; ????
     d92:	00 00       	nop
     d94:	28 bc       	out	0x28, r2	; 40
     d96:	07 00       	.word	0x0007	; ????
     d98:	00 27       	eor	r16, r16
     d9a:	5e 03       	fmul	r21, r22
     d9c:	00 00       	nop
     d9e:	01 8e       	std	Z+25, r0	; 0x19
     da0:	93 04       	cpc	r9, r3
     da2:	00 00       	nop
     da4:	27 40       	sbci	r18, 0x07	; 7
     da6:	05 00       	.word	0x0005	; ????
     da8:	00 01       	movw	r0, r0
     daa:	8e 86       	std	Y+14, r8	; 0x0e
     dac:	01 00       	.word	0x0001	; ????
     dae:	00 00       	nop
     db0:	28 d8       	rcall	.-4016   	; 0xfffffe02 <__eeprom_end+0xff7efe02>
     db2:	07 00       	.word	0x0007	; ????
     db4:	00 27       	eor	r16, r16
     db6:	5e 03       	fmul	r21, r22
     db8:	00 00       	nop
     dba:	01 8d       	ldd	r16, Z+25	; 0x19
     dbc:	93 04       	cpc	r9, r3
     dbe:	00 00       	nop
     dc0:	27 40       	sbci	r18, 0x07	; 7
     dc2:	05 00       	.word	0x0005	; ????
     dc4:	00 01       	movw	r0, r0
     dc6:	8d 86       	std	Y+13, r8	; 0x0d
     dc8:	01 00       	.word	0x0001	; ????
     dca:	00 00       	nop
     dcc:	20 27       	eor	r18, r16
     dce:	5e 03       	fmul	r21, r22
     dd0:	00 00       	nop
     dd2:	01 8c       	ldd	r0, Z+25	; 0x19
     dd4:	93 04       	cpc	r9, r3
     dd6:	00 00       	nop
     dd8:	27 40       	sbci	r18, 0x07	; 7
     dda:	05 00       	.word	0x0005	; ????
     ddc:	00 01       	movw	r0, r0
     dde:	8c 86       	std	Y+12, r8	; 0x0c
     de0:	01 00       	.word	0x0001	; ????
     de2:	00 00       	nop
     de4:	00 0e       	add	r0, r16
     de6:	02 29       	or	r16, r2
     de8:	00 00       	nop
     dea:	00 19       	sub	r16, r0
     dec:	f1 07       	cpc	r31, r17
     dee:	00 00       	nop
     df0:	22 55       	subi	r18, 0x52	; 82
     df2:	00 00       	nop
     df4:	00 01       	movw	r0, r0
     df6:	0a 08       	sbc	r0, r10
     df8:	00 00       	nop
     dfa:	15 08       	sbc	r1, r5
     dfc:	00 00       	nop
     dfe:	1f d0       	rcall	.+62     	; 0xe3e <__data_load_end+0x53c>
     e00:	05 00       	.word	0x0005	; ????
     e02:	00 f7       	brcc	.-64     	; 0xdc4 <__data_load_end+0x4c2>
     e04:	07 00       	.word	0x0007	; ????
     e06:	00 01       	movw	r0, r0
     e08:	00 0e       	add	r0, r16
     e0a:	02 22       	and	r0, r18
     e0c:	08 00       	.word	0x0008	; ????
     e0e:	00 12       	cpse	r0, r16
     e10:	01 06       	cpc	r0, r17
     e12:	42 04       	cpc	r4, r2
     e14:	00 00       	nop
     e16:	19 1b       	sub	r17, r25
     e18:	08 00       	.word	0x0008	; ????
     e1a:	00 1e       	adc	r0, r16
     e1c:	71 00       	.word	0x0071	; ????
     e1e:	00 00       	nop
     e20:	06 34       	cpi	r16, 0x46	; 70
     e22:	03 37       	cpi	r16, 0x73	; 115
     e24:	08 00       	.word	0x0008	; ????
     e26:	00 4d       	sbci	r16, 0xD0	; 208
     e28:	08 00       	.word	0x0008	; ????
     e2a:	00 1f       	adc	r16, r16
     e2c:	d0 05       	cpc	r29, r0
     e2e:	00 00       	nop
     e30:	f7 07       	cpc	r31, r23
     e32:	00 00       	nop
     e34:	01 26       	eor	r0, r17
     e36:	73 74       	andi	r23, 0x43	; 67
     e38:	72 00       	.word	0x0072	; ????
     e3a:	06 34       	cpi	r16, 0x46	; 70
     e3c:	15 08       	sbc	r1, r5
     e3e:	00 00       	nop
     e40:	00 22       	and	r0, r16
     e42:	91 00       	.word	0x0091	; ????
     e44:	00 00       	nop
     e46:	03 5b       	subi	r16, 0xB3	; 179
     e48:	08 00       	.word	0x0008	; ????
     e4a:	00 71       	andi	r16, 0x10	; 16
     e4c:	08 00       	.word	0x0008	; ????
     e4e:	00 1f       	adc	r16, r16
     e50:	d0 05       	cpc	r29, r0
     e52:	00 00       	nop
     e54:	f7 07       	cpc	r31, r23
     e56:	00 00       	nop
     e58:	01 26       	eor	r0, r17
     e5a:	73 74       	andi	r23, 0x43	; 67
     e5c:	72 00       	.word	0x0072	; ????
     e5e:	06 34       	cpi	r16, 0x46	; 70
     e60:	15 08       	sbc	r1, r5
     e62:	00 00       	nop
     e64:	00 22       	and	r0, r16
     e66:	b2 00       	.word	0x00b2	; ????
     e68:	00 00       	nop
     e6a:	01 7f       	andi	r16, 0xF1	; 241
     e6c:	08 00       	.word	0x0008	; ????
     e6e:	00 9c       	mul	r0, r0
     e70:	08 00       	.word	0x0008	; ????
     e72:	00 1f       	adc	r16, r16
     e74:	d0 05       	cpc	r29, r0
     e76:	00 00       	nop
     e78:	f7 07       	cpc	r31, r23
     e7a:	00 00       	nop
     e7c:	01 26       	eor	r0, r17
     e7e:	63 00       	.word	0x0063	; ????
     e80:	02 8a       	std	Z+18, r0	; 0x12
     e82:	15 08       	sbc	r1, r5
     e84:	00 00       	nop
     e86:	21 6e       	ori	r18, 0xE1	; 225
     e88:	00 02       	muls	r16, r16
     e8a:	8c 7d       	andi	r24, 0xDC	; 220
     e8c:	04 00       	.word	0x0004	; ????
     e8e:	00 00       	nop
     e90:	25 f0       	brhs	.+8      	; 0xe9a <__data_load_end+0x598>
     e92:	05 00       	.word	0x0005	; ????
     e94:	00 01       	movw	r0, r0
     e96:	4b 01       	movw	r8, r22
     e98:	01 b5       	in	r16, 0x21	; 33
     e9a:	08 00       	.word	0x0008	; ????
     e9c:	00 24       	eor	r0, r0
     e9e:	53 03       	mulsu	r21, r19
     ea0:	00 00       	nop
     ea2:	01 4b       	sbci	r16, 0xB1	; 177
     ea4:	86 01       	movw	r16, r12
     ea6:	00 00       	nop
     ea8:	00 23       	and	r16, r16
     eaa:	49 05       	cpc	r20, r9
     eac:	00 00       	nop
     eae:	01 01       	movw	r0, r2
     eb0:	01 cd       	rjmp	.-1534   	; 0x8b4 <_GLOBAL__sub_I___vector_18+0x56>
     eb2:	08 00       	.word	0x0008	; ????
     eb4:	00 27       	eor	r16, r16
     eb6:	53 03       	mulsu	r21, r19
     eb8:	00 00       	nop
     eba:	01 4b       	sbci	r16, 0xB1	; 177
     ebc:	86 01       	movw	r16, r12
     ebe:	00 00       	nop
     ec0:	00 2a       	or	r0, r16
     ec2:	2a 07       	cpc	r18, r26
     ec4:	00 00       	nop
     ec6:	0e 01       	movw	r0, r28
     ec8:	00 00       	nop
     eca:	9e 01       	movw	r18, r28
     ecc:	00 00       	nop
     ece:	03 92       	.word	0x9203	; ????
     ed0:	20 02       	muls	r18, r16
     ed2:	01 d6       	rcall	.+3074   	; 0x1ad6 <__data_load_end+0x11d4>
     ed4:	09 00       	.word	0x0009	; ????
     ed6:	00 2b       	or	r16, r16
     ed8:	42 07       	cpc	r20, r18
     eda:	00 00       	nop
     edc:	01 68       	ori	r16, 0x81	; 129
     ede:	2c 4d       	sbci	r18, 0xDC	; 220
     ee0:	07 00       	.word	0x0007	; ????
     ee2:	00 00       	nop
     ee4:	00 00       	nop
     ee6:	00 2c       	mov	r0, r0
     ee8:	58 07       	cpc	r21, r24
     eea:	00 00       	nop
     eec:	55 00       	.word	0x0055	; ????
     eee:	00 00       	nop
     ef0:	2c 63       	ori	r18, 0x3C	; 60
     ef2:	07 00       	.word	0x0007	; ????
     ef4:	00 81       	ld	r16, Z
     ef6:	00 00       	nop
     ef8:	00 2c       	mov	r0, r0
     efa:	6e 07       	cpc	r22, r30
     efc:	00 00       	nop
     efe:	9f 00       	.word	0x009f	; ????
     f00:	00 00       	nop
     f02:	2c 79       	andi	r18, 0x9C	; 156
     f04:	07 00       	.word	0x0007	; ????
     f06:	00 c7       	rjmp	.+3584   	; 0x1d08 <__data_load_end+0x1406>
     f08:	00 00       	nop
     f0a:	00 2d       	mov	r16, r0
     f0c:	37 07       	cpc	r19, r23
     f0e:	00 00       	nop
     f10:	0d 2e       	mov	r0, r29
     f12:	d8 07       	cpc	r29, r24
     f14:	00 00       	nop
     f16:	0e 01       	movw	r0, r28
     f18:	00 00       	nop
     f1a:	14 01       	movw	r2, r8
     f1c:	00 00       	nop
     f1e:	41 09       	sbc	r20, r1
     f20:	00 00       	nop
     f22:	2c d9       	rcall	.-3496   	; 0x17c <digitalWrite.constprop.4+0x6e>
     f24:	07 00       	.word	0x0007	; ????
     f26:	00 e5       	ldi	r16, 0x50	; 80
     f28:	00 00       	nop
     f2a:	00 2c       	mov	r0, r0
     f2c:	e4 07       	cpc	r30, r20
     f2e:	00 00       	nop
     f30:	00 00       	nop
     f32:	00 00       	nop
     f34:	00 2e       	mov	r0, r16
     f36:	bc 07       	cpc	r27, r28
     f38:	00 00       	nop
     f3a:	14 01       	movw	r2, r8
     f3c:	00 00       	nop
     f3e:	1a 01       	movw	r2, r20
     f40:	00 00       	nop
     f42:	65 09       	sbc	r22, r5
     f44:	00 00       	nop
     f46:	2c c1       	rjmp	.+600    	; 0x11a0 <__data_load_end+0x89e>
     f48:	07 00       	.word	0x0007	; ????
     f4a:	00 fd       	sbrc	r16, 0
     f4c:	00 00       	nop
     f4e:	00 2c       	mov	r0, r0
     f50:	cc 07       	cpc	r28, r28
     f52:	00 00       	nop
     f54:	55 00       	.word	0x0055	; ????
     f56:	00 00       	nop
     f58:	00 2e       	mov	r0, r16
     f5a:	a0 07       	cpc	r26, r16
     f5c:	00 00       	nop
     f5e:	1a 01       	movw	r2, r20
     f60:	00 00       	nop
     f62:	20 01       	movw	r4, r0
     f64:	00 00       	nop
     f66:	89 09       	sbc	r24, r9
     f68:	00 00       	nop
     f6a:	2c a5       	ldd	r18, Y+44	; 0x2c
     f6c:	07 00       	.word	0x0007	; ????
     f6e:	00 15       	cp	r16, r0
     f70:	01 00       	.word	0x0001	; ????
     f72:	00 2c       	mov	r0, r0
     f74:	b0 07       	cpc	r27, r16
     f76:	00 00       	nop
     f78:	81 00       	.word	0x0081	; ????
     f7a:	00 00       	nop
     f7c:	00 2f       	mov	r16, r16
     f7e:	9c 08       	sbc	r9, r12
     f80:	00 00       	nop
     f82:	28 01       	movw	r4, r16
     f84:	00 00       	nop
     f86:	00 00       	nop
     f88:	00 00       	nop
     f8a:	01 95       	neg	r16
     f8c:	b5 09       	sbc	r27, r5
     f8e:	00 00       	nop
     f90:	30 a9       	ldd	r19, Z+48	; 0x30
     f92:	08 00       	.word	0x0008	; ????
     f94:	00 2d       	mov	r16, r0
     f96:	01 00       	.word	0x0001	; ????
     f98:	00 31       	cpi	r16, 0x10	; 16
     f9a:	78 01       	movw	r14, r16
     f9c:	00 00       	nop
     f9e:	7c 01       	movw	r14, r24
     fa0:	00 00       	nop
     fa2:	32 c1       	rjmp	.+612    	; 0x1208 <__data_load_end+0x906>
     fa4:	08 00       	.word	0x0008	; ????
     fa6:	00 00       	nop
     fa8:	00 33       	cpi	r16, 0x30	; 48
     faa:	84 07       	cpc	r24, r20
     fac:	00 00       	nop
     fae:	36 01       	movw	r6, r12
     fb0:	00 00       	nop
     fb2:	44 01       	movw	r8, r8
     fb4:	00 00       	nop
     fb6:	2c 89       	ldd	r18, Y+20	; 0x14
     fb8:	07 00       	.word	0x0007	; ????
     fba:	00 82       	st	Z, r0
     fbc:	01 00       	.word	0x0001	; ????
     fbe:	00 2c       	mov	r0, r0
     fc0:	94 07       	cpc	r25, r20
     fc2:	00 00       	nop
     fc4:	9f 00       	.word	0x009f	; ????
     fc6:	00 00       	nop
     fc8:	00 00       	nop
     fca:	0e 02       	muls	r16, r30
     fcc:	e3 09       	sbc	r30, r3
     fce:	00 00       	nop
     fd0:	12 01       	movw	r2, r4
     fd2:	08 3c       	cpi	r16, 0xC8	; 200
     fd4:	03 00       	.word	0x0003	; ????
     fd6:	00 19       	sub	r16, r0
     fd8:	dc 09       	sbc	r29, r12
     fda:	00 00       	nop
     fdc:	34 d3       	rcall	.+1640   	; 0x1646 <__data_load_end+0xd44>
     fde:	00 00       	nop
     fe0:	00 9e       	mul	r0, r16
     fe2:	01 00       	.word	0x0001	; ????
     fe4:	00 f8       	bld	r0, 0
     fe6:	01 00       	.word	0x0001	; ????
     fe8:	00 9a       	sbi	0x00, 0	; 0
     fea:	01 00       	.word	0x0001	; ????
     fec:	00 02       	muls	r16, r16
     fee:	0a 00       	.word	0x000a	; ????
     ff0:	00 01       	movw	r0, r0
     ff2:	4d 0a       	sbc	r4, r29
     ff4:	00 00       	nop
     ff6:	35 d0       	rcall	.+106    	; 0x1062 <__data_load_end+0x760>
     ff8:	05 00       	.word	0x0005	; ????
     ffa:	00 f7       	brcc	.-64     	; 0xfbc <__data_load_end+0x6ba>
     ffc:	07 00       	.word	0x0007	; ????
     ffe:	00 01       	movw	r0, r0
    1000:	31 02       	muls	r19, r17
    1002:	00 00       	nop
    1004:	36 e7       	ldi	r19, 0x76	; 118
    1006:	07 00       	.word	0x0007	; ????
    1008:	00 02       	muls	r16, r16
    100a:	22 d6       	rcall	.+3140   	; 0x1c50 <__data_load_end+0x134e>
    100c:	09 00       	.word	0x0009	; ????
    100e:	00 67       	ori	r16, 0x70	; 112
    1010:	02 00       	.word	0x0002	; ????
    1012:	00 36       	cpi	r16, 0x60	; 96
    1014:	6d 07       	cpc	r22, r29
    1016:	00 00       	nop
    1018:	02 22       	and	r0, r18
    101a:	7d 04       	cpc	r7, r13
    101c:	00 00       	nop
    101e:	ac 02       	muls	r26, r28
    1020:	00 00       	nop
    1022:	37 6e       	ori	r19, 0xE7	; 231
    1024:	00 02       	muls	r16, r16
    1026:	24 7d       	andi	r18, 0xD4	; 212
    1028:	04 00       	.word	0x0004	; ????
    102a:	00 ed       	ldi	r16, 0xD0	; 208
    102c:	02 00       	.word	0x0002	; ????
    102e:	00 38       	cpi	r16, 0x80	; 128
    1030:	dc 01       	movw	r26, r24
    1032:	00 00       	nop
    1034:	39 06       	cpc	r3, r25
    1036:	68 93       	.word	0x9368	; ????
    1038:	01 69       	ori	r16, 0x91	; 145
    103a:	93 01       	movw	r18, r6
    103c:	02 7c       	andi	r16, 0xC2	; 194
    103e:	00 00       	nop
    1040:	00 3a       	cpi	r16, 0xA0	; 160
    1042:	bb 02       	muls	r27, r27
    1044:	00 00       	nop
    1046:	f8 01       	movw	r30, r16
    1048:	00 00       	nop
    104a:	16 02       	muls	r17, r22
    104c:	00 00       	nop
    104e:	03 92       	.word	0x9203	; ????
    1050:	20 02       	muls	r18, r16
    1052:	67 0a       	sbc	r6, r23
    1054:	00 00       	nop
    1056:	01 90       	ld	r0, Z+
    1058:	0a 00       	.word	0x000a	; ????
    105a:	00 35       	cpi	r16, 0x50	; 80
    105c:	d0 05       	cpc	r29, r0
    105e:	00 00       	nop
    1060:	7f 06       	cpc	r7, r31
    1062:	00 00       	nop
    1064:	01 21       	and	r16, r1
    1066:	03 00       	.word	0x0003	; ????
    1068:	00 3b       	cpi	r16, 0xB0	; 176
    106a:	72 03       	mulsu	r23, r18
    106c:	00 00       	nop
    106e:	03 c2       	rjmp	.+1030   	; 0x1476 <__data_load_end+0xb74>
    1070:	9d 01       	movw	r18, r26
    1072:	00 00       	nop
    1074:	01 65       	ori	r16, 0x51	; 81
    1076:	3b 2f       	mov	r19, r27
    1078:	02 00       	.word	0x0002	; ????
    107a:	00 03       	mulsu	r16, r16
    107c:	c3 9d       	mul	r28, r3
    107e:	01 00       	.word	0x0001	; ????
    1080:	00 01       	movw	r0, r0
    1082:	64 00       	.word	0x0064	; ????
    1084:	3a df       	rcall	.-396    	; 0xefa <__data_load_end+0x5f8>
    1086:	02 00       	.word	0x0002	; ????
    1088:	00 16       	cp	r0, r16
    108a:	02 00       	.word	0x0002	; ????
    108c:	00 3e       	cpi	r16, 0xE0	; 224
    108e:	02 00       	.word	0x0002	; ????
    1090:	00 03       	mulsu	r16, r16
    1092:	92 20       	and	r9, r2
    1094:	02 aa       	std	Z+50, r0	; 0x32
    1096:	0a 00       	.word	0x000a	; ????
    1098:	00 01       	movw	r0, r0
    109a:	d0 0a       	sbc	r13, r16
    109c:	00 00       	nop
    109e:	35 d0       	rcall	.+106    	; 0x110a <__data_load_end+0x808>
    10a0:	05 00       	.word	0x0005	; ????
    10a2:	00 7f       	andi	r16, 0xF0	; 240
    10a4:	06 00       	.word	0x0006	; ????
    10a6:	00 01       	movw	r0, r0
    10a8:	49 03       	fmul	r20, r17
    10aa:	00 00       	nop
    10ac:	31 20       	and	r3, r1
    10ae:	02 00       	.word	0x0002	; ????
    10b0:	00 38       	cpi	r16, 0x80	; 128
    10b2:	02 00       	.word	0x0002	; ????
    10b4:	00 37       	cpi	r16, 0x70	; 112
    10b6:	63 00       	.word	0x0063	; ????
    10b8:	03 ba       	out	0x13, r0	; 19
    10ba:	96 01       	movw	r18, r12
    10bc:	00 00       	nop
    10be:	71 03       	mulsu	r23, r17
    10c0:	00 00       	nop
    10c2:	00 00       	nop
    10c4:	3a 03       	fmul	r19, r18
    10c6:	03 00       	.word	0x0003	; ????
    10c8:	00 3e       	cpi	r16, 0xE0	; 224
    10ca:	02 00       	.word	0x0002	; ????
    10cc:	00 5a       	subi	r16, 0xA0	; 160
    10ce:	02 00       	.word	0x0002	; ????
    10d0:	00 03       	mulsu	r16, r16
    10d2:	92 20       	and	r9, r2
    10d4:	02 ea       	ldi	r16, 0xA2	; 162
    10d6:	0a 00       	.word	0x000a	; ????
    10d8:	00 01       	movw	r0, r0
    10da:	f9 0a       	sbc	r15, r25
    10dc:	00 00       	nop
    10de:	35 d0       	rcall	.+106    	; 0x114a <__data_load_end+0x848>
    10e0:	05 00       	.word	0x0005	; ????
    10e2:	00 7f       	andi	r16, 0xF0	; 240
    10e4:	06 00       	.word	0x0006	; ????
    10e6:	00 01       	movw	r0, r0
    10e8:	84 03       	fmuls	r16, r20
    10ea:	00 00       	nop
    10ec:	00 3a       	cpi	r16, 0xA0	; 160
    10ee:	27 03       	mulsu	r18, r23
    10f0:	00 00       	nop
    10f2:	5a 02       	muls	r21, r26
    10f4:	00 00       	nop
    10f6:	72 02       	muls	r23, r18
    10f8:	00 00       	nop
    10fa:	03 92       	.word	0x9203	; ????
    10fc:	20 02       	muls	r18, r16
    10fe:	13 0b       	sbc	r17, r19
    1100:	00 00       	nop
    1102:	01 22       	and	r0, r17
    1104:	0b 00       	.word	0x000b	; ????
    1106:	00 35       	cpi	r16, 0x50	; 80
    1108:	d0 05       	cpc	r29, r0
    110a:	00 00       	nop
    110c:	7f 06       	cpc	r7, r31
    110e:	00 00       	nop
    1110:	01 ca       	rjmp	.-3070   	; 0x514 <__vector_18+0x42>
    1112:	03 00       	.word	0x0003	; ????
    1114:	00 00       	nop
    1116:	3c 74       	andi	r19, 0x4C	; 76
    1118:	02 00       	.word	0x0002	; ????
    111a:	00 04       	cpc	r0, r0
    111c:	4b 01       	movw	r8, r22
    111e:	ea 03       	fmulsu	r22, r18
    1120:	00 00       	nop
    1122:	72 02       	muls	r23, r18
    1124:	00 00       	nop
    1126:	86 02       	muls	r24, r22
    1128:	00 00       	nop
    112a:	03 92       	.word	0x9203	; ????
    112c:	20 02       	muls	r18, r16
    112e:	01 58       	subi	r16, 0x81	; 129
    1130:	0b 00       	.word	0x000b	; ????
    1132:	00 3d       	cpi	r16, 0xD0	; 208
    1134:	7a 02       	muls	r23, r26
    1136:	00 00       	nop
    1138:	f9 0a       	sbc	r15, r25
    113a:	00 00       	nop
    113c:	39 06       	cpc	r3, r25
    113e:	68 93       	.word	0x9368	; ????
    1140:	01 69       	ori	r16, 0x91	; 145
    1142:	93 01       	movw	r18, r6
    1144:	05 03       	mulsu	r16, r21
    1146:	43 01       	movw	r8, r6
    1148:	80 00       	.word	0x0080	; ????
    114a:	00 00       	nop
    114c:	3e 44       	sbci	r19, 0x4E	; 78
    114e:	03 00       	.word	0x0003	; ????
    1150:	00 03       	mulsu	r16, r16
    1152:	40 01       	movw	r8, r0
    1154:	01 3f       	cpi	r16, 0xF1	; 241
    1156:	92 02       	muls	r25, r18
    1158:	00 00       	nop
    115a:	01 01       	movw	r0, r2
    115c:	01 2a       	or	r0, r17
    115e:	58 0b       	sbc	r21, r24
    1160:	00 00       	nop
    1162:	86 02       	muls	r24, r22
    1164:	00 00       	nop
    1166:	9a 02       	muls	r25, r26
    1168:	00 00       	nop
    116a:	03 92       	.word	0x9203	; ????
    116c:	20 02       	muls	r18, r16
    116e:	01 8f       	std	Z+25, r16	; 0x19
    1170:	0b 00       	.word	0x000b	; ????
    1172:	00 40       	sbci	r16, 0x00	; 0
    1174:	92 02       	muls	r25, r18
    1176:	00 00       	nop
    1178:	22 0b       	sbc	r18, r18
    117a:	00 00       	nop
    117c:	41 98       	cbi	0x08, 1	; 8
    117e:	02 00       	.word	0x0002	; ????
    1180:	00 01       	movw	r0, r0
    1182:	00 1e       	adc	r0, r16
    1184:	4b 03       	fmul	r20, r19
    1186:	00 00       	nop
    1188:	03 59       	subi	r16, 0x93	; 147
    118a:	01 9f       	mul	r16, r17
    118c:	0b 00       	.word	0x000b	; ????
    118e:	00 b3       	in	r16, 0x10	; 16
    1190:	0b 00       	.word	0x000b	; ????
    1192:	00 1f       	adc	r16, r16
    1194:	d0 05       	cpc	r29, r0
    1196:	00 00       	nop
    1198:	7f 06       	cpc	r7, r31
    119a:	00 00       	nop
    119c:	01 21       	and	r16, r1
    119e:	63 00       	.word	0x0063	; ????
    11a0:	03 5d       	subi	r16, 0xD3	; 211
    11a2:	96 01       	movw	r18, r12
    11a4:	00 00       	nop
    11a6:	00 22       	and	r0, r16
    11a8:	62 03       	mulsu	r22, r18
    11aa:	00 00       	nop
    11ac:	01 c1       	rjmp	.+514    	; 0x13b0 <__data_load_end+0xaae>
    11ae:	0b 00       	.word	0x000b	; ????
    11b0:	00 e3       	ldi	r16, 0x30	; 48
    11b2:	0b 00       	.word	0x000b	; ????
    11b4:	00 1f       	adc	r16, r16
    11b6:	d0 05       	cpc	r29, r0
    11b8:	00 00       	nop
    11ba:	7f 06       	cpc	r7, r31
    11bc:	00 00       	nop
    11be:	01 21       	and	r16, r1
    11c0:	63 00       	.word	0x0063	; ????
    11c2:	03 5d       	subi	r16, 0xD3	; 211
    11c4:	96 01       	movw	r18, r12
    11c6:	00 00       	nop
    11c8:	20 42       	sbci	r18, 0x20	; 32
    11ca:	9f 0b       	sbc	r25, r31
    11cc:	00 00       	nop
    11ce:	20 32       	cpi	r18, 0x20	; 32
    11d0:	a9 0b       	sbc	r26, r25
    11d2:	00 00       	nop
    11d4:	00 00       	nop
    11d6:	00 43       	sbci	r16, 0x30	; 48
    11d8:	b3 0b       	sbc	r27, r19
    11da:	00 00       	nop
    11dc:	9a 02       	muls	r25, r26
    11de:	00 00       	nop
    11e0:	de 02       	muls	r29, r30
    11e2:	00 00       	nop
    11e4:	03 92       	.word	0x9203	; ????
    11e6:	20 02       	muls	r18, r16
    11e8:	fd 0b       	sbc	r31, r29
    11ea:	00 00       	nop
    11ec:	01 34       	cpi	r16, 0x41	; 65
    11ee:	0c 00       	.word	0x000c	; ????
    11f0:	00 30       	cpi	r16, 0x00	; 0
    11f2:	c1 0b       	sbc	r28, r17
    11f4:	00 00       	nop
    11f6:	f2 03       	fmuls	r23, r18
    11f8:	00 00       	nop
    11fa:	44 cb       	rjmp	.-2424   	; 0x884 <_GLOBAL__sub_I___vector_18+0x26>
    11fc:	0b 00       	.word	0x000b	; ????
    11fe:	00 01       	movw	r0, r0
    1200:	62 33       	cpi	r22, 0x32	; 50
    1202:	8f 0b       	sbc	r24, r31
    1204:	00 00       	nop
    1206:	d0 02       	muls	r29, r16
    1208:	00 00       	nop
    120a:	dc 02       	muls	r29, r28
    120c:	00 00       	nop
    120e:	30 9f       	mul	r19, r16
    1210:	0b 00       	.word	0x000b	; ????
    1212:	00 28       	or	r0, r0
    1214:	04 00       	.word	0x0004	; ????
    1216:	00 31       	cpi	r16, 0x10	; 16
    1218:	d0 02       	muls	r29, r16
    121a:	00 00       	nop
    121c:	dc 02       	muls	r29, r28
    121e:	00 00       	nop
    1220:	32 a9       	ldd	r19, Z+50	; 0x32
    1222:	0b 00       	.word	0x000b	; ????
    1224:	00 00       	nop
    1226:	00 00       	nop
    1228:	34 7a       	andi	r19, 0xA4	; 164
    122a:	03 00       	.word	0x0003	; ????
    122c:	00 de       	rcall	.-1024   	; 0xe2e <__data_load_end+0x52c>
    122e:	02 00       	.word	0x0002	; ????
    1230:	00 78       	andi	r16, 0x80	; 128
    1232:	03 00       	.word	0x0003	; ????
    1234:	00 4e       	sbci	r16, 0xE0	; 224
    1236:	04 00       	.word	0x0004	; ????
    1238:	00 4e       	sbci	r16, 0xE0	; 224
    123a:	0c 00       	.word	0x000c	; ????
    123c:	00 01       	movw	r0, r0
    123e:	23 0d       	add	r18, r3
    1240:	00 00       	nop
    1242:	35 d0       	rcall	.+106    	; 0x12ae <__data_load_end+0x9ac>
    1244:	05 00       	.word	0x0005	; ????
    1246:	00 7f       	andi	r16, 0xF0	; 240
    1248:	06 00       	.word	0x0006	; ????
    124a:	00 01       	movw	r0, r0
    124c:	b1 04       	cpc	r11, r1
    124e:	00 00       	nop
    1250:	45 63       	ori	r20, 0x35	; 53
    1252:	00 03       	mulsu	r16, r16
    1254:	e1 86       	std	Z+9, r14	; 0x09
    1256:	01 00       	.word	0x0001	; ????
    1258:	00 f7       	brcc	.-64     	; 0x121a <__data_load_end+0x918>
    125a:	04 00       	.word	0x0004	; ????
    125c:	00 46       	sbci	r16, 0x60	; 96
    125e:	69 00       	.word	0x0069	; ????
    1260:	03 fb       	bst	r16, 3
    1262:	9d 01       	movw	r18, r26
    1264:	00 00       	nop
    1266:	01 60       	ori	r16, 0x01	; 1
    1268:	47 02       	muls	r20, r23
    126a:	03 00       	.word	0x0003	; ????
    126c:	00 16       	cp	r0, r16
    126e:	03 00       	.word	0x0003	; ????
    1270:	00 af       	std	Z+56, r16	; 0x38
    1272:	0c 00       	.word	0x000c	; ????
    1274:	00 48       	sbci	r16, 0x80	; 128
    1276:	7d 03       	fmul	r23, r21
    1278:	00 00       	nop
    127a:	03 f1       	brvs	.+64     	; 0x12bc <__data_load_end+0x9ba>
    127c:	86 01       	movw	r16, r12
    127e:	00 00       	nop
    1280:	2e 05       	cpc	r18, r14
    1282:	00 00       	nop
    1284:	48 92       	.word	0x9248	; ????
    1286:	04 00       	.word	0x0004	; ????
    1288:	00 03       	mulsu	r16, r16
    128a:	f1 86       	std	Z+9, r15	; 0x09
    128c:	01 00       	.word	0x0001	; ????
    128e:	00 41       	sbci	r16, 0x10	; 16
    1290:	05 00       	.word	0x0005	; ????
    1292:	00 49       	sbci	r16, 0x90	; 144
    1294:	23 0d       	add	r18, r3
    1296:	00 00       	nop
    1298:	04 03       	mulsu	r16, r20
    129a:	00 00       	nop
    129c:	06 03       	mulsu	r16, r22
    129e:	00 00       	nop
    12a0:	03 f1       	brvs	.+64     	; 0x12e2 <__data_load_end+0x9e0>
    12a2:	00 4a       	sbci	r16, 0xA0	; 160
    12a4:	18 00       	.word	0x0018	; ????
    12a6:	00 00       	nop
    12a8:	0d 0d       	add	r16, r13
    12aa:	00 00       	nop
    12ac:	4b 7d       	andi	r20, 0xDB	; 219
    12ae:	03 00       	.word	0x0003	; ????
    12b0:	00 03       	mulsu	r16, r16
    12b2:	11 01       	movw	r2, r2
    12b4:	86 01       	movw	r16, r12
    12b6:	00 00       	nop
    12b8:	55 05       	cpc	r21, r5
    12ba:	00 00       	nop
    12bc:	4b 92       	.word	0x924b	; ????
    12be:	04 00       	.word	0x0004	; ????
    12c0:	00 03       	mulsu	r16, r16
    12c2:	11 01       	movw	r2, r2
    12c4:	86 01       	movw	r16, r12
    12c6:	00 00       	nop
    12c8:	68 05       	cpc	r22, r8
    12ca:	00 00       	nop
    12cc:	4c 30       	cpi	r20, 0x0C	; 12
    12ce:	0d 00       	.word	0x000d	; ????
    12d0:	00 18       	sub	r0, r0
    12d2:	03 00       	.word	0x0003	; ????
    12d4:	00 1a       	sub	r0, r16
    12d6:	03 00       	.word	0x0003	; ????
    12d8:	00 03       	mulsu	r16, r16
    12da:	11 01       	movw	r2, r2
    12dc:	fc 0c       	add	r15, r12
    12de:	00 00       	nop
    12e0:	37 5f       	subi	r19, 0xF7	; 247
    12e2:	5f 73       	andi	r21, 0x3F	; 63
    12e4:	00 05       	cpc	r16, r0
    12e6:	44 d6       	rcall	.+3208   	; 0x1f70 <__data_load_end+0x166e>
    12e8:	09 00       	.word	0x0009	; ????
    12ea:	00 88       	ldd	r0, Z+16	; 0x10
    12ec:	05 00       	.word	0x0005	; ????
    12ee:	00 00       	nop
    12f0:	4d 23       	and	r20, r29
    12f2:	0d 00       	.word	0x000d	; ????
    12f4:	00 6a       	ori	r16, 0xA0	; 160
    12f6:	03 00       	.word	0x0003	; ????
    12f8:	00 6c       	ori	r16, 0xC0	; 192
    12fa:	03 00       	.word	0x0003	; ????
    12fc:	00 03       	mulsu	r16, r16
    12fe:	11 01       	movw	r2, r2
    1300:	00 3d       	cpi	r16, 0xD0	; 208
    1302:	58 03       	fmul	r21, r16
    1304:	00 00       	nop
    1306:	b3 0b       	sbc	r27, r19
    1308:	00 00       	nop
    130a:	39 06       	cpc	r3, r25
    130c:	68 93       	.word	0x9368	; ????
    130e:	01 69       	ori	r16, 0x91	; 145
    1310:	93 01       	movw	r18, r6
    1312:	02 8c       	ldd	r0, Z+26	; 0x1a
    1314:	00 00       	nop
    1316:	00 4e       	sbci	r16, 0xE0	; 224
    1318:	0a 08       	sbc	r0, r10
    131a:	00 00       	nop
    131c:	05 30       	cpi	r16, 0x05	; 5
    131e:	01 86       	std	Z+9, r0	; 0x09
    1320:	01 00       	.word	0x0001	; ????
    1322:	00 03       	mulsu	r16, r16
    1324:	3e 35       	cpi	r19, 0x5E	; 94
    1326:	05 00       	.word	0x0005	; ????
    1328:	00 05       	cpc	r16, r0
    132a:	44 01       	movw	r8, r8
    132c:	03 1e       	adc	r0, r19
    132e:	a3 03       	fmuls	r18, r19
    1330:	00 00       	nop
    1332:	03 cd       	rjmp	.-1530   	; 0xd3a <__data_load_end+0x438>
    1334:	01 49       	sbci	r16, 0x91	; 145
    1336:	0d 00       	.word	0x000d	; ????
    1338:	00 54       	subi	r16, 0x40	; 64
    133a:	0d 00       	.word	0x000d	; ????
    133c:	00 1f       	adc	r16, r16
    133e:	d0 05       	cpc	r29, r0
    1340:	00 00       	nop
    1342:	7f 06       	cpc	r7, r31
    1344:	00 00       	nop
    1346:	01 00       	.word	0x0001	; ????
    1348:	22 c2       	rjmp	.+1092   	; 0x178e <__data_load_end+0xe8c>
    134a:	03 00       	.word	0x0003	; ????
    134c:	00 01       	movw	r0, r0
    134e:	62 0d       	add	r22, r2
    1350:	00 00       	nop
    1352:	74 0d       	add	r23, r4
    1354:	00 00       	nop
    1356:	1f d0       	rcall	.+62     	; 0x1396 <__data_load_end+0xa94>
    1358:	05 00       	.word	0x0005	; ????
    135a:	00 7f       	andi	r16, 0xF0	; 240
    135c:	06 00       	.word	0x0006	; ????
    135e:	00 01       	movw	r0, r0
    1360:	20 42       	sbci	r18, 0x20	; 32
    1362:	49 0d       	add	r20, r9
    1364:	00 00       	nop
    1366:	00 00       	nop
    1368:	4f 54       	subi	r20, 0x4F	; 79
    136a:	0d 00       	.word	0x000d	; ????
    136c:	00 78       	andi	r16, 0x80	; 128
    136e:	03 00       	.word	0x0003	; ????
    1370:	00 b8       	out	0x00, r0	; 0
    1372:	03 00       	.word	0x0003	; ????
    1374:	00 a0       	ldd	r0, Z+32	; 0x20
    1376:	05 00       	.word	0x0005	; ????
    1378:	00 8e       	std	Z+24, r0	; 0x18
    137a:	0d 00       	.word	0x000d	; ????
    137c:	00 01       	movw	r0, r0
    137e:	c0 0d       	add	r28, r0
    1380:	00 00       	nop
    1382:	30 62       	ori	r19, 0x20	; 32
    1384:	0d 00       	.word	0x000d	; ????
    1386:	00 cf       	rjmp	.-512    	; 0x1188 <__data_load_end+0x886>
    1388:	05 00       	.word	0x0005	; ????
    138a:	00 33       	cpi	r16, 0x30	; 48
    138c:	39 0d       	add	r19, r9
    138e:	00 00       	nop
    1390:	84 03       	fmuls	r16, r20
    1392:	00 00       	nop
    1394:	b2 03       	fmuls	r19, r18
    1396:	00 00       	nop
    1398:	42 49       	sbci	r20, 0x92	; 146
    139a:	0d 00       	.word	0x000d	; ????
    139c:	00 3d       	cpi	r16, 0xD0	; 208
    139e:	b0 03       	fmuls	r19, r16
    13a0:	00 00       	nop
    13a2:	b3 0b       	sbc	r27, r19
    13a4:	00 00       	nop
    13a6:	39 06       	cpc	r3, r25
    13a8:	68 93       	.word	0x9368	; ????
    13aa:	01 69       	ori	r16, 0x91	; 145
    13ac:	93 01       	movw	r18, r6
    13ae:	02 8c       	ldd	r0, Z+26	; 0x1a
    13b0:	00 00       	nop
    13b2:	00 00       	nop
    13b4:	50 71       	andi	r21, 0x10	; 16
    13b6:	08 00       	.word	0x0008	; ????
    13b8:	00 b8       	out	0x00, r0	; 0
    13ba:	03 00       	.word	0x0003	; ????
    13bc:	00 f2       	brcs	.-128    	; 0x133e <__data_load_end+0xa3c>
    13be:	03 00       	.word	0x0003	; ????
    13c0:	00 05       	cpc	r16, r0
    13c2:	06 00       	.word	0x0006	; ????
    13c4:	00 01       	movw	r0, r0
    13c6:	dc 0e       	add	r13, r28
    13c8:	00 00       	nop
    13ca:	30 89       	ldd	r19, Z+16	; 0x10
    13cc:	08 00       	.word	0x0008	; ????
    13ce:	00 34       	cpi	r16, 0x40	; 64
    13d0:	06 00       	.word	0x0006	; ????
    13d2:	00 2c       	mov	r0, r0
    13d4:	92 08       	sbc	r9, r2
    13d6:	00 00       	nop
    13d8:	6a 06       	cpc	r6, r26
    13da:	00 00       	nop
    13dc:	2b 7f       	andi	r18, 0xFB	; 251
    13de:	08 00       	.word	0x0008	; ????
    13e0:	00 06       	cpc	r0, r16
    13e2:	03 43       	sbci	r16, 0x33	; 51
    13e4:	01 80       	ldd	r0, Z+1	; 0x01
    13e6:	00 9f       	mul	r16, r16
    13e8:	51 dc       	rcall	.-1886   	; 0xc8c <__data_load_end+0x38a>
    13ea:	0e 00       	.word	0x000e	; ????
    13ec:	00 bc       	out	0x20, r0	; 32
    13ee:	03 00       	.word	0x0003	; ????
    13f0:	00 d8       	rcall	.-4096   	; 0x3f2 <__vector_16>
    13f2:	03 00       	.word	0x0003	; ????
    13f4:	00 02       	muls	r16, r16
    13f6:	8c 6c       	ori	r24, 0xCC	; 204
    13f8:	0e 00       	.word	0x000e	; ????
    13fa:	00 52       	subi	r16, 0x20	; 32
    13fc:	92 06       	cpc	r9, r18
    13fe:	00 00       	nop
    1400:	53 54       	subi	r21, 0x43	; 67
    1402:	4d 08       	sbc	r4, r13
    1404:	00 00       	nop
    1406:	bc 03       	fmulsu	r19, r20
    1408:	00 00       	nop
    140a:	d8 03       	fmulsu	r21, r16
    140c:	00 00       	nop
    140e:	02 40       	sbci	r16, 0x02	; 2
    1410:	42 5b       	subi	r20, 0xB2	; 178
    1412:	08 00       	.word	0x0008	; ????
    1414:	00 30       	cpi	r16, 0x00	; 0
    1416:	65 08       	sbc	r6, r5
    1418:	00 00       	nop
    141a:	c8 06       	cpc	r12, r24
    141c:	00 00       	nop
    141e:	33 27       	eor	r19, r19
    1420:	08 00       	.word	0x0008	; ????
    1422:	00 bc       	out	0x20, r0	; 32
    1424:	03 00       	.word	0x0003	; ????
    1426:	00 d8       	rcall	.-4096   	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
    1428:	03 00       	.word	0x0003	; ????
    142a:	00 42       	sbci	r16, 0x20	; 32
    142c:	37 08       	sbc	r3, r7
    142e:	00 00       	nop
    1430:	30 41       	sbci	r19, 0x10	; 16
    1432:	08 00       	.word	0x0008	; ????
    1434:	00 fe       	sbrs	r0, 0
    1436:	06 00       	.word	0x0006	; ????
    1438:	00 3d       	cpi	r16, 0xD0	; 208
    143a:	d6 03       	fmuls	r21, r22
    143c:	00 00       	nop
    143e:	e8 09       	sbc	r30, r8
    1440:	00 00       	nop
    1442:	39 06       	cpc	r3, r25
    1444:	68 93       	.word	0x9368	; ????
    1446:	01 69       	ori	r16, 0x91	; 145
    1448:	93 01       	movw	r18, r6
    144a:	05 03       	mulsu	r16, r21
    144c:	43 01       	movw	r8, r6
    144e:	80 00       	.word	0x0080	; ????
    1450:	39 06       	cpc	r3, r25
    1452:	66 93       	lac	Z, r22
    1454:	01 67       	ori	r16, 0x71	; 113
    1456:	93 01       	movw	r18, r6
    1458:	03 f3       	brvs	.-64     	; 0x141a <__data_load_end+0xb18>
    145a:	01 68       	ori	r16, 0x81	; 129
    145c:	00 00       	nop
    145e:	00 00       	nop
    1460:	54 fc       	sbrc	r5, 4
    1462:	07 00       	.word	0x0007	; ????
    1464:	00 d8       	rcall	.-4096   	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
    1466:	03 00       	.word	0x0003	; ????
    1468:	00 e8       	ldi	r16, 0x80	; 128
    146a:	03 00       	.word	0x0003	; ????
    146c:	00 02       	muls	r16, r16
    146e:	8d 42       	sbci	r24, 0x2D	; 45
    1470:	0a 08       	sbc	r0, r10
    1472:	00 00       	nop
    1474:	54 4d       	sbci	r21, 0xD4	; 212
    1476:	08 00       	.word	0x0008	; ????
    1478:	00 d8       	rcall	.-4096   	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
    147a:	03 00       	.word	0x0003	; ????
    147c:	00 e8       	ldi	r16, 0x80	; 128
    147e:	03 00       	.word	0x0003	; ????
    1480:	00 02       	muls	r16, r16
    1482:	80 53       	subi	r24, 0x30	; 48
    1484:	53 33       	cpi	r21, 0x33	; 51
    1486:	27 08       	sbc	r2, r7
    1488:	00 00       	nop
    148a:	d8 03       	fmulsu	r21, r16
    148c:	00 00       	nop
    148e:	e8 03       	fmulsu	r22, r16
    1490:	00 00       	nop
    1492:	42 37       	cpi	r20, 0x72	; 114
    1494:	08 00       	.word	0x0008	; ????
    1496:	00 42       	sbci	r16, 0x20	; 32
    1498:	41 08       	sbc	r4, r1
    149a:	00 00       	nop
    149c:	3d e8       	ldi	r19, 0x8D	; 141
    149e:	03 00       	.word	0x0003	; ????
    14a0:	00 e8       	ldi	r16, 0x80	; 128
    14a2:	09 00       	.word	0x0009	; ????
    14a4:	00 39       	cpi	r16, 0x90	; 144
    14a6:	06 68       	ori	r16, 0x86	; 134
    14a8:	93 01       	movw	r18, r6
    14aa:	69 93       	st	Y+, r22
    14ac:	01 05       	cpc	r16, r1
    14ae:	03 43       	sbci	r16, 0x33	; 51
    14b0:	01 80       	ldd	r0, Z+1	; 0x01
    14b2:	00 39       	cpi	r16, 0x90	; 144
    14b4:	06 66       	ori	r16, 0x66	; 102
    14b6:	93 01       	movw	r18, r6
    14b8:	67 93       	lat	Z, r22
    14ba:	01 05       	cpc	r16, r1
    14bc:	03 16       	cp	r0, r19
    14be:	01 80       	ldd	r0, Z+1	; 0x01
    14c0:	00 39       	cpi	r16, 0x90	; 144
    14c2:	06 64       	ori	r16, 0x46	; 70
    14c4:	93 01       	movw	r18, r6
    14c6:	65 93       	las	Z, r22
    14c8:	01 01       	movw	r0, r2
    14ca:	32 00       	.word	0x0032	; ????
    14cc:	00 00       	nop
    14ce:	00 00       	nop
    14d0:	55 01       	movw	r10, r10
    14d2:	01 00       	.word	0x0001	; ????
    14d4:	00 01       	movw	r0, r0
    14d6:	56 01       	movw	r10, r12
    14d8:	7c 06       	cpc	r7, r28
    14da:	00 00       	nop
    14dc:	07 2d       	mov	r16, r7
    14de:	01 f2       	breq	.-128    	; 0x1460 <__data_load_end+0xb5e>
    14e0:	03 00       	.word	0x0003	; ????
    14e2:	00 86       	std	Z+8, r0	; 0x08
    14e4:	04 00       	.word	0x0004	; ????
    14e6:	00 34       	cpi	r16, 0x40	; 64
    14e8:	07 00       	.word	0x0007	; ????
    14ea:	00 01       	movw	r0, r0
    14ec:	17 0f       	add	r17, r23
    14ee:	00 00       	nop
    14f0:	37 6d       	ori	r19, 0xD7	; 215
    14f2:	00 07       	cpc	r16, r16
    14f4:	32 7f       	andi	r19, 0xF2	; 242
    14f6:	01 00       	.word	0x0001	; ????
    14f8:	00 b1       	in	r16, 0x00	; 0
    14fa:	07 00       	.word	0x0007	; ????
    14fc:	00 37       	cpi	r16, 0x70	; 112
    14fe:	66 00       	.word	0x0066	; ????
    1500:	07 33       	cpi	r16, 0x37	; 55
    1502:	96 01       	movw	r18, r12
    1504:	00 00       	nop
    1506:	24 08       	sbc	r2, r4
    1508:	00 00       	nop
    150a:	00 3e       	cpi	r16, 0xE0	; 224
    150c:	77 03       	mulsu	r23, r23
    150e:	00 00       	nop
    1510:	09 07       	cpc	r16, r25
    1512:	01 01       	movw	r0, r2
    1514:	3e b3       	in	r19, 0x1e	; 30
    1516:	02 00       	.word	0x0002	; ????
    1518:	00 08       	sbc	r0, r0
    151a:	1c 01       	movw	r2, r24
    151c:	01 3e       	cpi	r16, 0xE1	; 225
    151e:	31 08       	sbc	r3, r1
    1520:	00 00       	nop
    1522:	07 f1       	brie	.+64     	; 0x1564 <__data_load_end+0xc62>
    1524:	01 01       	movw	r0, r2
    1526:	25 cc       	rjmp	.-1974   	; 0xd72 <__data_load_end+0x470>
    1528:	07 00       	.word	0x0007	; ????
    152a:	00 09       	sbc	r16, r0
    152c:	4c 01       	movw	r8, r24
    152e:	01 56       	subi	r16, 0x61	; 97
    1530:	0f 00       	.word	0x000f	; ????
    1532:	00 27       	eor	r16, r16
    1534:	0b 03       	fmul	r16, r19
    1536:	00 00       	nop
    1538:	09 4d       	sbci	r16, 0xD9	; 217
    153a:	2a 01       	movw	r4, r20
    153c:	00 00       	nop
    153e:	27 76       	andi	r18, 0x67	; 103
    1540:	04 00       	.word	0x0004	; ????
    1542:	00 09       	sbc	r16, r0
    1544:	4d 2a       	or	r4, r29
    1546:	01 00       	.word	0x0001	; ????
    1548:	00 00       	nop
    154a:	57 01       	movw	r10, r14
    154c:	8d 02       	muls	r24, r29
    154e:	00 00       	nop
    1550:	08 21       	and	r16, r8
    1552:	01 2a       	or	r0, r17
    1554:	01 00       	.word	0x0001	; ????
    1556:	00 01       	movw	r0, r0
    1558:	36 05       	cpc	r19, r6
    155a:	00 00       	nop
    155c:	5e 08       	sbc	r5, r14
    155e:	00 00       	nop
    1560:	03 92       	.word	0x9203	; ????
    1562:	20 02       	muls	r18, r16
    1564:	01 a0       	ldd	r0, Z+33	; 0x21
    1566:	11 00       	.word	0x0011	; ????
    1568:	00 49       	sbci	r16, 0x90	; 144
    156a:	29 0f       	add	r18, r25
    156c:	00 00       	nop
    156e:	36 05       	cpc	r19, r6
    1570:	00 00       	nop
    1572:	bc 05       	cpc	r27, r12
    1574:	00 00       	nop
    1576:	08 23       	and	r16, r24
    1578:	51 17       	cp	r21, r17
    157a:	0f 00       	.word	0x000f	; ????
    157c:	00 bc       	out	0x20, r0	; 32
    157e:	05 00       	.word	0x0005	; ????
    1580:	00 e4       	ldi	r16, 0x40	; 64
    1582:	06 00       	.word	0x0006	; ????
    1584:	00 08       	sbc	r0, r0
    1586:	2b ff       	.word	0xff2b	; ????
    1588:	10 00       	.word	0x0010	; ????
    158a:	00 51       	subi	r16, 0x10	; 16
    158c:	8a 05       	cpc	r24, r10
    158e:	00 00       	nop
    1590:	bc 05       	cpc	r27, r12
    1592:	00 00       	nop
    1594:	f2 05       	cpc	r31, r2
    1596:	00 00       	nop
    1598:	09 0a       	sbc	r0, r25
    159a:	8a 10       	cpse	r8, r10
    159c:	00 00       	nop
    159e:	30 97       	sbiw	r30, 0x00	; 0
    15a0:	05 00       	.word	0x0005	; ????
    15a2:	00 74       	andi	r16, 0x40	; 64
    15a4:	08 00       	.word	0x0008	; ????
    15a6:	00 30       	cpi	r16, 0x00	; 0
    15a8:	a2 05       	cpc	r26, r2
    15aa:	00 00       	nop
    15ac:	88 08       	sbc	r8, r8
    15ae:	00 00       	nop
    15b0:	31 bc       	out	0x21, r3	; 33
    15b2:	05 00       	.word	0x0005	; ????
    15b4:	00 f2       	brcs	.-128    	; 0x1536 <__data_load_end+0xc34>
    15b6:	05 00       	.word	0x0005	; ????
    15b8:	00 2c       	mov	r0, r0
    15ba:	ad 05       	cpc	r26, r13
    15bc:	00 00       	nop
    15be:	9c 08       	sbc	r9, r12
    15c0:	00 00       	nop
    15c2:	2c b8       	out	0x0c, r2	; 12
    15c4:	05 00       	.word	0x0005	; ????
    15c6:	00 af       	std	Z+56, r16	; 0x38
    15c8:	08 00       	.word	0x0008	; ????
    15ca:	00 2c       	mov	r0, r0
    15cc:	c3 05       	cpc	r28, r3
    15ce:	00 00       	nop
    15d0:	c2 08       	sbc	r12, r2
    15d2:	00 00       	nop
    15d4:	32 ce       	rjmp	.-924    	; 0x123a <__data_load_end+0x938>
    15d6:	05 00       	.word	0x0005	; ????
    15d8:	00 2e       	mov	r0, r16
    15da:	60 06       	cpc	r6, r16
    15dc:	00 00       	nop
    15de:	bc 05       	cpc	r27, r12
    15e0:	00 00       	nop
    15e2:	c2 05       	cpc	r28, r2
    15e4:	00 00       	nop
    15e6:	09 10       	cpse	r0, r9
    15e8:	00 00       	nop
    15ea:	2c 61       	ori	r18, 0x1C	; 28
    15ec:	06 00       	.word	0x0006	; ????
    15ee:	00 da       	rcall	.-3072   	; 0x9f0 <__data_load_end+0xee>
    15f0:	08 00       	.word	0x0008	; ????
    15f2:	00 2c       	mov	r0, r0
    15f4:	6c 06       	cpc	r6, r28
    15f6:	00 00       	nop
    15f8:	f2 08       	sbc	r15, r2
    15fa:	00 00       	nop
    15fc:	00 2e       	mov	r0, r16
    15fe:	44 06       	cpc	r4, r20
    1600:	00 00       	nop
    1602:	c2 05       	cpc	r28, r2
    1604:	00 00       	nop
    1606:	c8 05       	cpc	r28, r8
    1608:	00 00       	nop
    160a:	2d 10       	cpse	r2, r13
    160c:	00 00       	nop
    160e:	2c 49       	sbci	r18, 0x9C	; 156
    1610:	06 00       	.word	0x0006	; ????
    1612:	00 05       	cpc	r16, r0
    1614:	09 00       	.word	0x0009	; ????
    1616:	00 2c       	mov	r0, r0
    1618:	54 06       	cpc	r5, r20
    161a:	00 00       	nop
    161c:	af 08       	sbc	r10, r15
    161e:	00 00       	nop
    1620:	00 2e       	mov	r0, r16
    1622:	28 06       	cpc	r2, r24
    1624:	00 00       	nop
    1626:	cc 05       	cpc	r28, r12
    1628:	00 00       	nop
    162a:	dc 05       	cpc	r29, r12
    162c:	00 00       	nop
    162e:	51 10       	cpse	r5, r1
    1630:	00 00       	nop
    1632:	2c 2d       	mov	r18, r12
    1634:	06 00       	.word	0x0006	; ????
    1636:	00 1d       	adc	r16, r0
    1638:	09 00       	.word	0x0009	; ????
    163a:	00 2c       	mov	r0, r0
    163c:	38 06       	cpc	r3, r24
    163e:	00 00       	nop
    1640:	c2 08       	sbc	r12, r2
    1642:	00 00       	nop
    1644:	00 2e       	mov	r0, r16
    1646:	0c 06       	cpc	r0, r28
    1648:	00 00       	nop
    164a:	dc 05       	cpc	r29, r12
    164c:	00 00       	nop
    164e:	e6 05       	cpc	r30, r6
    1650:	00 00       	nop
    1652:	71 10       	cpse	r7, r1
    1654:	00 00       	nop
    1656:	2c 11       	cpse	r18, r12
    1658:	06 00       	.word	0x0006	; ????
    165a:	00 35       	cpi	r16, 0x50	; 80
    165c:	09 00       	.word	0x0009	; ????
    165e:	00 32       	cpi	r16, 0x20	; 32
    1660:	1c 06       	cpc	r1, r28
    1662:	00 00       	nop
    1664:	00 33       	cpi	r16, 0x30	; 48
    1666:	d9 05       	cpc	r29, r9
    1668:	00 00       	nop
    166a:	e6 05       	cpc	r30, r6
    166c:	00 00       	nop
    166e:	f2 05       	cpc	r31, r2
    1670:	00 00       	nop
    1672:	2c de       	rcall	.-936    	; 0x12cc <__data_load_end+0x9ca>
    1674:	05 00       	.word	0x0005	; ????
    1676:	00 4d       	sbci	r16, 0xD0	; 208
    1678:	09 00       	.word	0x0009	; ????
    167a:	00 00       	nop
    167c:	00 00       	nop
    167e:	51 ed       	ldi	r21, 0xD1	; 209
    1680:	06 00       	.word	0x0006	; ????
    1682:	00 f2       	brcs	.-128    	; 0x1604 <__data_load_end+0xd02>
    1684:	05 00       	.word	0x0005	; ????
    1686:	00 5c       	subi	r16, 0xC0	; 192
    1688:	06 00       	.word	0x0006	; ????
    168a:	00 09       	sbc	r16, r0
    168c:	0b e6       	ldi	r16, 0x6B	; 107
    168e:	10 00       	.word	0x0010	; ????
    1690:	00 42       	sbci	r16, 0x20	; 32
    1692:	fb 06       	cpc	r15, r27
    1694:	00 00       	nop
    1696:	30 05       	cpc	r19, r0
    1698:	07 00       	.word	0x0007	; ????
    169a:	00 60       	ori	r16, 0x00	; 0
    169c:	09 00       	.word	0x0009	; ????
    169e:	00 54       	subi	r16, 0x40	; 64
    16a0:	84 06       	cpc	r8, r20
    16a2:	00 00       	nop
    16a4:	f2 05       	cpc	r31, r2
    16a6:	00 00       	nop
    16a8:	5c 06       	cpc	r5, r28
    16aa:	00 00       	nop
    16ac:	0e 79       	andi	r16, 0x9E	; 158
    16ae:	42 92       	st	-Z, r4
    16b0:	06 00       	.word	0x0006	; ????
    16b2:	00 30       	cpi	r16, 0x00	; 0
    16b4:	9c 06       	cpc	r9, r28
    16b6:	00 00       	nop
    16b8:	60 09       	sbc	r22, r0
    16ba:	00 00       	nop
    16bc:	30 a7       	std	Z+40, r19	; 0x28
    16be:	06 00       	.word	0x0006	; ????
    16c0:	00 76       	andi	r16, 0x60	; 96
    16c2:	09 00       	.word	0x0009	; ????
    16c4:	00 31       	cpi	r16, 0x10	; 16
    16c6:	f2 05       	cpc	r31, r2
    16c8:	00 00       	nop
    16ca:	5c 06       	cpc	r5, r28
    16cc:	00 00       	nop
    16ce:	2c b2       	in	r2, 0x1c	; 28
    16d0:	06 00       	.word	0x0006	; ????
    16d2:	00 8a       	std	Z+16, r0	; 0x10
    16d4:	09 00       	.word	0x0009	; ????
    16d6:	00 00       	nop
    16d8:	00 00       	nop
    16da:	3d 64       	ori	r19, 0x4D	; 77
    16dc:	06 00       	.word	0x0006	; ????
    16de:	00 c0       	rjmp	.+0      	; 0x16e0 <__data_load_end+0xdde>
    16e0:	0d 00       	.word	0x000d	; ????
    16e2:	00 39       	cpi	r16, 0x90	; 144
    16e4:	06 68       	ori	r16, 0x86	; 134
    16e6:	93 01       	movw	r18, r6
    16e8:	69 93       	st	Y+, r22
    16ea:	01 05       	cpc	r16, r1
    16ec:	03 19       	sub	r16, r3
    16ee:	01 80       	ldd	r0, Z+1	; 0x01
    16f0:	00 00       	nop
    16f2:	00 2f       	mov	r16, r16
    16f4:	58 0b       	sbc	r21, r24
    16f6:	00 00       	nop
    16f8:	e4 06       	cpc	r14, r20
    16fa:	00 00       	nop
    16fc:	30 00       	.word	0x0030	; ????
    16fe:	00 00       	nop
    1700:	08 2f       	mov	r16, r24
    1702:	21 11       	cpse	r18, r1
    1704:	00 00       	nop
    1706:	40 52       	subi	r20, 0x20	; 32
    1708:	08 00       	.word	0x0008	; ????
    170a:	00 22       	and	r0, r16
    170c:	0b 00       	.word	0x000b	; ????
    170e:	00 58       	subi	r16, 0x80	; 128
    1710:	5c 08       	sbc	r5, r12
    1712:	00 00       	nop
    1714:	00 54       	subi	r16, 0x40	; 64
    1716:	32 0f       	add	r19, r18
    1718:	00 00       	nop
    171a:	e8 06       	cpc	r14, r24
    171c:	00 00       	nop
    171e:	48 08       	sbc	r4, r8
    1720:	00 00       	nop
    1722:	08 2e       	mov	r0, r24
    1724:	31 e8       	ldi	r19, 0x81	; 129
    1726:	06 00       	.word	0x0006	; ????
    1728:	00 48       	sbci	r16, 0x80	; 128
    172a:	08 00       	.word	0x0008	; ????
    172c:	00 32       	cpi	r16, 0x20	; 32
    172e:	3f 0f       	add	r19, r31
    1730:	00 00       	nop
    1732:	32 4a       	sbci	r19, 0xA2	; 162
    1734:	0f 00       	.word	0x000f	; ????
    1736:	00 59       	subi	r16, 0x90	; 144
    1738:	f0 06       	cpc	r15, r16
    173a:	00 00       	nop
    173c:	c0 0d       	add	r28, r0
    173e:	00 00       	nop
    1740:	5f 11       	cpse	r21, r15
    1742:	00 00       	nop
    1744:	39 06       	cpc	r3, r25
    1746:	68 93       	.word	0x9368	; ????
    1748:	01 69       	ori	r16, 0x91	; 145
    174a:	93 01       	movw	r18, r6
    174c:	05 03       	mulsu	r16, r21
    174e:	22 01       	movw	r4, r4
    1750:	80 00       	.word	0x0080	; ????
    1752:	00 59       	subi	r16, 0x90	; 144
    1754:	f8 06       	cpc	r15, r24
    1756:	00 00       	nop
    1758:	cd 08       	sbc	r12, r13
    175a:	00 00       	nop
    175c:	72 11       	cpse	r23, r2
    175e:	00 00       	nop
    1760:	39 01       	movw	r6, r18
    1762:	68 01       	movw	r12, r16
    1764:	30 00       	.word	0x0030	; ????
    1766:	59 fe       	.word	0xfe59	; ????
    1768:	06 00       	.word	0x0006	; ????
    176a:	00 cd       	rjmp	.-1536   	; 0x116c <__data_load_end+0x86a>
    176c:	08 00       	.word	0x0008	; ????
    176e:	00 85       	ldd	r16, Z+8	; 0x08
    1770:	11 00       	.word	0x0011	; ????
    1772:	00 39       	cpi	r16, 0x90	; 144
    1774:	01 68       	ori	r16, 0x81	; 129
    1776:	01 31       	cpi	r16, 0x11	; 17
    1778:	00 3d       	cpi	r16, 0xD0	; 208
    177a:	46 08       	sbc	r4, r6
    177c:	00 00       	nop
    177e:	c0 0d       	add	r28, r0
    1780:	00 00       	nop
    1782:	39 06       	cpc	r3, r25
    1784:	68 93       	.word	0x9368	; ????
    1786:	01 69       	ori	r16, 0x91	; 145
    1788:	93 01       	movw	r18, r6
    178a:	05 03       	mulsu	r16, r21
    178c:	2e 01       	movw	r4, r28
    178e:	80 00       	.word	0x0080	; ????
    1790:	00 00       	nop
    1792:	00 00       	nop
    1794:	5a d5       	rcall	.+2740   	; 0x224a <__data_load_end+0x1948>
    1796:	05 00       	.word	0x0005	; ????
    1798:	00 01       	movw	r0, r0
    179a:	01 5e       	subi	r16, 0xE1	; 225
    179c:	08 00       	.word	0x0008	; ????
    179e:	00 b8       	out	0x00, r0	; 0
    17a0:	08 00       	.word	0x0008	; ????
    17a2:	00 03       	mulsu	r16, r16
    17a4:	92 20       	and	r9, r2
    17a6:	02 01       	movw	r0, r4
    17a8:	21 12       	cpse	r2, r17
    17aa:	00 00       	nop
    17ac:	54 67       	ori	r21, 0x74	; 116
    17ae:	05 00       	.word	0x0005	; ????
    17b0:	00 5e       	subi	r16, 0xE0	; 224
    17b2:	08 00       	.word	0x0008	; ????
    17b4:	00 b6       	in	r0, 0x30	; 48
    17b6:	08 00       	.word	0x0008	; ????
    17b8:	00 04       	cpc	r0, r0
    17ba:	4d 30       	cpi	r20, 0x0D	; 13
    17bc:	73 05       	cpc	r23, r3
    17be:	00 00       	nop
    17c0:	9f 09       	sbc	r25, r15
    17c2:	00 00       	nop
    17c4:	30 7e       	andi	r19, 0xE0	; 224
    17c6:	05 00       	.word	0x0005	; ????
    17c8:	00 b3       	in	r16, 0x10	; 16
    17ca:	09 00       	.word	0x0009	; ????
    17cc:	00 54       	subi	r16, 0x40	; 64
    17ce:	21 12       	cpse	r2, r17
    17d0:	00 00       	nop
    17d2:	5e 08       	sbc	r5, r14
    17d4:	00 00       	nop
    17d6:	b6 08       	sbc	r11, r6
    17d8:	00 00       	nop
    17da:	04 46       	sbci	r16, 0x64	; 100
    17dc:	5b c6       	rjmp	.+3254   	; 0x2494 <__data_load_end+0x1b92>
    17de:	5b c2       	rjmp	.+1206   	; 0x1c96 <__data_load_end+0x1394>
    17e0:	5b c1       	rjmp	.+694    	; 0x1a98 <__data_load_end+0x1196>
    17e2:	5b c0       	rjmp	.+182    	; 0x189a <__data_load_end+0xf98>
    17e4:	5b c4       	rjmp	.+2230   	; 0x209c <__data_load_end+0x179a>
    17e6:	5b c5       	rjmp	.+2742   	; 0x229e <__data_load_end+0x199c>
    17e8:	5c 06       	cpc	r5, r28
    17ea:	03 43       	sbci	r16, 0x33	; 51
    17ec:	01 80       	ldd	r0, Z+1	; 0x01
    17ee:	00 9f       	mul	r16, r16
    17f0:	54 2d       	mov	r21, r4
    17f2:	12 00       	.word	0x0012	; ????
    17f4:	00 5e       	subi	r16, 0xE0	; 224
    17f6:	08 00       	.word	0x0008	; ????
    17f8:	00 76       	andi	r16, 0x60	; 96
    17fa:	08 00       	.word	0x0008	; ????
    17fc:	00 0b       	sbc	r16, r16
    17fe:	5f 53       	subi	r21, 0x3F	; 63
    1800:	54 39       	cpi	r21, 0x94	; 148
    1802:	12 00       	.word	0x0012	; ????
    1804:	00 5e       	subi	r16, 0xE0	; 224
    1806:	08 00       	.word	0x0008	; ????
    1808:	00 66       	ori	r16, 0x60	; 96
    180a:	08 00       	.word	0x0008	; ????
    180c:	00 0a       	sbc	r0, r16
    180e:	3f 53       	subi	r19, 0x3F	; 63
    1810:	00 00       	nop
    1812:	00 00       	nop
    1814:	00 55       	subi	r16, 0x50	; 80
    1816:	dc 04       	cpc	r13, r12
    1818:	00 00       	nop
    181a:	03 0e       	add	r0, r19
    181c:	02 08       	sbc	r0, r2
    181e:	04 00       	.word	0x0004	; ????
    1820:	00 55       	subi	r16, 0x50	; 80
    1822:	3f 04       	cpc	r3, r15
    1824:	00 00       	nop
    1826:	03 0e       	add	r0, r19
    1828:	02 59       	subi	r16, 0x92	; 146
    182a:	04 00       	.word	0x0004	; ????
    182c:	00 55       	subi	r16, 0x50	; 80
    182e:	63 04       	cpc	r6, r3
    1830:	00 00       	nop
    1832:	03 56       	subi	r16, 0x63	; 99
    1834:	01 17       	cp	r16, r17
    1836:	08 00       	.word	0x0008	; ????
    1838:	00 04       	cpc	r0, r0
    183a:	3b 01       	movw	r6, r22
    183c:	86 04       	cpc	r8, r6
    183e:	00 00       	nop
    1840:	d2 04       	cpc	r13, r2
    1842:	00 00       	nop
    1844:	c8 09       	sbc	r28, r8
    1846:	00 00       	nop
    1848:	01 72       	andi	r16, 0x21	; 33
    184a:	12 00       	.word	0x0012	; ????
    184c:	00 3d       	cpi	r16, 0xD0	; 208
    184e:	b0 04       	cpc	r11, r0
    1850:	00 00       	nop
    1852:	b3 0b       	sbc	r27, r19
    1854:	00 00       	nop
    1856:	39 06       	cpc	r3, r25
    1858:	68 93       	.word	0x9368	; ????
    185a:	01 69       	ori	r16, 0x91	; 145
    185c:	93 01       	movw	r18, r6
    185e:	05 03       	mulsu	r16, r21
    1860:	43 01       	movw	r8, r6
    1862:	80 00       	.word	0x0080	; ????
    1864:	00 00       	nop
    1866:	56 01       	movw	r10, r12
    1868:	e4 05       	cpc	r30, r4
    186a:	00 00       	nop
    186c:	04 28       	or	r0, r4
    186e:	01 d2       	rcall	.+1026   	; 0x1c72 <__data_load_end+0x1370>
    1870:	04 00       	.word	0x0004	; ????
    1872:	00 36       	cpi	r16, 0x60	; 96
    1874:	05 00       	.word	0x0005	; ????
    1876:	00 93 0a 00 	sts	0x000A, r16	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    187a:	00 01       	movw	r0, r0
    187c:	d5 12       	cpse	r13, r21
    187e:	00 00       	nop
    1880:	5d 4e       	sbci	r21, 0xED	; 237
    1882:	05 00       	.word	0x0005	; ????
    1884:	00 e6       	ldi	r16, 0x60	; 96
    1886:	04 00       	.word	0x0004	; ????
    1888:	00 48       	sbci	r16, 0x80	; 128
    188a:	00 00       	nop
    188c:	00 04       	cpc	r0, r0
    188e:	31 42       	sbci	r19, 0x21	; 33
    1890:	5c 05       	cpc	r21, r12
    1892:	00 00       	nop
    1894:	33 1f       	adc	r19, r19
    1896:	05 00       	.word	0x0005	; ????
    1898:	00 fc       	sbrc	r0, 0
    189a:	04 00       	.word	0x0004	; ????
    189c:	00 1e       	adc	r0, r16
    189e:	05 00       	.word	0x0005	; ????
    18a0:	00 42       	sbci	r16, 0x20	; 32
    18a2:	2f 05       	cpc	r18, r15
    18a4:	00 00       	nop
    18a6:	33 39       	cpi	r19, 0x93	; 147
    18a8:	05 00       	.word	0x0005	; ????
    18aa:	00 fc       	sbrc	r0, 0
    18ac:	04 00       	.word	0x0004	; ????
    18ae:	00 1e       	adc	r0, r16
    18b0:	05 00       	.word	0x0005	; ????
    18b2:	00 2c       	mov	r0, r0
    18b4:	3a 05       	cpc	r19, r10
    18b6:	00 00       	nop
    18b8:	03 0b       	sbc	r16, r19
    18ba:	00 00       	nop
    18bc:	2c 43       	sbci	r18, 0x3C	; 60
    18be:	05 00       	.word	0x0005	; ????
    18c0:	00 16       	cp	r0, r16
    18c2:	0b 00       	.word	0x000b	; ????
    18c4:	00 00       	nop
    18c6:	00 00       	nop
    18c8:	00 1a       	sub	r0, r16
    18ca:	9e 04       	cpc	r9, r14
    18cc:	00 00       	nop
    18ce:	e5 12       	cpse	r14, r21
    18d0:	00 00       	nop
    18d2:	1b 01       	movw	r2, r22
    18d4:	04 00       	.word	0x0004	; ????
    18d6:	00 04       	cpc	r0, r0
    18d8:	00 19       	sub	r16, r0
    18da:	d5 12       	cpse	r13, r21
    18dc:	00 00       	nop
    18de:	3b ed       	ldi	r19, 0xDB	; 219
    18e0:	03 00       	.word	0x0003	; ????
    18e2:	00 13       	cpse	r16, r16
    18e4:	7e e5       	ldi	r23, 0x5E	; 94
    18e6:	12 00       	.word	0x0012	; ????
    18e8:	00 05       	cpc	r16, r0
    18ea:	03 68       	ori	r16, 0x83	; 131
    18ec:	00 00       	nop
    18ee:	00 46       	sbci	r16, 0x60	; 96
    18f0:	61 00       	.word	0x0061	; ????
    18f2:	09 03       	fmul	r16, r17
    18f4:	11 13       	cpse	r17, r17
    18f6:	00 00       	nop
    18f8:	05 03       	mulsu	r16, r21
    18fa:	00 01       	movw	r0, r0
    18fc:	80 00       	.word	0x0080	; ????
    18fe:	0d 02       	muls	r16, r29
    1900:	05 69       	ori	r16, 0x95	; 149
    1902:	6e 74       	andi	r22, 0x4E	; 78
    1904:	00 14       	cp	r0, r0
    1906:	0a 13       	cpse	r16, r26
    1908:	00 00       	nop
    190a:	46 62       	ori	r20, 0x26	; 38
    190c:	00 09       	sbc	r16, r0
    190e:	04 11       	cpse	r16, r4
    1910:	13 00       	.word	0x0013	; ????
    1912:	00 05       	cpc	r16, r0
    1914:	03 02       	muls	r16, r19
    1916:	01 80       	ldd	r0, Z+1	; 0x01
    1918:	00 3b       	cpi	r16, 0xB0	; 176
    191a:	5b 05       	cpc	r21, r11
    191c:	00 00       	nop
    191e:	07 26       	eor	r0, r23
    1920:	3d 13       	cpse	r19, r29
    1922:	00 00       	nop
    1924:	05 03       	mulsu	r16, r21
    1926:	3a 01       	movw	r6, r20
    1928:	80 00       	.word	0x0080	; ????
    192a:	12 04       	cpc	r1, r2
    192c:	07 52       	subi	r16, 0x27	; 39
    192e:	06 00       	.word	0x0006	; ????
    1930:	00 14       	cp	r0, r0
    1932:	36 13       	cpse	r19, r22
    1934:	00 00       	nop
    1936:	3b 5b       	subi	r19, 0xBB	; 187
    1938:	02 00       	.word	0x0002	; ????
    193a:	00 07       	cpc	r16, r16
    193c:	28 96       	adiw	r28, 0x08	; 8
    193e:	01 00       	.word	0x0001	; ????
    1940:	00 05       	cpc	r16, r0
    1942:	03 3e       	cpi	r16, 0xE3	; 227
    1944:	01 80       	ldd	r0, Z+1	; 0x01
    1946:	00 3b       	cpi	r16, 0xB0	; 176
    1948:	c6 03       	fmuls	r20, r22
    194a:	00 00       	nop
    194c:	07 27       	eor	r16, r23
    194e:	3d 13       	cpse	r19, r29
    1950:	00 00       	nop
    1952:	05 03       	mulsu	r16, r21
    1954:	3f 01       	movw	r6, r30
    1956:	80 00       	.word	0x0080	; ????
    1958:	3b 15       	cp	r19, r11
    195a:	05 00       	.word	0x0005	; ????
    195c:	00 13       	cpse	r16, r16
    195e:	86 e5       	ldi	r24, 0x56	; 86
    1960:	12 00       	.word	0x0012	; ????
    1962:	00 05       	cpc	r16, r0
    1964:	03 72       	andi	r16, 0x23	; 35
    1966:	00 00       	nop
    1968:	00 1a       	sub	r0, r16
    196a:	e3 09       	sbc	r30, r3
    196c:	00 00       	nop
    196e:	85 13       	cpse	r24, r21
    1970:	00 00       	nop
    1972:	1b 01       	movw	r2, r22
    1974:	04 00       	.word	0x0004	; ????
    1976:	00 13       	cpse	r16, r16
    1978:	00 19       	sub	r16, r0
    197a:	75 13       	cpse	r23, r21
    197c:	00 00       	nop
    197e:	3b 64       	ori	r19, 0x4B	; 75
    1980:	06 00       	.word	0x0006	; ????
    1982:	00 13       	cpse	r16, r16
    1984:	96 85       	ldd	r25, Z+14	; 0x0e
    1986:	13 00       	.word	0x0013	; ????
    1988:	00 05       	cpc	r16, r0
    198a:	03 7c       	andi	r16, 0xC3	; 195
    198c:	00 00       	nop
    198e:	00 3b       	cpi	r16, 0xB0	; 176
    1990:	ee 07       	cpc	r30, r30
    1992:	00 00       	nop
    1994:	13 ad       	ldd	r17, Z+59	; 0x3b
    1996:	85 13       	cpse	r24, r21
    1998:	00 00       	nop
    199a:	05 03       	mulsu	r16, r21
    199c:	90 00       	.word	0x0090	; ????
    199e:	00 00       	nop
    19a0:	3b 1c       	adc	r3, r11
    19a2:	03 00       	.word	0x0003	; ????
    19a4:	00 13       	cpse	r16, r16
    19a6:	c4 85       	ldd	r28, Z+12	; 0x0c
    19a8:	13 00       	.word	0x0013	; ????
    19aa:	00 05       	cpc	r16, r0
    19ac:	03 a4       	ldd	r0, Z+43	; 0x2b
    19ae:	00 00       	nop
    19b0:	00 3b       	cpi	r16, 0xB0	; 176
    19b2:	03 06       	cpc	r0, r19
    19b4:	00 00       	nop
    19b6:	04 46       	sbci	r16, 0x64	; 100
    19b8:	a3 04       	cpc	r10, r3
    19ba:	00 00       	nop
    19bc:	05 03       	mulsu	r16, r21
    19be:	43 01       	movw	r8, r6
    19c0:	80 00       	.word	0x0080	; ????
    19c2:	00 b7       	in	r16, 0x30	; 48
    19c4:	00 00       	nop
    19c6:	00 02       	muls	r16, r16
    19c8:	00 a2       	std	Z+32, r0	; 0x20
    19ca:	0a 00       	.word	0x000a	; ????
    19cc:	00 04       	cpc	r0, r0
    19ce:	01 e1       	ldi	r16, 0x11	; 17
    19d0:	07 00       	.word	0x0007	; ????
    19d2:	00 c4       	rjmp	.+2048   	; 0x21d4 <__data_load_end+0x18d2>
    19d4:	08 00       	.word	0x0008	; ????
    19d6:	00 c8       	rjmp	.-4096   	; 0x9d8 <__data_load_end+0xd6>
    19d8:	08 00       	.word	0x0008	; ????
    19da:	00 2e       	mov	r0, r16
    19dc:	2e 2f       	mov	r18, r30
    19de:	2e 2e       	mov	r2, r30
    19e0:	2f 2e       	mov	r2, r31
    19e2:	2e 2f       	mov	r18, r30
    19e4:	2e 2e       	mov	r2, r30
    19e6:	2f 67       	ori	r18, 0x7F	; 127
    19e8:	63 63       	ori	r22, 0x33	; 51
    19ea:	2f 6c       	ori	r18, 0xCF	; 207
    19ec:	69 62       	ori	r22, 0x29	; 41
    19ee:	67 63       	ori	r22, 0x37	; 55
    19f0:	63 2f       	mov	r22, r19
    19f2:	63 6f       	ori	r22, 0xF3	; 243
    19f4:	6e 66       	ori	r22, 0x6E	; 110
    19f6:	69 67       	ori	r22, 0x79	; 121
    19f8:	2f 61       	ori	r18, 0x1F	; 31
    19fa:	76 72       	andi	r23, 0x26	; 38
    19fc:	2f 6c       	ori	r18, 0xCF	; 207
    19fe:	69 62       	ori	r22, 0x29	; 41
    1a00:	31 66       	ori	r19, 0x61	; 97
    1a02:	75 6e       	ori	r23, 0xE5	; 229
    1a04:	63 73       	andi	r22, 0x33	; 51
    1a06:	2e 53       	subi	r18, 0x3E	; 62
    1a08:	00 2f       	mov	r16, r16
    1a0a:	68 6f       	ori	r22, 0xF8	; 248
    1a0c:	6d 65       	ori	r22, 0x5D	; 93
    1a0e:	2f 6a       	ori	r18, 0xAF	; 175
    1a10:	65 6e       	ori	r22, 0xE5	; 229
    1a12:	6b 69       	ori	r22, 0x9B	; 155
    1a14:	6e 73       	andi	r22, 0x3E	; 62
    1a16:	2d 6d       	ori	r18, 0xDD	; 221
    1a18:	69 6e       	ori	r22, 0xE9	; 233
    1a1a:	67 77       	andi	r22, 0x77	; 119
    1a1c:	33 32       	cpi	r19, 0x23	; 35
    1a1e:	2f 77       	andi	r18, 0x7F	; 127
    1a20:	6f 72       	andi	r22, 0x2F	; 47
    1a22:	6b 73       	andi	r22, 0x3B	; 59
    1a24:	70 61       	ori	r23, 0x10	; 16
    1a26:	63 65       	ori	r22, 0x53	; 83
    1a28:	2f 61       	ori	r18, 0x1F	; 31
    1a2a:	76 72       	andi	r23, 0x26	; 38
    1a2c:	2d 67       	ori	r18, 0x7D	; 125
    1a2e:	63 63       	ori	r22, 0x33	; 51
    1a30:	2d 73       	andi	r18, 0x3D	; 61
    1a32:	74 61       	ori	r23, 0x14	; 20
    1a34:	67 69       	ori	r22, 0x97	; 151
    1a36:	6e 67       	ori	r22, 0x7E	; 126
    1a38:	2f 6c       	ori	r18, 0xCF	; 207
    1a3a:	61 62       	ori	r22, 0x21	; 33
    1a3c:	65 6c       	ori	r22, 0xC5	; 197
    1a3e:	2f 55       	subi	r18, 0x5F	; 95
    1a40:	62 75       	andi	r22, 0x52	; 82
    1a42:	6e 74       	andi	r22, 0x4E	; 78
    1a44:	75 31       	cpi	r23, 0x15	; 21
    1a46:	34 2e       	mov	r3, r20
    1a48:	30 34       	cpi	r19, 0x40	; 64
    1a4a:	78 36       	cpi	r23, 0x68	; 104
    1a4c:	34 2d       	mov	r19, r4
    1a4e:	6d 69       	ori	r22, 0x9D	; 157
    1a50:	6e 67       	ori	r22, 0x7E	; 126
    1a52:	77 33       	cpi	r23, 0x37	; 55
    1a54:	32 2f       	mov	r19, r18
    1a56:	67 63       	ori	r22, 0x37	; 55
    1a58:	63 2d       	mov	r22, r3
    1a5a:	62 75       	andi	r22, 0x52	; 82
    1a5c:	69 6c       	ori	r22, 0xC9	; 201
    1a5e:	64 2f       	mov	r22, r20
    1a60:	61 76       	andi	r22, 0x61	; 97
    1a62:	72 2f       	mov	r23, r18
    1a64:	61 76       	andi	r22, 0x61	; 97
    1a66:	72 35       	cpi	r23, 0x52	; 82
    1a68:	2f 6c       	ori	r18, 0xCF	; 207
    1a6a:	69 62       	ori	r22, 0x29	; 41
    1a6c:	67 63       	ori	r22, 0x37	; 55
    1a6e:	63 00       	.word	0x0063	; ????
    1a70:	47 4e       	sbci	r20, 0xE7	; 231
    1a72:	55 20       	and	r5, r5
    1a74:	41 53       	subi	r20, 0x31	; 49
    1a76:	20 32       	cpi	r18, 0x20	; 32
    1a78:	2e 32       	cpi	r18, 0x2E	; 46
    1a7a:	36 00       	.word	0x0036	; ????
    1a7c:	01 80       	ldd	r0, Z+1	; 0x01
    1a7e:	b7 00       	.word	0x00b7	; ????
    1a80:	00 00       	nop
    1a82:	02 00       	.word	0x0002	; ????
    1a84:	b6 0a       	sbc	r11, r22
    1a86:	00 00       	nop
    1a88:	04 01       	movw	r0, r8
    1a8a:	43 08       	sbc	r4, r3
    1a8c:	00 00       	nop
    1a8e:	c6 00       	.word	0x00c6	; ????
    1a90:	00 00       	nop
    1a92:	dc 00       	.word	0x00dc	; ????
    1a94:	00 00       	nop
    1a96:	2e 2e       	mov	r2, r30
    1a98:	2f 2e       	mov	r2, r31
    1a9a:	2e 2f       	mov	r18, r30
    1a9c:	2e 2e       	mov	r2, r30
    1a9e:	2f 2e       	mov	r2, r31
    1aa0:	2e 2f       	mov	r18, r30
    1aa2:	67 63       	ori	r22, 0x37	; 55
    1aa4:	63 2f       	mov	r22, r19
    1aa6:	6c 69       	ori	r22, 0x9C	; 156
    1aa8:	62 67       	ori	r22, 0x72	; 114
    1aaa:	63 63       	ori	r22, 0x33	; 51
    1aac:	2f 63       	ori	r18, 0x3F	; 63
    1aae:	6f 6e       	ori	r22, 0xEF	; 239
    1ab0:	66 69       	ori	r22, 0x96	; 150
    1ab2:	67 2f       	mov	r22, r23
    1ab4:	61 76       	andi	r22, 0x61	; 97
    1ab6:	72 2f       	mov	r23, r18
    1ab8:	6c 69       	ori	r22, 0x9C	; 156
    1aba:	62 31       	cpi	r22, 0x12	; 18
    1abc:	66 75       	andi	r22, 0x56	; 86
    1abe:	6e 63       	ori	r22, 0x3E	; 62
    1ac0:	73 2e       	mov	r7, r19
    1ac2:	53 00       	.word	0x0053	; ????
    1ac4:	2f 68       	ori	r18, 0x8F	; 143
    1ac6:	6f 6d       	ori	r22, 0xDF	; 223
    1ac8:	65 2f       	mov	r22, r21
    1aca:	6a 65       	ori	r22, 0x5A	; 90
    1acc:	6e 6b       	ori	r22, 0xBE	; 190
    1ace:	69 6e       	ori	r22, 0xE9	; 233
    1ad0:	73 2d       	mov	r23, r3
    1ad2:	6d 69       	ori	r22, 0x9D	; 157
    1ad4:	6e 67       	ori	r22, 0x7E	; 126
    1ad6:	77 33       	cpi	r23, 0x37	; 55
    1ad8:	32 2f       	mov	r19, r18
    1ada:	77 6f       	ori	r23, 0xF7	; 247
    1adc:	72 6b       	ori	r23, 0xB2	; 178
    1ade:	73 70       	andi	r23, 0x03	; 3
    1ae0:	61 63       	ori	r22, 0x31	; 49
    1ae2:	65 2f       	mov	r22, r21
    1ae4:	61 76       	andi	r22, 0x61	; 97
    1ae6:	72 2d       	mov	r23, r2
    1ae8:	67 63       	ori	r22, 0x37	; 55
    1aea:	63 2d       	mov	r22, r3
    1aec:	73 74       	andi	r23, 0x43	; 67
    1aee:	61 67       	ori	r22, 0x71	; 113
    1af0:	69 6e       	ori	r22, 0xE9	; 233
    1af2:	67 2f       	mov	r22, r23
    1af4:	6c 61       	ori	r22, 0x1C	; 28
    1af6:	62 65       	ori	r22, 0x52	; 82
    1af8:	6c 2f       	mov	r22, r28
    1afa:	55 62       	ori	r21, 0x25	; 37
    1afc:	75 6e       	ori	r23, 0xE5	; 229
    1afe:	74 75       	andi	r23, 0x54	; 84
    1b00:	31 34       	cpi	r19, 0x41	; 65
    1b02:	2e 30       	cpi	r18, 0x0E	; 14
    1b04:	34 78       	andi	r19, 0x84	; 132
    1b06:	36 34       	cpi	r19, 0x46	; 70
    1b08:	2d 6d       	ori	r18, 0xDD	; 221
    1b0a:	69 6e       	ori	r22, 0xE9	; 233
    1b0c:	67 77       	andi	r22, 0x77	; 119
    1b0e:	33 32       	cpi	r19, 0x23	; 35
    1b10:	2f 67       	ori	r18, 0x7F	; 127
    1b12:	63 63       	ori	r22, 0x33	; 51
    1b14:	2d 62       	ori	r18, 0x2D	; 45
    1b16:	75 69       	ori	r23, 0x95	; 149
    1b18:	6c 64       	ori	r22, 0x4C	; 76
    1b1a:	2f 61       	ori	r18, 0x1F	; 31
    1b1c:	76 72       	andi	r23, 0x26	; 38
    1b1e:	2f 61       	ori	r18, 0x1F	; 31
    1b20:	76 72       	andi	r23, 0x26	; 38
    1b22:	35 2f       	mov	r19, r21
    1b24:	6c 69       	ori	r22, 0x9C	; 156
    1b26:	62 67       	ori	r22, 0x72	; 114
    1b28:	63 63       	ori	r22, 0x33	; 51
    1b2a:	00 47       	sbci	r16, 0x70	; 112
    1b2c:	4e 55       	subi	r20, 0x5E	; 94
    1b2e:	20 41       	sbci	r18, 0x10	; 16
    1b30:	53 20       	and	r5, r3
    1b32:	32 2e       	mov	r3, r18
    1b34:	32 36       	cpi	r19, 0x62	; 98
    1b36:	00 01       	movw	r0, r0
    1b38:	80 b7       	in	r24, 0x30	; 48
    1b3a:	00 00       	nop
    1b3c:	00 02       	muls	r16, r16
    1b3e:	00 ca       	rjmp	.-3072   	; 0xf40 <__data_load_end+0x63e>
    1b40:	0a 00       	.word	0x000a	; ????
    1b42:	00 04       	cpc	r0, r0
    1b44:	01 db       	rcall	.-2558   	; 0x1148 <__data_load_end+0x846>
    1b46:	08 00       	.word	0x0008	; ????
    1b48:	00 dc       	rcall	.-2048   	; 0x134a <__data_load_end+0xa48>
    1b4a:	00 00       	nop
    1b4c:	00 ec       	ldi	r16, 0xC0	; 192
    1b4e:	00 00       	nop
    1b50:	00 2e       	mov	r0, r16
    1b52:	2e 2f       	mov	r18, r30
    1b54:	2e 2e       	mov	r2, r30
    1b56:	2f 2e       	mov	r2, r31
    1b58:	2e 2f       	mov	r18, r30
    1b5a:	2e 2e       	mov	r2, r30
    1b5c:	2f 67       	ori	r18, 0x7F	; 127
    1b5e:	63 63       	ori	r22, 0x33	; 51
    1b60:	2f 6c       	ori	r18, 0xCF	; 207
    1b62:	69 62       	ori	r22, 0x29	; 41
    1b64:	67 63       	ori	r22, 0x37	; 55
    1b66:	63 2f       	mov	r22, r19
    1b68:	63 6f       	ori	r22, 0xF3	; 243
    1b6a:	6e 66       	ori	r22, 0x6E	; 110
    1b6c:	69 67       	ori	r22, 0x79	; 121
    1b6e:	2f 61       	ori	r18, 0x1F	; 31
    1b70:	76 72       	andi	r23, 0x26	; 38
    1b72:	2f 6c       	ori	r18, 0xCF	; 207
    1b74:	69 62       	ori	r22, 0x29	; 41
    1b76:	31 66       	ori	r19, 0x61	; 97
    1b78:	75 6e       	ori	r23, 0xE5	; 229
    1b7a:	63 73       	andi	r22, 0x33	; 51
    1b7c:	2e 53       	subi	r18, 0x3E	; 62
    1b7e:	00 2f       	mov	r16, r16
    1b80:	68 6f       	ori	r22, 0xF8	; 248
    1b82:	6d 65       	ori	r22, 0x5D	; 93
    1b84:	2f 6a       	ori	r18, 0xAF	; 175
    1b86:	65 6e       	ori	r22, 0xE5	; 229
    1b88:	6b 69       	ori	r22, 0x9B	; 155
    1b8a:	6e 73       	andi	r22, 0x3E	; 62
    1b8c:	2d 6d       	ori	r18, 0xDD	; 221
    1b8e:	69 6e       	ori	r22, 0xE9	; 233
    1b90:	67 77       	andi	r22, 0x77	; 119
    1b92:	33 32       	cpi	r19, 0x23	; 35
    1b94:	2f 77       	andi	r18, 0x7F	; 127
    1b96:	6f 72       	andi	r22, 0x2F	; 47
    1b98:	6b 73       	andi	r22, 0x3B	; 59
    1b9a:	70 61       	ori	r23, 0x10	; 16
    1b9c:	63 65       	ori	r22, 0x53	; 83
    1b9e:	2f 61       	ori	r18, 0x1F	; 31
    1ba0:	76 72       	andi	r23, 0x26	; 38
    1ba2:	2d 67       	ori	r18, 0x7D	; 125
    1ba4:	63 63       	ori	r22, 0x33	; 51
    1ba6:	2d 73       	andi	r18, 0x3D	; 61
    1ba8:	74 61       	ori	r23, 0x14	; 20
    1baa:	67 69       	ori	r22, 0x97	; 151
    1bac:	6e 67       	ori	r22, 0x7E	; 126
    1bae:	2f 6c       	ori	r18, 0xCF	; 207
    1bb0:	61 62       	ori	r22, 0x21	; 33
    1bb2:	65 6c       	ori	r22, 0xC5	; 197
    1bb4:	2f 55       	subi	r18, 0x5F	; 95
    1bb6:	62 75       	andi	r22, 0x52	; 82
    1bb8:	6e 74       	andi	r22, 0x4E	; 78
    1bba:	75 31       	cpi	r23, 0x15	; 21
    1bbc:	34 2e       	mov	r3, r20
    1bbe:	30 34       	cpi	r19, 0x40	; 64
    1bc0:	78 36       	cpi	r23, 0x68	; 104
    1bc2:	34 2d       	mov	r19, r4
    1bc4:	6d 69       	ori	r22, 0x9D	; 157
    1bc6:	6e 67       	ori	r22, 0x7E	; 126
    1bc8:	77 33       	cpi	r23, 0x37	; 55
    1bca:	32 2f       	mov	r19, r18
    1bcc:	67 63       	ori	r22, 0x37	; 55
    1bce:	63 2d       	mov	r22, r3
    1bd0:	62 75       	andi	r22, 0x52	; 82
    1bd2:	69 6c       	ori	r22, 0xC9	; 201
    1bd4:	64 2f       	mov	r22, r20
    1bd6:	61 76       	andi	r22, 0x61	; 97
    1bd8:	72 2f       	mov	r23, r18
    1bda:	61 76       	andi	r22, 0x61	; 97
    1bdc:	72 35       	cpi	r23, 0x52	; 82
    1bde:	2f 6c       	ori	r18, 0xCF	; 207
    1be0:	69 62       	ori	r22, 0x29	; 41
    1be2:	67 63       	ori	r22, 0x37	; 55
    1be4:	63 00       	.word	0x0063	; ????
    1be6:	47 4e       	sbci	r20, 0xE7	; 231
    1be8:	55 20       	and	r5, r5
    1bea:	41 53       	subi	r20, 0x31	; 49
    1bec:	20 32       	cpi	r18, 0x20	; 32
    1bee:	2e 32       	cpi	r18, 0x2E	; 46
    1bf0:	36 00       	.word	0x0036	; ????
    1bf2:	01 80       	ldd	r0, Z+1	; 0x01
    1bf4:	b7 00       	.word	0x00b7	; ????
    1bf6:	00 00       	nop
    1bf8:	02 00       	.word	0x0002	; ????
    1bfa:	de 0a       	sbc	r13, r30
    1bfc:	00 00       	nop
    1bfe:	04 01       	movw	r0, r8
    1c00:	61 09       	sbc	r22, r1
    1c02:	00 00       	nop
    1c04:	ec 00       	.word	0x00ec	; ????
    1c06:	00 00       	nop
    1c08:	02 01       	movw	r0, r4
    1c0a:	00 00       	nop
    1c0c:	2e 2e       	mov	r2, r30
    1c0e:	2f 2e       	mov	r2, r31
    1c10:	2e 2f       	mov	r18, r30
    1c12:	2e 2e       	mov	r2, r30
    1c14:	2f 2e       	mov	r2, r31
    1c16:	2e 2f       	mov	r18, r30
    1c18:	67 63       	ori	r22, 0x37	; 55
    1c1a:	63 2f       	mov	r22, r19
    1c1c:	6c 69       	ori	r22, 0x9C	; 156
    1c1e:	62 67       	ori	r22, 0x72	; 114
    1c20:	63 63       	ori	r22, 0x33	; 51
    1c22:	2f 63       	ori	r18, 0x3F	; 63
    1c24:	6f 6e       	ori	r22, 0xEF	; 239
    1c26:	66 69       	ori	r22, 0x96	; 150
    1c28:	67 2f       	mov	r22, r23
    1c2a:	61 76       	andi	r22, 0x61	; 97
    1c2c:	72 2f       	mov	r23, r18
    1c2e:	6c 69       	ori	r22, 0x9C	; 156
    1c30:	62 31       	cpi	r22, 0x12	; 18
    1c32:	66 75       	andi	r22, 0x56	; 86
    1c34:	6e 63       	ori	r22, 0x3E	; 62
    1c36:	73 2e       	mov	r7, r19
    1c38:	53 00       	.word	0x0053	; ????
    1c3a:	2f 68       	ori	r18, 0x8F	; 143
    1c3c:	6f 6d       	ori	r22, 0xDF	; 223
    1c3e:	65 2f       	mov	r22, r21
    1c40:	6a 65       	ori	r22, 0x5A	; 90
    1c42:	6e 6b       	ori	r22, 0xBE	; 190
    1c44:	69 6e       	ori	r22, 0xE9	; 233
    1c46:	73 2d       	mov	r23, r3
    1c48:	6d 69       	ori	r22, 0x9D	; 157
    1c4a:	6e 67       	ori	r22, 0x7E	; 126
    1c4c:	77 33       	cpi	r23, 0x37	; 55
    1c4e:	32 2f       	mov	r19, r18
    1c50:	77 6f       	ori	r23, 0xF7	; 247
    1c52:	72 6b       	ori	r23, 0xB2	; 178
    1c54:	73 70       	andi	r23, 0x03	; 3
    1c56:	61 63       	ori	r22, 0x31	; 49
    1c58:	65 2f       	mov	r22, r21
    1c5a:	61 76       	andi	r22, 0x61	; 97
    1c5c:	72 2d       	mov	r23, r2
    1c5e:	67 63       	ori	r22, 0x37	; 55
    1c60:	63 2d       	mov	r22, r3
    1c62:	73 74       	andi	r23, 0x43	; 67
    1c64:	61 67       	ori	r22, 0x71	; 113
    1c66:	69 6e       	ori	r22, 0xE9	; 233
    1c68:	67 2f       	mov	r22, r23
    1c6a:	6c 61       	ori	r22, 0x1C	; 28
    1c6c:	62 65       	ori	r22, 0x52	; 82
    1c6e:	6c 2f       	mov	r22, r28
    1c70:	55 62       	ori	r21, 0x25	; 37
    1c72:	75 6e       	ori	r23, 0xE5	; 229
    1c74:	74 75       	andi	r23, 0x54	; 84
    1c76:	31 34       	cpi	r19, 0x41	; 65
    1c78:	2e 30       	cpi	r18, 0x0E	; 14
    1c7a:	34 78       	andi	r19, 0x84	; 132
    1c7c:	36 34       	cpi	r19, 0x46	; 70
    1c7e:	2d 6d       	ori	r18, 0xDD	; 221
    1c80:	69 6e       	ori	r22, 0xE9	; 233
    1c82:	67 77       	andi	r22, 0x77	; 119
    1c84:	33 32       	cpi	r19, 0x23	; 35
    1c86:	2f 67       	ori	r18, 0x7F	; 127
    1c88:	63 63       	ori	r22, 0x33	; 51
    1c8a:	2d 62       	ori	r18, 0x2D	; 45
    1c8c:	75 69       	ori	r23, 0x95	; 149
    1c8e:	6c 64       	ori	r22, 0x4C	; 76
    1c90:	2f 61       	ori	r18, 0x1F	; 31
    1c92:	76 72       	andi	r23, 0x26	; 38
    1c94:	2f 61       	ori	r18, 0x1F	; 31
    1c96:	76 72       	andi	r23, 0x26	; 38
    1c98:	35 2f       	mov	r19, r21
    1c9a:	6c 69       	ori	r22, 0x9C	; 156
    1c9c:	62 67       	ori	r22, 0x72	; 114
    1c9e:	63 63       	ori	r22, 0x33	; 51
    1ca0:	00 47       	sbci	r16, 0x70	; 112
    1ca2:	4e 55       	subi	r20, 0x5E	; 94
    1ca4:	20 41       	sbci	r18, 0x10	; 16
    1ca6:	53 20       	and	r5, r3
    1ca8:	32 2e       	mov	r3, r18
    1caa:	32 36       	cpi	r19, 0x62	; 98
    1cac:	00 01       	movw	r0, r0
    1cae:	80 b7       	in	r24, 0x30	; 48
    1cb0:	00 00       	nop
    1cb2:	00 02       	muls	r16, r16
    1cb4:	00 f2       	brcs	.-128    	; 0x1c36 <__data_load_end+0x1334>
    1cb6:	0a 00       	.word	0x000a	; ????
    1cb8:	00 04       	cpc	r0, r0
    1cba:	01 f3       	breq	.-64     	; 0x1c7c <__data_load_end+0x137a>
    1cbc:	09 00       	.word	0x0009	; ????
    1cbe:	00 b8       	out	0x00, r0	; 0
    1cc0:	08 00       	.word	0x0008	; ????
    1cc2:	00 c4       	rjmp	.+2048   	; 0x24c4 <__data_load_end+0x1bc2>
    1cc4:	08 00       	.word	0x0008	; ????
    1cc6:	00 2e       	mov	r0, r16
    1cc8:	2e 2f       	mov	r18, r30
    1cca:	2e 2e       	mov	r2, r30
    1ccc:	2f 2e       	mov	r2, r31
    1cce:	2e 2f       	mov	r18, r30
    1cd0:	2e 2e       	mov	r2, r30
    1cd2:	2f 67       	ori	r18, 0x7F	; 127
    1cd4:	63 63       	ori	r22, 0x33	; 51
    1cd6:	2f 6c       	ori	r18, 0xCF	; 207
    1cd8:	69 62       	ori	r22, 0x29	; 41
    1cda:	67 63       	ori	r22, 0x37	; 55
    1cdc:	63 2f       	mov	r22, r19
    1cde:	63 6f       	ori	r22, 0xF3	; 243
    1ce0:	6e 66       	ori	r22, 0x6E	; 110
    1ce2:	69 67       	ori	r22, 0x79	; 121
    1ce4:	2f 61       	ori	r18, 0x1F	; 31
    1ce6:	76 72       	andi	r23, 0x26	; 38
    1ce8:	2f 6c       	ori	r18, 0xCF	; 207
    1cea:	69 62       	ori	r22, 0x29	; 41
    1cec:	31 66       	ori	r19, 0x61	; 97
    1cee:	75 6e       	ori	r23, 0xE5	; 229
    1cf0:	63 73       	andi	r22, 0x33	; 51
    1cf2:	2e 53       	subi	r18, 0x3E	; 62
    1cf4:	00 2f       	mov	r16, r16
    1cf6:	68 6f       	ori	r22, 0xF8	; 248
    1cf8:	6d 65       	ori	r22, 0x5D	; 93
    1cfa:	2f 6a       	ori	r18, 0xAF	; 175
    1cfc:	65 6e       	ori	r22, 0xE5	; 229
    1cfe:	6b 69       	ori	r22, 0x9B	; 155
    1d00:	6e 73       	andi	r22, 0x3E	; 62
    1d02:	2d 6d       	ori	r18, 0xDD	; 221
    1d04:	69 6e       	ori	r22, 0xE9	; 233
    1d06:	67 77       	andi	r22, 0x77	; 119
    1d08:	33 32       	cpi	r19, 0x23	; 35
    1d0a:	2f 77       	andi	r18, 0x7F	; 127
    1d0c:	6f 72       	andi	r22, 0x2F	; 47
    1d0e:	6b 73       	andi	r22, 0x3B	; 59
    1d10:	70 61       	ori	r23, 0x10	; 16
    1d12:	63 65       	ori	r22, 0x53	; 83
    1d14:	2f 61       	ori	r18, 0x1F	; 31
    1d16:	76 72       	andi	r23, 0x26	; 38
    1d18:	2d 67       	ori	r18, 0x7D	; 125
    1d1a:	63 63       	ori	r22, 0x33	; 51
    1d1c:	2d 73       	andi	r18, 0x3D	; 61
    1d1e:	74 61       	ori	r23, 0x14	; 20
    1d20:	67 69       	ori	r22, 0x97	; 151
    1d22:	6e 67       	ori	r22, 0x7E	; 126
    1d24:	2f 6c       	ori	r18, 0xCF	; 207
    1d26:	61 62       	ori	r22, 0x21	; 33
    1d28:	65 6c       	ori	r22, 0xC5	; 197
    1d2a:	2f 55       	subi	r18, 0x5F	; 95
    1d2c:	62 75       	andi	r22, 0x52	; 82
    1d2e:	6e 74       	andi	r22, 0x4E	; 78
    1d30:	75 31       	cpi	r23, 0x15	; 21
    1d32:	34 2e       	mov	r3, r20
    1d34:	30 34       	cpi	r19, 0x40	; 64
    1d36:	78 36       	cpi	r23, 0x68	; 104
    1d38:	34 2d       	mov	r19, r4
    1d3a:	6d 69       	ori	r22, 0x9D	; 157
    1d3c:	6e 67       	ori	r22, 0x7E	; 126
    1d3e:	77 33       	cpi	r23, 0x37	; 55
    1d40:	32 2f       	mov	r19, r18
    1d42:	67 63       	ori	r22, 0x37	; 55
    1d44:	63 2d       	mov	r22, r3
    1d46:	62 75       	andi	r22, 0x52	; 82
    1d48:	69 6c       	ori	r22, 0xC9	; 201
    1d4a:	64 2f       	mov	r22, r20
    1d4c:	61 76       	andi	r22, 0x61	; 97
    1d4e:	72 2f       	mov	r23, r18
    1d50:	61 76       	andi	r22, 0x61	; 97
    1d52:	72 35       	cpi	r23, 0x52	; 82
    1d54:	2f 6c       	ori	r18, 0xCF	; 207
    1d56:	69 62       	ori	r22, 0x29	; 41
    1d58:	67 63       	ori	r22, 0x37	; 55
    1d5a:	63 00       	.word	0x0063	; ????
    1d5c:	47 4e       	sbci	r20, 0xE7	; 231
    1d5e:	55 20       	and	r5, r5
    1d60:	41 53       	subi	r20, 0x31	; 49
    1d62:	20 32       	cpi	r18, 0x20	; 32
    1d64:	2e 32       	cpi	r18, 0x2E	; 46
    1d66:	36 00       	.word	0x0036	; ????
    1d68:	01 80       	ldd	r0, Z+1	; 0x01

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	01 11       	cpse	r16, r1
   2:	01 25       	eor	r16, r1
   4:	0e 10       	cpse	r0, r14
   6:	06 00       	.word	0x0006	; ????
   8:	00 02       	muls	r16, r16
   a:	24 00       	.word	0x0024	; ????
   c:	03 0e       	add	r0, r19
   e:	0b 0b       	sbc	r16, r27
  10:	3e 0b       	sbc	r19, r30
  12:	00 00       	nop
  14:	03 24       	eor	r0, r3
  16:	00 03       	mulsu	r16, r16
  18:	0e 0b       	sbc	r16, r30
  1a:	0b 3e       	cpi	r16, 0xEB	; 235
  1c:	0b 00       	.word	0x000b	; ????
  1e:	00 04       	cpc	r0, r0
  20:	01 01       	movw	r0, r2
  22:	49 13       	cpse	r20, r25
  24:	00 00       	nop
  26:	05 21       	and	r16, r5
  28:	00 49       	sbci	r16, 0x90	; 144
  2a:	13 2f       	mov	r17, r19
  2c:	05 00       	.word	0x0005	; ????
  2e:	00 06       	cpc	r0, r16
  30:	34 00       	.word	0x0034	; ????
  32:	03 0e       	add	r0, r19
  34:	3a 0b       	sbc	r19, r26
  36:	3b 0b       	sbc	r19, r27
  38:	49 13       	cpse	r20, r25
  3a:	3f 0c       	add	r3, r15
  3c:	02 0a       	sbc	r0, r18
  3e:	00 00       	nop
  40:	07 34       	cpi	r16, 0x47	; 71
  42:	00 03       	mulsu	r16, r16
  44:	0e 3a       	cpi	r16, 0xAE	; 174
  46:	0b 3b       	cpi	r16, 0xBB	; 187
  48:	0b 49       	sbci	r16, 0x9B	; 155
  4a:	13 3f       	cpi	r17, 0xF3	; 243
  4c:	0c 02       	muls	r16, r28
  4e:	0a 00       	.word	0x000a	; ????
  50:	00 08       	sbc	r0, r0
  52:	34 00       	.word	0x0034	; ????
  54:	03 0e       	add	r0, r19
  56:	3a 0b       	sbc	r19, r26
  58:	3b 0b       	sbc	r19, r27
  5a:	49 13       	cpse	r20, r25
  5c:	3f 0c       	add	r3, r15
  5e:	02 0a       	sbc	r0, r18
  60:	00 00       	nop
  62:	09 34       	cpi	r16, 0x49	; 73
  64:	00 03       	mulsu	r16, r16
  66:	0e 3a       	cpi	r16, 0xAE	; 174
  68:	0b 3b       	cpi	r16, 0xBB	; 187
  6a:	0b 49       	sbci	r16, 0x9B	; 155
  6c:	13 3f       	cpi	r17, 0xF3	; 243
  6e:	0c 02       	muls	r16, r28
  70:	0a 00       	.word	0x000a	; ????
  72:	00 0a       	sbc	r0, r16
  74:	34 00       	.word	0x0034	; ????
  76:	03 0e       	add	r0, r19
  78:	3a 0b       	sbc	r19, r26
  7a:	3b 0b       	sbc	r19, r27
  7c:	49 13       	cpse	r20, r25
  7e:	3f 0c       	add	r3, r15
  80:	02 0a       	sbc	r0, r18
  82:	00 00       	nop
  84:	0b 34       	cpi	r16, 0x4B	; 75
  86:	00 03       	mulsu	r16, r16
  88:	0e 3a       	cpi	r16, 0xAE	; 174
  8a:	0b 3b       	cpi	r16, 0xBB	; 187
  8c:	0b 49       	sbci	r16, 0x9B	; 155
  8e:	13 3f       	cpi	r17, 0xF3	; 243
  90:	0c 02       	muls	r16, r28
  92:	0a 00       	.word	0x000a	; ????
  94:	00 0c       	add	r0, r0
  96:	34 00       	.word	0x0034	; ????
  98:	03 0e       	add	r0, r19
  9a:	3a 0b       	sbc	r19, r26
  9c:	3b 0b       	sbc	r19, r27
  9e:	49 13       	cpse	r20, r25
  a0:	3f 0c       	add	r3, r15
  a2:	02 0a       	sbc	r0, r18
  a4:	00 00       	nop
  a6:	0d 34       	cpi	r16, 0x4D	; 77
  a8:	00 03       	mulsu	r16, r16
  aa:	0e 3a       	cpi	r16, 0xAE	; 174
  ac:	0b 3b       	cpi	r16, 0xBB	; 187
  ae:	0b 49       	sbci	r16, 0x9B	; 155
  b0:	13 3f       	cpi	r17, 0xF3	; 243
  b2:	0c 02       	muls	r16, r28
  b4:	0a 00       	.word	0x000a	; ????
  b6:	00 0e       	add	r0, r16
  b8:	34 00       	.word	0x0034	; ????
  ba:	03 0e       	add	r0, r19
  bc:	3a 0b       	sbc	r19, r26
  be:	3b 0b       	sbc	r19, r27
  c0:	49 13       	cpse	r20, r25
  c2:	3f 0c       	add	r3, r15
  c4:	02 0a       	sbc	r0, r18
  c6:	00 00       	nop
  c8:	0f 34       	cpi	r16, 0x4F	; 79
  ca:	00 03       	mulsu	r16, r16
  cc:	0e 3a       	cpi	r16, 0xAE	; 174
  ce:	0b 3b       	cpi	r16, 0xBB	; 187
  d0:	0b 49       	sbci	r16, 0x9B	; 155
  d2:	13 3f       	cpi	r17, 0xF3	; 243
  d4:	0c 02       	muls	r16, r28
  d6:	0a 00       	.word	0x000a	; ????
  d8:	00 10       	cpse	r0, r0
  da:	34 00       	.word	0x0034	; ????
  dc:	03 0e       	add	r0, r19
  de:	3a 0b       	sbc	r19, r26
  e0:	3b 0b       	sbc	r19, r27
  e2:	49 13       	cpse	r20, r25
  e4:	3f 0c       	add	r3, r15
  e6:	02 0a       	sbc	r0, r18
  e8:	00 00       	nop
  ea:	11 34       	cpi	r17, 0x41	; 65
  ec:	00 03       	mulsu	r16, r16
  ee:	0e 3a       	cpi	r16, 0xAE	; 174
  f0:	0b 3b       	cpi	r16, 0xBB	; 187
  f2:	0b 49       	sbci	r16, 0x9B	; 155
  f4:	13 3f       	cpi	r17, 0xF3	; 243
  f6:	0c 02       	muls	r16, r28
  f8:	0a 00       	.word	0x000a	; ????
  fa:	00 12       	cpse	r0, r16
  fc:	34 00       	.word	0x0034	; ????
  fe:	03 0e       	add	r0, r19
 100:	3a 0b       	sbc	r19, r26
 102:	3b 0b       	sbc	r19, r27
 104:	49 13       	cpse	r20, r25
 106:	3f 0c       	add	r3, r15
 108:	02 0a       	sbc	r0, r18
 10a:	00 00       	nop
 10c:	13 34       	cpi	r17, 0x43	; 67
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	00 03       	mulsu	r16, r16
 110:	0e 3a       	cpi	r16, 0xAE	; 174
 112:	0b 3b       	cpi	r16, 0xBB	; 187
	uint8_t bit = digitalPinToBitMask(pin);
 114:	0b 49       	sbci	r16, 0x9B	; 155
 116:	13 3f       	cpi	r17, 0xF3	; 243
 118:	0c 02       	muls	r16, r28
	uint8_t port = digitalPinToPort(pin);
 11a:	0a 00       	.word	0x000a	; ????
 11c:	00 14       	cp	r0, r0
 11e:	34 00       	.word	0x0034	; ????
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	03 0e       	add	r0, r19
 122:	3a 0b       	sbc	r19, r26

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	3b 0b       	sbc	r19, r27
 126:	49 13       	cpse	r20, r25
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	3f 0c       	add	r3, r15
 12a:	02 0a       	sbc	r0, r18
 12c:	00 00       	nop
 12e:	15 34       	cpi	r17, 0x45	; 69
 130:	00 03       	mulsu	r16, r16
 132:	0e 3a       	cpi	r16, 0xAE	; 174
 134:	0b 3b       	cpi	r16, 0xBB	; 187

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	0b 49       	sbci	r16, 0x9B	; 155
 138:	13 3f       	cpi	r17, 0xF3	; 243
 13a:	0c 02       	muls	r16, r28
 13c:	0a 00       	.word	0x000a	; ????
 13e:	00 16       	cp	r0, r16
 140:	34 00       	.word	0x0034	; ????
 142:	03 0e       	add	r0, r19

	uint8_t oldSREG = SREG;
 144:	3a 0b       	sbc	r19, r26
	cli();
 146:	3b 0b       	sbc	r19, r27

	if (val == LOW) {
		*out &= ~bit;
 148:	49 13       	cpse	r20, r25
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	3f 0c       	add	r3, r15
 14c:	02 0a       	sbc	r0, r18
		*out &= ~bit;
 14e:	00 00       	nop
 150:	17 34       	cpi	r17, 0x47	; 71
	} else {
		*out |= bit;
 152:	00 03       	mulsu	r16, r16
	}

	SREG = oldSREG;
 154:	0e 3a       	cpi	r16, 0xAE	; 174
}
 156:	0b 3b       	cpi	r16, 0xBB	; 187
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	0b 49       	sbci	r16, 0x9B	; 155
 15a:	13 3f       	cpi	r17, 0xF3	; 243
 15c:	0c 02       	muls	r16, r28
 15e:	0a 00       	.word	0x000a	; ????
 160:	00 18       	sub	r0, r0
 162:	34 00       	.word	0x0034	; ????
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	03 0e       	add	r0, r19
 166:	3a 0b       	sbc	r19, r26
 168:	3b 0b       	sbc	r19, r27
 16a:	49 13       	cpse	r20, r25
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	3f 0c       	add	r3, r15
 16e:	02 0a       	sbc	r0, r18
 170:	00 00       	nop
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	19 34       	cpi	r17, 0x49	; 73
 174:	00 03       	mulsu	r16, r16
 176:	0e 3a       	cpi	r16, 0xAE	; 174
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	0b 3b       	cpi	r16, 0xBB	; 187
 17a:	0b 49       	sbci	r16, 0x9B	; 155
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17c:	13 3f       	cpi	r17, 0xF3	; 243
 17e:	0c 02       	muls	r16, r28
 180:	0a 00       	.word	0x000a	; ????
 182:	00 1a       	sub	r0, r16
 184:	34 00       	.word	0x0034	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	03 0e       	add	r0, r19
 188:	3a 0b       	sbc	r19, r26
 18a:	3b 0b       	sbc	r19, r27
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	49 13       	cpse	r20, r25
 18e:	3f 0c       	add	r3, r15
 190:	02 0a       	sbc	r0, r18
 192:	00 00       	nop
 194:	1b 34       	cpi	r17, 0x4B	; 75
 196:	00 03       	mulsu	r16, r16
 198:	0e 3a       	cpi	r16, 0xAE	; 174
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	0b 3b       	cpi	r16, 0xBB	; 187
 19c:	0b 49       	sbci	r16, 0x9B	; 155

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	13 3f       	cpi	r17, 0xF3	; 243
 1a0:	0c 02       	muls	r16, r28
 1a2:	0a 00       	.word	0x000a	; ????
 1a4:	00 1c       	adc	r0, r0
 1a6:	34 00       	.word	0x0034	; ????
 1a8:	03 0e       	add	r0, r19
 1aa:	3a 0b       	sbc	r19, r26
 1ac:	3b 0b       	sbc	r19, r27
 1ae:	49 13       	cpse	r20, r25
 1b0:	3f 0c       	add	r3, r15
 1b2:	02 0a       	sbc	r0, r18
 1b4:	00 00       	nop
 1b6:	1d 34       	cpi	r17, 0x4D	; 77
 1b8:	00 03       	mulsu	r16, r16
 1ba:	0e 3a       	cpi	r16, 0xAE	; 174
 1bc:	0b 3b       	cpi	r16, 0xBB	; 187
 1be:	0b 49       	sbci	r16, 0x9B	; 155
 1c0:	13 3f       	cpi	r17, 0xF3	; 243
 1c2:	0c 02       	muls	r16, r28
  size_t n = 0;
  while (size--) {
 1c4:	0a 00       	.word	0x000a	; ????
 1c6:	00 1e       	adc	r0, r16
 1c8:	34 00       	.word	0x0034	; ????
    if (write(*buffer++)) n++;
 1ca:	03 0e       	add	r0, r19
 1cc:	3a 0b       	sbc	r19, r26
 1ce:	3b 0b       	sbc	r19, r27
 1d0:	49 13       	cpse	r20, r25
 1d2:	3f 0c       	add	r3, r15
 1d4:	02 0a       	sbc	r0, r18
 1d6:	00 00       	nop
 1d8:	1f 34       	cpi	r17, 0x4F	; 79
 1da:	00 03       	mulsu	r16, r16
 1dc:	0e 3a       	cpi	r16, 0xAE	; 174
 1de:	0b 3b       	cpi	r16, 0xBB	; 187
    else break;
  }
  return n;
}
 1e0:	0b 49       	sbci	r16, 0x9B	; 155
 1e2:	13 3f       	cpi	r17, 0xF3	; 243
 1e4:	0c 02       	muls	r16, r28
 1e6:	0a 00       	.word	0x000a	; ????
 1e8:	00 20       	and	r0, r0
 1ea:	34 00       	.word	0x0034	; ????
 1ec:	03 0e       	add	r0, r19
 1ee:	3a 0b       	sbc	r19, r26
 1f0:	3b 0b       	sbc	r19, r27
 1f2:	49 13       	cpse	r20, r25
 1f4:	3f 0c       	add	r3, r15
 1f6:	02 0a       	sbc	r0, r18
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	00 00       	nop
 1fa:	21 34       	cpi	r18, 0x41	; 65
    tail = _tx_buffer_tail;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	0e 3a       	cpi	r16, 0xAE	; 174
 200:	0b 3b       	cpi	r16, 0xBB	; 187
 202:	0b 49       	sbci	r16, 0x9B	; 155
 204:	13 3f       	cpi	r17, 0xF3	; 243
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	0c 02       	muls	r16, r28
 208:	0a 00       	.word	0x000a	; ????
 20a:	00 22       	and	r0, r16
 20c:	34 00       	.word	0x0034	; ????
 20e:	03 0e       	add	r0, r19
 210:	3a 0b       	sbc	r19, r26
  return tail - head - 1;
 212:	3b 0b       	sbc	r19, r27
}
 214:	49 13       	cpse	r20, r25
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	3f 0c       	add	r3, r15
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	02 0a       	sbc	r0, r18
 21a:	00 00       	nop
 21c:	23 34       	cpi	r18, 0x43	; 67
 21e:	00 03       	mulsu	r16, r16
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	0e 3a       	cpi	r16, 0xAE	; 174
 222:	0b 3b       	cpi	r16, 0xBB	; 187
 224:	0b 49       	sbci	r16, 0x9B	; 155
 226:	13 3f       	cpi	r17, 0xF3	; 243
 228:	0c 02       	muls	r16, r28
 22a:	0a 00       	.word	0x000a	; ????
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 22c:	00 24       	eor	r0, r0
 22e:	34 00       	.word	0x0034	; ????
 230:	03 0e       	add	r0, r19
 232:	3a 0b       	sbc	r19, r26
    return c;
 234:	3b 0b       	sbc	r19, r27
 236:	49 13       	cpse	r20, r25

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 238:	3f 0c       	add	r3, r15
 23a:	02 0a       	sbc	r0, r18
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 23c:	00 00       	nop
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 23e:	25 34       	cpi	r18, 0x45	; 69
  if (_rx_buffer_head == _rx_buffer_tail) {
 240:	00 03       	mulsu	r16, r16
 242:	0e 3a       	cpi	r16, 0xAE	; 174
 244:	0b 3b       	cpi	r16, 0xBB	; 187
 246:	0b 49       	sbci	r16, 0x9B	; 155
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 248:	13 3f       	cpi	r17, 0xF3	; 243
 24a:	0c 02       	muls	r16, r28
 24c:	0a 00       	.word	0x000a	; ????
 24e:	00 26       	eor	r0, r16
 250:	34 00       	.word	0x0034	; ????
 252:	03 0e       	add	r0, r19
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 254:	3a 0b       	sbc	r19, r26
 256:	3b 0b       	sbc	r19, r27
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 258:	49 13       	cpse	r20, r25
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 25a:	3f 0c       	add	r3, r15
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 25c:	02 0a       	sbc	r0, r18
 25e:	00 00       	nop
 260:	27 34       	cpi	r18, 0x47	; 71
 262:	00 03       	mulsu	r16, r16
 264:	0e 3a       	cpi	r16, 0xAE	; 174
 266:	0b 3b       	cpi	r16, 0xBB	; 187
 268:	0b 49       	sbci	r16, 0x9B	; 155
 26a:	13 3f       	cpi	r17, 0xF3	; 243
}
 26c:	0c 02       	muls	r16, r28
 26e:	0a 00       	.word	0x000a	; ????
 270:	00 28       	or	r0, r0
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 272:	34 00       	.word	0x0034	; ????
 274:	03 0e       	add	r0, r19
 276:	3a 0b       	sbc	r19, r26
 278:	3b 0b       	sbc	r19, r27
 27a:	49 13       	cpse	r20, r25
 27c:	3f 0c       	add	r3, r15
 27e:	02 0a       	sbc	r0, r18
 280:	00 00       	nop
}
 282:	29 34       	cpi	r18, 0x49	; 73
 284:	00 03       	mulsu	r16, r16
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 286:	0e 3a       	cpi	r16, 0xAE	; 174
 288:	0b 3b       	cpi	r16, 0xBB	; 187
 28a:	0b 49       	sbci	r16, 0x9B	; 155
 28c:	13 3f       	cpi	r17, 0xF3	; 243
 28e:	0c 02       	muls	r16, r28
 290:	0a 00       	.word	0x000a	; ????
 292:	00 2a       	or	r0, r16
 294:	34 00       	.word	0x0034	; ????
 296:	03 0e       	add	r0, r19
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 298:	3a 0b       	sbc	r19, r26
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 29a:	3b 0b       	sbc	r19, r27
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 29c:	49 13       	cpse	r20, r25
 29e:	3f 0c       	add	r3, r15
 2a0:	02 0a       	sbc	r0, r18
 2a2:	00 00       	nop
 2a4:	2b 34       	cpi	r18, 0x4B	; 75
 2a6:	00 03       	mulsu	r16, r16
 2a8:	0e 3a       	cpi	r16, 0xAE	; 174
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2aa:	0b 3b       	cpi	r16, 0xBB	; 187
 2ac:	0b 49       	sbci	r16, 0x9B	; 155
 2ae:	13 3f       	cpi	r17, 0xF3	; 243
 2b0:	0c 02       	muls	r16, r28
 2b2:	0a 00       	.word	0x000a	; ????
 2b4:	00 2c       	mov	r0, r0

  *_udr = c;
 2b6:	34 00       	.word	0x0034	; ????
 2b8:	03 0e       	add	r0, r19
 2ba:	3a 0b       	sbc	r19, r26
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 2bc:	3b 0b       	sbc	r19, r27
 2be:	49 13       	cpse	r20, r25
 2c0:	3f 0c       	add	r3, r15
 2c2:	02 0a       	sbc	r0, r18
 2c4:	00 00       	nop
 2c6:	2d 34       	cpi	r18, 0x4D	; 77
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 2c8:	00 03       	mulsu	r16, r16
 2ca:	0e 3a       	cpi	r16, 0xAE	; 174
 2cc:	0b 3b       	cpi	r16, 0xBB	; 187
 2ce:	0b 49       	sbci	r16, 0x9B	; 155
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 2d0:	13 3f       	cpi	r17, 0xF3	; 243
 2d2:	0c 02       	muls	r16, r28
 2d4:	0a 00       	.word	0x000a	; ????
 2d6:	00 2e       	mov	r0, r16
 2d8:	34 00       	.word	0x0034	; ????
 2da:	03 0e       	add	r0, r19
  }
}
 2dc:	3a 0b       	sbc	r19, r26
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 2de:	3b 0b       	sbc	r19, r27
 2e0:	49 13       	cpse	r20, r25
 2e2:	3f 0c       	add	r3, r15
 2e4:	02 0a       	sbc	r0, r18
 2e6:	00 00       	nop
 2e8:	2f 34       	cpi	r18, 0x4F	; 79
 2ea:	00 03       	mulsu	r16, r16
  _written = true;
 2ec:	0e 3a       	cpi	r16, 0xAE	; 174
 2ee:	0b 3b       	cpi	r16, 0xBB	; 187
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 2f0:	0b 49       	sbci	r16, 0x9B	; 155
 2f2:	13 3f       	cpi	r17, 0xF3	; 243
 2f4:	0c 02       	muls	r16, r28
 2f6:	0a 00       	.word	0x000a	; ????
 2f8:	00 30       	cpi	r16, 0x00	; 0
 2fa:	34 00       	.word	0x0034	; ????
 2fc:	03 0e       	add	r0, r19
 2fe:	3a 0b       	sbc	r19, r26
 300:	3b 0b       	sbc	r19, r27
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 302:	49 13       	cpse	r20, r25
 304:	3f 0c       	add	r3, r15
      *_udr = c;
 306:	02 0a       	sbc	r0, r18
 308:	00 00       	nop
 30a:	31 34       	cpi	r19, 0x41	; 65
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 30c:	00 03       	mulsu	r16, r16
 30e:	0e 3a       	cpi	r16, 0xAE	; 174
 310:	0b 3b       	cpi	r16, 0xBB	; 187
 312:	0b 49       	sbci	r16, 0x9B	; 155
 314:	13 3f       	cpi	r17, 0xF3	; 243
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 316:	0c 02       	muls	r16, r28
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 318:	0a 00       	.word	0x000a	; ????
  }
  
  return 1;
}
 31a:	00 32       	cpi	r16, 0x20	; 32
 31c:	34 00       	.word	0x0034	; ????
 31e:	03 0e       	add	r0, r19
 320:	3a 0b       	sbc	r19, r26
 322:	3b 0b       	sbc	r19, r27
 324:	49 13       	cpse	r20, r25
 326:	3f 0c       	add	r3, r15
 328:	02 0a       	sbc	r0, r18
 32a:	00 00       	nop
 32c:	33 34       	cpi	r19, 0x43	; 67
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 32e:	00 03       	mulsu	r16, r16
 330:	0e 3a       	cpi	r16, 0xAE	; 174
 332:	0b 3b       	cpi	r16, 0xBB	; 187
 334:	0b 49       	sbci	r16, 0x9B	; 155
 336:	13 3f       	cpi	r17, 0xF3	; 243
 338:	0c 02       	muls	r16, r28
 33a:	0a 00       	.word	0x000a	; ????
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 33c:	00 34       	cpi	r16, 0x40	; 64
 33e:	34 00       	.word	0x0034	; ????
 340:	03 0e       	add	r0, r19
    if (bit_is_clear(SREG, SREG_I)) {
 342:	3a 0b       	sbc	r19, r26
 344:	3b 0b       	sbc	r19, r27
 346:	49 13       	cpse	r20, r25
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 348:	3f 0c       	add	r3, r15
 34a:	02 0a       	sbc	r0, r18
 34c:	00 00       	nop
 34e:	35 34       	cpi	r19, 0x45	; 69
 350:	00 03       	mulsu	r16, r16
	_tx_udr_empty_irq();
 352:	0e 3a       	cpi	r16, 0xAE	; 174
 354:	0b 3b       	cpi	r16, 0xBB	; 187
 356:	0b 49       	sbci	r16, 0x9B	; 155
 358:	13 3f       	cpi	r17, 0xF3	; 243
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 35a:	0c 02       	muls	r16, r28
 35c:	0a 00       	.word	0x000a	; ????
 35e:	00 36       	cpi	r16, 0x60	; 96
 360:	34 00       	.word	0x0034	; ????
 362:	03 0e       	add	r0, r19
 364:	3a 0b       	sbc	r19, r26
 366:	3b 0b       	sbc	r19, r27

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 368:	49 13       	cpse	r20, r25
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 36a:	3f 0c       	add	r3, r15
    _tx_buffer_head = i;
 36c:	02 0a       	sbc	r0, r18
    sbi(*_ucsrb, UDRIE0);
 36e:	00 00       	nop
 370:	37 34       	cpi	r19, 0x47	; 71
 372:	00 03       	mulsu	r16, r16
 374:	0e 3a       	cpi	r16, 0xAE	; 174
 376:	0b 3b       	cpi	r16, 0xBB	; 187
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 378:	0b 49       	sbci	r16, 0x9B	; 155
 37a:	13 3f       	cpi	r17, 0xF3	; 243
 37c:	0c 02       	muls	r16, r28
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 37e:	0a 00       	.word	0x000a	; ????
 380:	00 38       	cpi	r16, 0x80	; 128
 382:	34 00       	.word	0x0034	; ????
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 384:	03 0e       	add	r0, r19
 386:	3a 0b       	sbc	r19, r26
 388:	3b 0b       	sbc	r19, r27
 38a:	49 13       	cpse	r20, r25
 38c:	3f 0c       	add	r3, r15
 38e:	02 0a       	sbc	r0, r18
 390:	00 00       	nop
 392:	39 34       	cpi	r19, 0x49	; 73
 394:	00 03       	mulsu	r16, r16
 396:	0e 3a       	cpi	r16, 0xAE	; 174
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 398:	0b 3b       	cpi	r16, 0xBB	; 187
 39a:	0b 49       	sbci	r16, 0x9B	; 155
 39c:	13 3f       	cpi	r17, 0xF3	; 243
 39e:	0c 02       	muls	r16, r28
 3a0:	0a 00       	.word	0x000a	; ????
 3a2:	00 3a       	cpi	r16, 0xA0	; 160
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 3a4:	34 00       	.word	0x0034	; ????
 3a6:	03 0e       	add	r0, r19
 3a8:	3a 0b       	sbc	r19, r26
	  _tx_udr_empty_irq();
 3aa:	3b 0b       	sbc	r19, r27
 3ac:	49 13       	cpse	r20, r25
 3ae:	3f 0c       	add	r3, r15
 3b0:	02 0a       	sbc	r0, r18
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3b2:	00 00       	nop
 3b4:	3b 34       	cpi	r19, 0x4B	; 75
 3b6:	00 03       	mulsu	r16, r16
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 3b8:	0e 3a       	cpi	r16, 0xAE	; 174
 3ba:	0b 3b       	cpi	r16, 0xBB	; 187
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 3bc:	0b 49       	sbci	r16, 0x9B	; 155
 3be:	13 3f       	cpi	r17, 0xF3	; 243
 3c0:	0c 02       	muls	r16, r28
 3c2:	0a 00       	.word	0x000a	; ????
 3c4:	00 3c       	cpi	r16, 0xC0	; 192
 3c6:	34 00       	.word	0x0034	; ????
 3c8:	03 0e       	add	r0, r19
 3ca:	3a 0b       	sbc	r19, r26
 3cc:	3b 0b       	sbc	r19, r27
 3ce:	49 13       	cpse	r20, r25
 3d0:	3f 0c       	add	r3, r15
 3d2:	02 0a       	sbc	r0, r18
 3d4:	00 00       	nop
 3d6:	3d 34       	cpi	r19, 0x4D	; 77
 3d8:	00 03       	mulsu	r16, r16
 3da:	0e 3a       	cpi	r16, 0xAE	; 174
 3dc:	0b 3b       	cpi	r16, 0xBB	; 187
 3de:	0b 49       	sbci	r16, 0x9B	; 155
 3e0:	13 3f       	cpi	r17, 0xF3	; 243
 3e2:	0c 02       	muls	r16, r28
 3e4:	0a 00       	.word	0x000a	; ????
 3e6:	00 3e       	cpi	r16, 0xE0	; 224
{
  size_t n = print(c);
  n += println();
  return n;
}
 3e8:	34 00       	.word	0x0034	; ????
 3ea:	03 0e       	add	r0, r19
 3ec:	3a 0b       	sbc	r19, r26
 3ee:	3b 0b       	sbc	r19, r27
 3f0:	49 13       	cpse	r20, r25
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3f2:	3f 0c       	add	r3, r15
 3f4:	02 0a       	sbc	r0, r18
 3f6:	00 00       	nop
 3f8:	3f 34       	cpi	r19, 0x4F	; 79
 3fa:	00 03       	mulsu	r16, r16
 3fc:	0e 3a       	cpi	r16, 0xAE	; 174
 3fe:	0b 3b       	cpi	r16, 0xBB	; 187
 400:	0b 49       	sbci	r16, 0x9B	; 155
 402:	13 3f       	cpi	r17, 0xF3	; 243
 404:	0c 02       	muls	r16, r28
 406:	0a 00       	.word	0x000a	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 408:	00 40       	sbci	r16, 0x00	; 0
 40a:	34 00       	.word	0x0034	; ????
 40c:	03 0e       	add	r0, r19
 40e:	3a 0b       	sbc	r19, r26
 410:	3b 0b       	sbc	r19, r27
 412:	49 13       	cpse	r20, r25
 414:	3f 0c       	add	r3, r15
 416:	02 0a       	sbc	r0, r18
	unsigned char f = timer0_fract;
 418:	00 00       	nop
 41a:	41 34       	cpi	r20, 0x41	; 65

	m += MILLIS_INC;
	f += FRACT_INC;
 41c:	00 03       	mulsu	r16, r16
 41e:	0e 3a       	cpi	r16, 0xAE	; 174
	if (f >= FRACT_MAX) {
 420:	0b 3b       	cpi	r16, 0xBB	; 187
 422:	0b 49       	sbci	r16, 0x9B	; 155
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 424:	13 3f       	cpi	r17, 0xF3	; 243
 426:	0c 02       	muls	r16, r28
 428:	0a 00       	.word	0x000a	; ????
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 42a:	00 42       	sbci	r16, 0x20	; 32
 42c:	34 00       	.word	0x0034	; ????
	timer0_millis = m;
 42e:	03 0e       	add	r0, r19
 430:	3a 0b       	sbc	r19, r26
 432:	3b 0b       	sbc	r19, r27
 434:	49 13       	cpse	r20, r25
 436:	3f 0c       	add	r3, r15
 438:	02 0a       	sbc	r0, r18
 43a:	00 00       	nop
 43c:	43 34       	cpi	r20, 0x43	; 67
	timer0_overflow_count++;
 43e:	00 03       	mulsu	r16, r16
 440:	0e 3a       	cpi	r16, 0xAE	; 174
 442:	0b 3b       	cpi	r16, 0xBB	; 187
 444:	0b 49       	sbci	r16, 0x9B	; 155
 446:	13 3f       	cpi	r17, 0xF3	; 243
 448:	0c 02       	muls	r16, r28
 44a:	0a 00       	.word	0x000a	; ????
 44c:	00 44       	sbci	r16, 0x40	; 64
 44e:	34 00       	.word	0x0034	; ????
 450:	03 0e       	add	r0, r19
 452:	3a 0b       	sbc	r19, r26
 454:	3b 0b       	sbc	r19, r27
 456:	49 13       	cpse	r20, r25
 458:	3f 0c       	add	r3, r15
 45a:	02 0a       	sbc	r0, r18
 45c:	00 00       	nop
 45e:	45 34       	cpi	r20, 0x45	; 69
 460:	00 03       	mulsu	r16, r16
 462:	0e 3a       	cpi	r16, 0xAE	; 174
}
 464:	0b 3b       	cpi	r16, 0xBB	; 187
 466:	0b 49       	sbci	r16, 0x9B	; 155
 468:	13 3f       	cpi	r17, 0xF3	; 243
 46a:	0c 02       	muls	r16, r28
 46c:	0a 00       	.word	0x000a	; ????
 46e:	00 46       	sbci	r16, 0x60	; 96
 470:	34 00       	.word	0x0034	; ????
 472:	03 0e       	add	r0, r19
 474:	3a 0b       	sbc	r19, r26
 476:	3b 0b       	sbc	r19, r27
 478:	49 13       	cpse	r20, r25
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 47a:	3f 0c       	add	r3, r15
 47c:	02 0a       	sbc	r0, r18
		m += 1;
 47e:	00 00       	nop
 480:	47 34       	cpi	r20, 0x47	; 71
 482:	00 03       	mulsu	r16, r16
 484:	0e 3a       	cpi	r16, 0xAE	; 174
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 486:	0b 3b       	cpi	r16, 0xBB	; 187
 488:	0b 49       	sbci	r16, 0x9B	; 155
 48a:	13 3f       	cpi	r17, 0xF3	; 243
 48c:	0c 02       	muls	r16, r28
 48e:	0a 00       	.word	0x000a	; ????
 490:	00 48       	sbci	r16, 0x80	; 128
 492:	34 00       	.word	0x0034	; ????
 494:	03 0e       	add	r0, r19
 496:	3a 0b       	sbc	r19, r26
 498:	3b 0b       	sbc	r19, r27
 49a:	49 13       	cpse	r20, r25
 49c:	3f 0c       	add	r3, r15
 49e:	02 0a       	sbc	r0, r18
 4a0:	00 00       	nop
 4a2:	49 34       	cpi	r20, 0x49	; 73
 4a4:	00 03       	mulsu	r16, r16
 4a6:	0e 3a       	cpi	r16, 0xAE	; 174
  Serial._tx_udr_empty_irq();
 4a8:	0b 3b       	cpi	r16, 0xBB	; 187
 4aa:	0b 49       	sbci	r16, 0x9B	; 155
 4ac:	13 3f       	cpi	r17, 0xF3	; 243
 4ae:	0c 02       	muls	r16, r28
}
 4b0:	0a 00       	.word	0x000a	; ????
 4b2:	00 4a       	sbci	r16, 0xA0	; 160
 4b4:	34 00       	.word	0x0034	; ????
 4b6:	03 0e       	add	r0, r19
 4b8:	3a 0b       	sbc	r19, r26
 4ba:	3b 0b       	sbc	r19, r27
 4bc:	49 13       	cpse	r20, r25
 4be:	3f 0c       	add	r3, r15
 4c0:	02 0a       	sbc	r0, r18
 4c2:	00 00       	nop
 4c4:	4b 34       	cpi	r20, 0x4B	; 75
 4c6:	00 03       	mulsu	r16, r16
 4c8:	0e 3a       	cpi	r16, 0xAE	; 174
 4ca:	0b 3b       	cpi	r16, 0xBB	; 187
 4cc:	0b 49       	sbci	r16, 0x9B	; 155
 4ce:	13 3f       	cpi	r17, 0xF3	; 243
 4d0:	0c 02       	muls	r16, r28
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4d2:	0a 00       	.word	0x000a	; ????
 4d4:	00 4c       	sbci	r16, 0xC0	; 192
 4d6:	34 00       	.word	0x0034	; ????
 4d8:	03 0e       	add	r0, r19
 4da:	3a 0b       	sbc	r19, r26
 4dc:	3b 0b       	sbc	r19, r27
 4de:	49 13       	cpse	r20, r25
 4e0:	3f 0c       	add	r3, r15
 4e2:	02 0a       	sbc	r0, r18
 4e4:	00 00       	nop

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 4e6:	4d 34       	cpi	r20, 0x4D	; 77
 4e8:	00 03       	mulsu	r16, r16
 4ea:	0e 3a       	cpi	r16, 0xAE	; 174
 4ec:	0b 3b       	cpi	r16, 0xBB	; 187
 4ee:	0b 49       	sbci	r16, 0x9B	; 155
 4f0:	13 3f       	cpi	r17, 0xF3	; 243
 4f2:	0c 02       	muls	r16, r28
 4f4:	0a 00       	.word	0x000a	; ????
 4f6:	00 4e       	sbci	r16, 0xE0	; 224
 4f8:	34 00       	.word	0x0034	; ????
 4fa:	03 0e       	add	r0, r19
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 4fc:	3a 0b       	sbc	r19, r26
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 4fe:	3b 0b       	sbc	r19, r27
 500:	49 13       	cpse	r20, r25
 502:	3f 0c       	add	r3, r15
 504:	02 0a       	sbc	r0, r18

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 506:	00 00       	nop
 508:	4f 34       	cpi	r20, 0x4F	; 79
 50a:	00 03       	mulsu	r16, r16
 50c:	0e 3a       	cpi	r16, 0xAE	; 174
      _rx_buffer[_rx_buffer_head] = c;
 50e:	0b 3b       	cpi	r16, 0xBB	; 187
 510:	0b 49       	sbci	r16, 0x9B	; 155
 512:	13 3f       	cpi	r17, 0xF3	; 243
 514:	0c 02       	muls	r16, r28
 516:	0a 00       	.word	0x000a	; ????
 518:	00 50       	subi	r16, 0x00	; 0
      _rx_buffer_head = i;
 51a:	34 00       	.word	0x0034	; ????
 51c:	03 0e       	add	r0, r19
    Serial._rx_complete_irq();
  }
 51e:	3a 0b       	sbc	r19, r26
 520:	3b 0b       	sbc	r19, r27
 522:	49 13       	cpse	r20, r25
 524:	3f 0c       	add	r3, r15
 526:	02 0a       	sbc	r0, r18
 528:	00 00       	nop
 52a:	51 34       	cpi	r21, 0x41	; 65
 52c:	00 03       	mulsu	r16, r16
 52e:	0e 3a       	cpi	r16, 0xAE	; 174
 530:	0b 3b       	cpi	r16, 0xBB	; 187
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 532:	0b 49       	sbci	r16, 0x9B	; 155
 534:	13 3f       	cpi	r17, 0xF3	; 243

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 536:	0c 02       	muls	r16, r28
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 538:	0a 00       	.word	0x000a	; ????
 53a:	00 52       	subi	r16, 0x20	; 32
 53c:	34 00       	.word	0x0034	; ????
	sbi(TCCR0A, WGM00);
 53e:	03 0e       	add	r0, r19
 540:	3a 0b       	sbc	r19, r26
 542:	3b 0b       	sbc	r19, r27
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 544:	49 13       	cpse	r20, r25
 546:	3f 0c       	add	r3, r15
 548:	02 0a       	sbc	r0, r18
	sbi(TCCR0B, CS00);
 54a:	00 00       	nop
 54c:	53 34       	cpi	r21, 0x43	; 67
 54e:	00 03       	mulsu	r16, r16

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 550:	0e 3a       	cpi	r16, 0xAE	; 174
 552:	0b 3b       	cpi	r16, 0xBB	; 187
 554:	0b 49       	sbci	r16, 0x9B	; 155
 556:	13 3f       	cpi	r17, 0xF3	; 243
 558:	0c 02       	muls	r16, r28
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 55a:	0a 00       	.word	0x000a	; ????
 55c:	00 54       	subi	r16, 0x40	; 64

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 55e:	34 00       	.word	0x0034	; ????
 560:	03 0e       	add	r0, r19
 562:	3a 0b       	sbc	r19, r26
 564:	3b 0b       	sbc	r19, r27
 566:	49 13       	cpse	r20, r25
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 568:	3f 0c       	add	r3, r15
 56a:	02 0a       	sbc	r0, r18
 56c:	00 00       	nop
 56e:	55 34       	cpi	r21, 0x45	; 69
 570:	00 03       	mulsu	r16, r16
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 572:	0e 3a       	cpi	r16, 0xAE	; 174
 574:	0b 3b       	cpi	r16, 0xBB	; 187
 576:	0b 49       	sbci	r16, 0x9B	; 155
 578:	13 3f       	cpi	r17, 0xF3	; 243
 57a:	0c 02       	muls	r16, r28

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 57c:	0a 00       	.word	0x000a	; ????
 57e:	00 56       	subi	r16, 0x60	; 96
 580:	34 00       	.word	0x0034	; ????
 582:	03 0e       	add	r0, r19
 584:	3a 0b       	sbc	r19, r26

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 586:	3b 0b       	sbc	r19, r27
 588:	49 13       	cpse	r20, r25
 58a:	3f 0c       	add	r3, r15
 58c:	02 0a       	sbc	r0, r18
 58e:	00 00       	nop
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 590:	57 34       	cpi	r21, 0x47	; 71
 592:	00 03       	mulsu	r16, r16
 594:	0e 3a       	cpi	r16, 0xAE	; 174
 596:	0b 3b       	cpi	r16, 0xBB	; 187
 598:	0b 49       	sbci	r16, 0x9B	; 155
		sbi(ADCSRA, ADPS1);
 59a:	13 3f       	cpi	r17, 0xF3	; 243
 59c:	0c 02       	muls	r16, r28
 59e:	0a 00       	.word	0x000a	; ????
 5a0:	00 00       	nop
 5a2:	01 11       	cpse	r16, r1
		sbi(ADCSRA, ADPS0);
 5a4:	01 25       	eor	r16, r1
 5a6:	0e 13       	cpse	r16, r30
 5a8:	0b 03       	fmul	r16, r19
 5aa:	0e 1b       	sub	r16, r30
 5ac:	0e 55       	subi	r16, 0x5E	; 94
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 5ae:	06 11       	cpse	r16, r6
 5b0:	01 52       	subi	r16, 0x21	; 33
 5b2:	01 10       	cpse	r0, r1
 5b4:	06 00       	.word	0x0006	; ????
 5b6:	00 02       	muls	r16, r16
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 5b8:	13 01       	movw	r2, r6
 5ba:	03 0e       	add	r0, r19
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 5bc:	0b 0b       	sbc	r16, r27
 5be:	3a 0b       	sbc	r19, r26
 5c0:	3b 0b       	sbc	r19, r27
	uint8_t port = digitalPinToPort(pin);
 5c2:	1d 13       	cpse	r17, r29
 5c4:	01 13       	cpse	r16, r17
 5c6:	00 00       	nop
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 5c8:	03 0d       	add	r16, r3
 5ca:	00 03       	mulsu	r16, r16

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 5cc:	0e 49       	sbci	r16, 0x9E	; 158
 5ce:	13 38       	cpi	r17, 0x83	; 131
 5d0:	0a 34       	cpi	r16, 0x4A	; 74
 5d2:	0c 00       	.word	0x000c	; ????
 5d4:	00 04       	cpc	r0, r0
 5d6:	0d 00       	.word	0x000d	; ????
 5d8:	03 0e       	add	r0, r19
 5da:	3a 0b       	sbc	r19, r26
	out = portOutputRegister(port);
 5dc:	3b 0b       	sbc	r19, r27
 5de:	49 13       	cpse	r20, r25
 5e0:	38 0a       	sbc	r3, r24
 5e2:	32 0b       	sbc	r19, r18
 5e4:	00 00       	nop
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 5e6:	05 2e       	mov	r0, r21
                cli();
 5e8:	01 03       	mulsu	r16, r17
		*reg |= bit;
 5ea:	0e 3a       	cpi	r16, 0xAE	; 174
 5ec:	0b 3b       	cpi	r16, 0xBB	; 187
 5ee:	0b 27       	eor	r16, r27
		SREG = oldSREG;
 5f0:	0c 49       	sbci	r16, 0x9C	; 156

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 5f2:	13 3c       	cpi	r17, 0xC3	; 195
 5f4:	0c 64       	ori	r16, 0x4C	; 76
 5f6:	13 01       	movw	r2, r6
 5f8:	13 00       	.word	0x0013	; ????
 5fa:	00 06       	cpc	r0, r16
 5fc:	05 00       	.word	0x0005	; ????
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5fe:	49 13       	cpse	r20, r25
 600:	34 0c       	add	r3, r4
 602:	00 00       	nop
 604:	07 2e       	mov	r0, r23
 606:	01 03       	mulsu	r16, r17
  *_ubrrl = baud_setting;
 608:	0e 27       	eor	r16, r30
 60a:	0c 49       	sbci	r16, 0x9C	; 156
 60c:	13 34       	cpi	r17, 0x43	; 67
 60e:	0c 3c       	cpi	r16, 0xCC	; 204
 610:	0c 64       	ori	r16, 0x4C	; 76
 612:	13 01       	movw	r2, r6

  _written = false;
 614:	13 00       	.word	0x0013	; ????
 616:	00 08       	sbc	r0, r0

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 618:	05 00       	.word	0x0005	; ????
 61a:	49 13       	cpse	r20, r25
 61c:	00 00       	nop
 61e:	09 2e       	mov	r0, r25
 620:	01 03       	mulsu	r16, r17
 622:	0e 3a       	cpi	r16, 0xAE	; 174
  
  sbi(*_ucsrb, RXEN0);
 624:	0b 3b       	cpi	r16, 0xBB	; 187
 626:	0b 27       	eor	r16, r27
 628:	0c 49       	sbci	r16, 0x9C	; 156
 62a:	13 4c       	sbci	r17, 0xC3	; 195
 62c:	0b 4d       	sbci	r16, 0xDB	; 219
 62e:	0a 1d       	adc	r16, r10
 630:	13 3c       	cpi	r17, 0xC3	; 195
  sbi(*_ucsrb, TXEN0);
 632:	0c 64       	ori	r16, 0x4C	; 76
 634:	13 01       	movw	r2, r6
 636:	13 00       	.word	0x0013	; ????
 638:	00 0a       	sbc	r0, r16
 63a:	2e 01       	movw	r4, r28
 63c:	03 0e       	add	r0, r19
 63e:	3a 0b       	sbc	r19, r26
  sbi(*_ucsrb, RXCIE0);
 640:	3b 0b       	sbc	r19, r27
 642:	27 0c       	add	r2, r7
 644:	49 13       	cpse	r20, r25
 646:	3c 0c       	add	r3, r12
 648:	64 13       	cpse	r22, r20
 64a:	00 00       	nop
 64c:	0b 15       	cp	r16, r11
  cbi(*_ucsrb, UDRIE0);
 64e:	01 49       	sbci	r16, 0x91	; 145
 650:	13 01       	movw	r2, r6
 652:	13 00       	.word	0x0013	; ????
 654:	00 0c       	add	r0, r0
 656:	18 00       	.word	0x0018	; ????
 658:	00 00       	nop
 65a:	0d 24       	eor	r0, r13
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
 65c:	00 0b       	sbc	r16, r16
 65e:	0b 3e       	cpi	r16, 0xEB	; 235
 660:	0b 03       	fmul	r16, r19
 662:	08 00       	.word	0x0008	; ????
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
 664:	00 0e       	add	r0, r16
 666:	0f 00       	.word	0x000f	; ????
 668:	0b 0b       	sbc	r16, r27
 66a:	49 13       	cpse	r20, r25
 66c:	00 00       	nop
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
 66e:	0f 0f       	add	r16, r31
 670:	00 0b       	sbc	r16, r16
 672:	0b 03       	fmul	r16, r19
 674:	0e 49       	sbci	r16, 0x9E	; 158
 676:	13 00       	.word	0x0013	; ????
 678:	00 10       	cpse	r0, r0
 67a:	1c 00       	.word	0x001c	; ????
 67c:	49 13       	cpse	r20, r25
 67e:	38 0a       	sbc	r3, r24
 680:	32 0b       	sbc	r19, r18
 682:	00 00       	nop
 684:	11 13       	cpse	r17, r17
 686:	00 03       	mulsu	r16, r16
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
 688:	0e 3c       	cpi	r16, 0xCE	; 206
 68a:	0c 00       	.word	0x000c	; ????
 68c:	00 12       	cpse	r0, r16
 68e:	24 00       	.word	0x0024	; ????
 690:	0b 0b       	sbc	r16, r27
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
 692:	3e 0b       	sbc	r19, r30
 694:	03 0e       	add	r0, r19
 696:	00 00       	nop
 698:	13 16       	cp	r1, r19
 69a:	00 03       	mulsu	r16, r16
 69c:	0e 3a       	cpi	r16, 0xAE	; 174
 69e:	0b 3b       	cpi	r16, 0xBB	; 187
 6a0:	0b 49       	sbci	r16, 0x9B	; 155
 6a2:	13 00       	.word	0x0013	; ????
 6a4:	00 14       	cp	r0, r0
 6a6:	35 00       	.word	0x0035	; ????
 6a8:	49 13       	cpse	r20, r25
 6aa:	00 00       	nop
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
 6ac:	15 2e       	mov	r1, r21
 6ae:	01 03       	mulsu	r16, r17
 6b0:	0e 3a       	cpi	r16, 0xAE	; 174
 6b2:	0b 3b       	cpi	r16, 0xBB	; 187
 6b4:	0b 27       	eor	r16, r27
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
 6b6:	0c 3c       	cpi	r16, 0xCC	; 204
 6b8:	0c 64       	ori	r16, 0x4C	; 76
 6ba:	13 01       	movw	r2, r6
 6bc:	13 00       	.word	0x0013	; ????
 6be:	00 16       	cp	r0, r16
 6c0:	2e 01       	movw	r4, r28
 6c2:	03 0e       	add	r0, r19
 6c4:	27 0c       	add	r2, r7
 6c6:	34 0c       	add	r3, r4
 6c8:	3c 0c       	add	r3, r12
 6ca:	64 13       	cpse	r22, r20
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
 6cc:	01 13       	cpse	r16, r17
 6ce:	00 00       	nop
 6d0:	17 2e       	mov	r1, r23
 6d2:	01 03       	mulsu	r16, r17
 6d4:	0e 27       	eor	r16, r30
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
 6d6:	0c 4c       	sbci	r16, 0xCC	; 204
 6d8:	0b 4d       	sbci	r16, 0xDB	; 219
 6da:	0a 1d       	adc	r16, r10
 6dc:	13 34       	cpi	r17, 0x43	; 67
 6de:	0c 3c       	cpi	r16, 0xCC	; 204
 6e0:	0c 64       	ori	r16, 0x4C	; 76
 6e2:	13 01       	movw	r2, r6
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 6e4:	13 00       	.word	0x0013	; ????
 6e6:	00 18       	sub	r0, r0
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
 6e8:	2e 01       	movw	r4, r28
 6ea:	03 0e       	add	r0, r19
 6ec:	3a 0b       	sbc	r19, r26
 6ee:	3b 0b       	sbc	r19, r27
  randomSeed(0);
  noInterrupts();
 6f0:	27 0c       	add	r2, r7
  
  digitalWrite(LED_BUILTIN, LOW);   
 6f2:	4c 0b       	sbc	r20, r28
 6f4:	4d 0a       	sbc	r4, r29
 6f6:	1d 13       	cpse	r17, r29
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 6f8:	3c 0c       	add	r3, r12
 6fa:	64 13       	cpse	r22, r20
 6fc:	00 00       	nop
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
 6fe:	19 26       	eor	r1, r25
 700:	00 49       	sbci	r16, 0x90	; 144
 702:	13 00       	.word	0x0013	; ????
 704:	00 1a       	sub	r0, r16
 706:	01 01       	movw	r0, r2
 708:	49 13       	cpse	r20, r25
 70a:	01 13       	cpse	r16, r17
 70c:	00 00       	nop
 70e:	1b 21       	and	r17, r11
 710:	00 49       	sbci	r16, 0x90	; 144
 712:	13 2f       	mov	r17, r19
 714:	0b 00       	.word	0x000b	; ????
 716:	00 1c       	adc	r0, r0
 718:	2e 01       	movw	r4, r28
 71a:	3f 0c       	add	r3, r15
 71c:	03 0e       	add	r0, r19
 71e:	3a 0b       	sbc	r19, r26
 720:	3b 0b       	sbc	r19, r27
 722:	87 40       	sbci	r24, 0x07	; 7
 724:	0e 27       	eor	r16, r30
 726:	0c 3c       	cpi	r16, 0xCC	; 204
 728:	0c 64       	ori	r16, 0x4C	; 76
 72a:	13 00       	.word	0x0013	; ????
 72c:	00 1d       	adc	r16, r0
 72e:	13 01       	movw	r2, r6
 730:	03 0e       	add	r0, r19
 732:	3c 0c       	add	r3, r12
 734:	01 13       	cpse	r16, r17
 736:	00 00       	nop
 738:	1e 2e       	mov	r1, r30
 73a:	01 47       	sbci	r16, 0x71	; 113
 73c:	13 3a       	cpi	r17, 0xA3	; 163
 73e:	0b 3b       	cpi	r16, 0xBB	; 187
 740:	0b 20       	and	r0, r11
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
 742:	0b 64       	ori	r16, 0x4B	; 75
 744:	13 01       	movw	r2, r6
 746:	13 00       	.word	0x0013	; ????
 748:	00 1f       	adc	r16, r16
 74a:	05 00       	.word	0x0005	; ????
 74c:	03 0e       	add	r0, r19
 74e:	49 13       	cpse	r20, r25
 750:	34 0c       	add	r3, r4
 752:	00 00       	nop
 754:	20 0b       	sbc	r18, r16
 756:	01 00       	.word	0x0001	; ????
 758:	00 21       	and	r16, r0
 75a:	34 00       	.word	0x0034	; ????
 75c:	03 08       	sbc	r0, r3
 75e:	3a 0b       	sbc	r19, r26
 760:	3b 0b       	sbc	r19, r27
 762:	49 13       	cpse	r20, r25
 764:	00 00       	nop
 766:	22 2e       	mov	r2, r18
 768:	01 47       	sbci	r16, 0x71	; 113
 76a:	13 20       	and	r1, r3
 76c:	0b 64       	ori	r16, 0x4B	; 75
 76e:	13 01       	movw	r2, r6
 770:	13 00       	.word	0x0013	; ????
 772:	00 23       	and	r16, r16
 774:	2e 01       	movw	r4, r28
 776:	03 0e       	add	r0, r19
 778:	27 0c       	add	r2, r7
 77a:	34 0c       	add	r3, r4
 77c:	20 0b       	sbc	r18, r16
 77e:	01 13       	cpse	r16, r17
 780:	00 00       	nop
 782:	24 05       	cpc	r18, r4
 784:	00 03       	mulsu	r16, r16
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
 786:	0e 3a       	cpi	r16, 0xAE	; 174
 788:	0b 3b       	cpi	r16, 0xBB	; 187
 78a:	0b 49       	sbci	r16, 0x9B	; 155
 78c:	13 00       	.word	0x0013	; ????
 78e:	00 25       	eor	r16, r0
 790:	2e 01       	movw	r4, r28
 792:	03 0e       	add	r0, r19
 794:	3a 0b       	sbc	r19, r26
 796:	3b 0b       	sbc	r19, r27
 798:	27 0c       	add	r2, r7
 79a:	20 0b       	sbc	r18, r16
 79c:	01 13       	cpse	r16, r17
 79e:	00 00       	nop
 7a0:	26 05       	cpc	r18, r6
 7a2:	00 03       	mulsu	r16, r16
 7a4:	08 3a       	cpi	r16, 0xA8	; 168
 7a6:	0b 3b       	cpi	r16, 0xBB	; 187
 7a8:	0b 49       	sbci	r16, 0x9B	; 155
 7aa:	13 00       	.word	0x0013	; ????
 7ac:	00 27       	eor	r16, r16
 7ae:	34 00       	.word	0x0034	; ????
 7b0:	03 0e       	add	r0, r19
 7b2:	3a 0b       	sbc	r19, r26
 7b4:	3b 0b       	sbc	r19, r27
 7b6:	49 13       	cpse	r20, r25
 7b8:	00 00       	nop
 7ba:	28 0b       	sbc	r18, r24
 7bc:	01 01       	movw	r0, r2
 7be:	13 00       	.word	0x0013	; ????
 7c0:	00 29       	or	r16, r0
 7c2:	2e 01       	movw	r4, r28
 7c4:	03 0e       	add	r0, r19
 7c6:	3a 0b       	sbc	r19, r26
 7c8:	3b 0b       	sbc	r19, r27
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
 7ca:	27 0c       	add	r2, r7
 7cc:	3c 0c       	add	r3, r12
 7ce:	64 13       	cpse	r22, r20
 7d0:	00 00       	nop
 7d2:	2a 2e       	mov	r2, r26
 7d4:	01 31       	cpi	r16, 0x11	; 17
 7d6:	13 11       	cpse	r17, r3
 7d8:	01 12       	cpse	r0, r17
 7da:	01 40       	sbci	r16, 0x01	; 1
 7dc:	0a 97       	sbiw	r24, 0x0a	; 10
 7de:	42 0c       	add	r4, r2
 7e0:	01 13       	cpse	r16, r17
 7e2:	00 00       	nop
 7e4:	2b 05       	cpc	r18, r11
 7e6:	00 31       	cpi	r16, 0x10	; 16
 7e8:	13 02       	muls	r17, r19
 7ea:	0a 00       	.word	0x000a	; ????
 7ec:	00 2c       	mov	r0, r0
 7ee:	34 00       	.word	0x0034	; ????
 7f0:	31 13       	cpse	r19, r17
 7f2:	02 06       	cpc	r0, r18
 7f4:	00 00       	nop
 7f6:	2d 05       	cpc	r18, r13
 7f8:	00 31       	cpi	r16, 0x10	; 16
 7fa:	13 1c       	adc	r1, r3
 7fc:	0b 00       	.word	0x000b	; ????
 7fe:	00 2e       	mov	r0, r16
 800:	0b 01       	movw	r0, r22
 802:	31 13       	cpse	r19, r17
 804:	11 01       	movw	r2, r2
 806:	12 01       	movw	r2, r4
 808:	01 13       	cpse	r16, r17
 80a:	00 00       	nop
 80c:	2f 1d       	adc	r18, r15
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
 80e:	01 31       	cpi	r16, 0x11	; 17
 810:	13 52       	subi	r17, 0x23	; 35
 812:	01 55       	subi	r16, 0x51	; 81
 814:	06 58       	subi	r16, 0x86	; 134
 816:	0b 59       	subi	r16, 0x9B	; 155
 818:	0b 01       	movw	r0, r22
 81a:	13 00       	.word	0x0013	; ????
 81c:	00 30       	cpi	r16, 0x00	; 0
 81e:	05 00       	.word	0x0005	; ????
 820:	31 13       	cpse	r19, r17
 822:	02 06       	cpc	r0, r18
 824:	00 00       	nop
 826:	31 0b       	sbc	r19, r17
 828:	01 11       	cpse	r16, r1
 82a:	01 12       	cpse	r0, r17
 82c:	01 00       	.word	0x0001	; ????
 82e:	00 32       	cpi	r16, 0x20	; 32
 830:	34 00       	.word	0x0034	; ????
 832:	31 13       	cpse	r19, r17
 834:	00 00       	nop
 836:	33 0b       	sbc	r19, r19
 838:	01 31       	cpi	r16, 0x11	; 17
 83a:	13 11       	cpse	r17, r3
 83c:	01 12       	cpse	r0, r17
  Serial.println("End of loop");
 83e:	01 00       	.word	0x0001	; ????
 840:	00 34       	cpi	r16, 0x40	; 64
 842:	2e 01       	movw	r4, r28
 844:	47 13       	cpse	r20, r23
  interrupts();
 846:	11 01       	movw	r2, r2
 848:	12 01       	movw	r2, r4
 84a:	40 06       	cpc	r4, r16
 84c:	64 13       	cpse	r22, r20
 84e:	97 42       	sbci	r25, 0x27	; 39
 850:	0c 01       	movw	r0, r24
 852:	13 00       	.word	0x0013	; ????
 854:	00 35       	cpi	r16, 0x50	; 80
 856:	05 00       	.word	0x0005	; ????
 858:	03 0e       	add	r0, r19
 85a:	49 13       	cpse	r20, r25
 85c:	34 0c       	add	r3, r4
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 85e:	02 06       	cpc	r0, r18
 860:	00 00       	nop
 862:	36 05       	cpc	r19, r6
 864:	00 03       	mulsu	r16, r16
 866:	0e 3a       	cpi	r16, 0xAE	; 174
 868:	0b 3b       	cpi	r16, 0xBB	; 187
 86a:	0b 49       	sbci	r16, 0x9B	; 155
 86c:	13 02       	muls	r17, r19
 86e:	06 00       	.word	0x0006	; ????
 870:	00 37       	cpi	r16, 0x70	; 112
 872:	34 00       	.word	0x0034	; ????
 874:	03 08       	sbc	r0, r3
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 876:	3a 0b       	sbc	r19, r26
 878:	3b 0b       	sbc	r19, r27
 87a:	49 13       	cpse	r20, r25
 87c:	02 06       	cpc	r0, r18
 87e:	00 00       	nop
 880:	38 89       	ldd	r19, Y+16	; 0x10
 882:	82 01       	movw	r16, r4
 884:	01 11       	cpse	r16, r1
 886:	01 00       	.word	0x0001	; ????
 888:	00 39       	cpi	r16, 0x90	; 144
 88a:	8a 82       	std	Y+2, r8	; 0x02
 88c:	01 00       	.word	0x0001	; ????
 88e:	02 0a       	sbc	r0, r18
 890:	91 42       	sbci	r25, 0x21	; 33
 892:	0a 00       	.word	0x000a	; ????
 894:	00 3a       	cpi	r16, 0xA0	; 160
 896:	2e 01       	movw	r4, r28
 898:	47 13       	cpse	r20, r23
 89a:	11 01       	movw	r2, r2
 89c:	12 01       	movw	r2, r4
 89e:	40 0a       	sbc	r4, r16
 8a0:	64 13       	cpse	r22, r20
 8a2:	97 42       	sbci	r25, 0x27	; 39
 8a4:	0c 01       	movw	r0, r24
 8a6:	13 00       	.word	0x0013	; ????
 8a8:	00 3b       	cpi	r16, 0xB0	; 176
 8aa:	34 00       	.word	0x0034	; ????
 8ac:	03 0e       	add	r0, r19
 8ae:	3a 0b       	sbc	r19, r26
 8b0:	3b 0b       	sbc	r19, r27
 8b2:	49 13       	cpse	r20, r25
 8b4:	02 0a       	sbc	r0, r18

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
 8b6:	00 00       	nop
 8b8:	3c 2e       	mov	r3, r28
 8ba:	01 03       	mulsu	r16, r17
 8bc:	0e 3a       	cpi	r16, 0xAE	; 174
 8be:	0b 3b       	cpi	r16, 0xBB	; 187
 8c0:	0b 27       	eor	r16, r27
 8c2:	0c 49       	sbci	r16, 0x9C	; 156
 8c4:	13 11       	cpse	r17, r3
 8c6:	01 12       	cpse	r0, r17
 8c8:	01 40       	sbci	r16, 0x01	; 1
 8ca:	0a 97       	sbiw	r24, 0x0a	; 10
 8cc:	42 0c       	add	r4, r2
 8ce:	01 13       	cpse	r16, r17
 8d0:	00 00       	nop
 8d2:	3d 89       	ldd	r19, Y+21	; 0x15
 8d4:	82 01       	movw	r16, r4
 8d6:	01 11       	cpse	r16, r1
 8d8:	01 31       	cpi	r16, 0x11	; 17
 8da:	13 00       	.word	0x0013	; ????
 8dc:	00 3e       	cpi	r16, 0xE0	; 224
 8de:	2e 00       	.word	0x002e	; ????
 8e0:	03 0e       	add	r0, r19
 8e2:	3a 0b       	sbc	r19, r26
 8e4:	3b 0b       	sbc	r19, r27
 8e6:	27 0c       	add	r2, r7
 8e8:	20 0b       	sbc	r18, r16
 8ea:	00 00       	nop
 8ec:	3f 2e       	mov	r3, r31
 8ee:	00 03       	mulsu	r16, r16
 8f0:	0e 27       	eor	r16, r30
 8f2:	0c 34       	cpi	r16, 0x4C	; 76
 8f4:	0c 20       	and	r0, r12
 8f6:	0b 00       	.word	0x000b	; ????
 8f8:	00 40       	sbci	r16, 0x00	; 0
 8fa:	89 82       	std	Y+1, r8	; 0x01
 8fc:	01 00       	.word	0x0001	; ????
 8fe:	11 01       	movw	r2, r2
 900:	31 13       	cpse	r19, r17
 902:	00 00       	nop
 904:	41 89       	ldd	r20, Z+17	; 0x11
 906:	82 01       	movw	r16, r4
 908:	00 11       	cpse	r16, r0
 90a:	01 95       	neg	r16
 90c:	42 0c       	add	r4, r2
 90e:	00 00       	nop
 910:	42 05       	cpc	r20, r2
 912:	00 31       	cpi	r16, 0x10	; 16
 914:	13 00       	.word	0x0013	; ????
 916:	00 43       	sbci	r16, 0x30	; 48
 918:	2e 01       	movw	r4, r28
 91a:	31 13       	cpse	r19, r17
 91c:	11 01       	movw	r2, r2
 91e:	12 01       	movw	r2, r4
 920:	40 0a       	sbc	r4, r16
 922:	64 13       	cpse	r22, r20
 924:	97 42       	sbci	r25, 0x27	; 39
 926:	0c 01       	movw	r0, r24
 928:	13 00       	.word	0x0013	; ????
 92a:	00 44       	sbci	r16, 0x40	; 64
 92c:	34 00       	.word	0x0034	; ????
 92e:	31 13       	cpse	r19, r17
 930:	02 0a       	sbc	r0, r18
 932:	00 00       	nop
 934:	45 05       	cpc	r20, r5
 936:	00 03       	mulsu	r16, r16
 938:	08 3a       	cpi	r16, 0xA8	; 168
 93a:	0b 3b       	cpi	r16, 0xBB	; 187
 93c:	0b 49       	sbci	r16, 0x9B	; 155
 93e:	13 02       	muls	r17, r19
 940:	06 00       	.word	0x0006	; ????
 942:	00 46       	sbci	r16, 0x60	; 96
 944:	34 00       	.word	0x0034	; ????
 946:	03 08       	sbc	r0, r3
 948:	3a 0b       	sbc	r19, r26
 94a:	3b 0b       	sbc	r19, r27
 94c:	49 13       	cpse	r20, r25
 94e:	02 0a       	sbc	r0, r18
 950:	00 00       	nop
 952:	47 0b       	sbc	r20, r23
 954:	01 11       	cpse	r16, r1
 956:	01 12       	cpse	r0, r17
 958:	01 01       	movw	r0, r2
 95a:	13 00       	.word	0x0013	; ????
 95c:	00 48       	sbci	r16, 0x80	; 128
 95e:	34 00       	.word	0x0034	; ????
 960:	03 0e       	add	r0, r19
 962:	3a 0b       	sbc	r19, r26
 964:	3b 0b       	sbc	r19, r27
 966:	49 13       	cpse	r20, r25
 968:	02 06       	cpc	r0, r18
 96a:	00 00       	nop
 96c:	49 1d       	adc	r20, r9
 96e:	00 31       	cpi	r16, 0x10	; 16
 970:	13 11       	cpse	r17, r3
 972:	01 12       	cpse	r0, r17
 974:	01 58       	subi	r16, 0x81	; 129
 976:	0b 59       	subi	r16, 0x9B	; 155
 978:	0b 00       	.word	0x000b	; ????
 97a:	00 4a       	sbci	r16, 0xA0	; 160
 97c:	0b 01       	movw	r0, r22
 97e:	55 06       	cpc	r5, r21
 980:	01 13       	cpse	r16, r17
 982:	00 00       	nop
 984:	4b 34       	cpi	r20, 0x4B	; 75
 986:	00 03       	mulsu	r16, r16
 988:	0e 3a       	cpi	r16, 0xAE	; 174
 98a:	0b 3b       	cpi	r16, 0xBB	; 187
 98c:	05 49       	sbci	r16, 0x95	; 149
 98e:	13 02       	muls	r17, r19
 990:	06 00       	.word	0x0006	; ????
 992:	00 4c       	sbci	r16, 0xC0	; 192
 994:	1d 01       	movw	r2, r26
 996:	31 13       	cpse	r19, r17
 998:	11 01       	movw	r2, r2
 99a:	12 01       	movw	r2, r4
 99c:	58 0b       	sbc	r21, r24
 99e:	59 05       	cpc	r21, r9
 9a0:	01 13       	cpse	r16, r17
 9a2:	00 00       	nop
 9a4:	4d 1d       	adc	r20, r13
 9a6:	00 31       	cpi	r16, 0x10	; 16
 9a8:	13 11       	cpse	r17, r3
 9aa:	01 12       	cpse	r0, r17
 9ac:	01 58       	subi	r16, 0x81	; 129
 9ae:	0b 59       	subi	r16, 0x9B	; 155
 9b0:	05 00       	.word	0x0005	; ????
 9b2:	00 4e       	sbci	r16, 0xE0	; 224
 9b4:	2e 00       	.word	0x002e	; ????
 9b6:	03 0e       	add	r0, r19
 9b8:	3a 0b       	sbc	r19, r26
 9ba:	3b 0b       	sbc	r19, r27
 9bc:	27 0c       	add	r2, r7
 9be:	49 13       	cpse	r20, r25
 9c0:	20 0b       	sbc	r18, r16
 9c2:	00 00       	nop
 9c4:	4f 2e       	mov	r4, r31
 9c6:	01 31       	cpi	r16, 0x11	; 17
 9c8:	13 11       	cpse	r17, r3
 9ca:	01 12       	cpse	r0, r17
 9cc:	01 40       	sbci	r16, 0x01	; 1
 9ce:	06 64       	ori	r16, 0x46	; 70
 9d0:	13 97       	sbiw	r26, 0x03	; 3
 9d2:	42 0c       	add	r4, r2
 9d4:	01 13       	cpse	r16, r17
 9d6:	00 00       	nop
 9d8:	50 2e       	mov	r5, r16
 9da:	01 31       	cpi	r16, 0x11	; 17
 9dc:	13 11       	cpse	r17, r3
 9de:	01 12       	cpse	r0, r17
 9e0:	01 40       	sbci	r16, 0x01	; 1
 9e2:	06 97       	sbiw	r24, 0x06	; 6
 9e4:	42 0c       	add	r4, r2
 9e6:	01 13       	cpse	r16, r17
 9e8:	00 00       	nop
 9ea:	51 1d       	adc	r21, r1
 9ec:	01 31       	cpi	r16, 0x11	; 17
 9ee:	13 11       	cpse	r17, r3
 9f0:	01 12       	cpse	r0, r17
 9f2:	01 58       	subi	r16, 0x81	; 129
 9f4:	0b 59       	subi	r16, 0x9B	; 155
 9f6:	0b 01       	movw	r0, r22
 9f8:	13 00       	.word	0x0013	; ????
 9fa:	00 52       	subi	r16, 0x20	; 32
 9fc:	34 00       	.word	0x0034	; ????
 9fe:	02 06       	cpc	r0, r18
 a00:	00 00       	nop
 a02:	53 34       	cpi	r21, 0x43	; 67
 a04:	00 00       	nop
 a06:	00 54       	subi	r16, 0x40	; 64
 a08:	1d 01       	movw	r2, r26
 a0a:	31 13       	cpse	r19, r17
 a0c:	11 01       	movw	r2, r2
 a0e:	12 01       	movw	r2, r4
 a10:	58 0b       	sbc	r21, r24
 a12:	59 0b       	sbc	r21, r25
 a14:	00 00       	nop
 a16:	55 2e       	mov	r5, r21
 a18:	00 47       	sbci	r16, 0x70	; 112
 a1a:	13 20       	and	r1, r3
 a1c:	0b 00       	.word	0x000b	; ????
 a1e:	00 56       	subi	r16, 0x60	; 96
 a20:	2e 01       	movw	r4, r28
 a22:	3f 0c       	add	r3, r15
 a24:	03 0e       	add	r0, r19
 a26:	3a 0b       	sbc	r19, r26
 a28:	3b 0b       	sbc	r19, r27
 a2a:	27 0c       	add	r2, r7
 a2c:	11 01       	movw	r2, r2
 a2e:	12 01       	movw	r2, r4
 a30:	40 06       	cpc	r4, r16
 a32:	97 42       	sbci	r25, 0x27	; 39
 a34:	0c 01       	movw	r0, r24
 a36:	13 00       	.word	0x0013	; ????
 a38:	00 57       	subi	r16, 0x70	; 112
 a3a:	2e 01       	movw	r4, r28
 a3c:	3f 0c       	add	r3, r15
 a3e:	03 0e       	add	r0, r19
 a40:	3a 0b       	sbc	r19, r26
 a42:	3b 0b       	sbc	r19, r27
 a44:	27 0c       	add	r2, r7
 a46:	49 13       	cpse	r20, r25
 a48:	87 01       	movw	r16, r14
 a4a:	0c 11       	cpse	r16, r12
 a4c:	01 12       	cpse	r0, r17
 a4e:	01 40       	sbci	r16, 0x01	; 1
 a50:	0a 97       	sbiw	r24, 0x0a	; 10
 a52:	42 0c       	add	r4, r2
 a54:	01 13       	cpse	r16, r17
 a56:	00 00       	nop
 a58:	58 89       	ldd	r21, Y+16	; 0x10
 a5a:	82 01       	movw	r16, r4
 a5c:	00 11       	cpse	r16, r0
 a5e:	01 00       	.word	0x0001	; ????
 a60:	00 59       	subi	r16, 0x90	; 144
 a62:	89 82       	std	Y+1, r8	; 0x01
 a64:	01 01       	movw	r0, r2
 a66:	11 01       	movw	r2, r2
 a68:	31 13       	cpse	r19, r17
 a6a:	01 13       	cpse	r16, r17
 a6c:	00 00       	nop
 a6e:	5a 2e       	mov	r5, r26
 a70:	01 03       	mulsu	r16, r17
 a72:	0e 27       	eor	r16, r30
 a74:	0c 34       	cpi	r16, 0x4C	; 76
 a76:	0c 11       	cpse	r16, r12
 a78:	01 12       	cpse	r0, r17
 a7a:	01 40       	sbci	r16, 0x01	; 1
 a7c:	0a 97       	sbiw	r24, 0x0a	; 10
 a7e:	42 0c       	add	r4, r2
 a80:	01 13       	cpse	r16, r17
 a82:	00 00       	nop
 a84:	5b 34       	cpi	r21, 0x4B	; 75
 a86:	00 1c       	adc	r0, r0
 a88:	0b 00       	.word	0x000b	; ????
 a8a:	00 5c       	subi	r16, 0xC0	; 192
 a8c:	34 00       	.word	0x0034	; ????
 a8e:	02 0a       	sbc	r0, r18
 a90:	00 00       	nop
 a92:	5d 1d       	adc	r21, r13
 a94:	01 31       	cpi	r16, 0x11	; 17
 a96:	13 52       	subi	r17, 0x23	; 35
 a98:	01 55       	subi	r16, 0x51	; 81
 a9a:	06 58       	subi	r16, 0x86	; 134
 a9c:	0b 59       	subi	r16, 0x9B	; 155
 a9e:	0b 00       	.word	0x000b	; ????
 aa0:	00 00       	nop
 aa2:	01 11       	cpse	r16, r1
 aa4:	00 10       	cpse	r0, r0
 aa6:	06 11       	cpse	r16, r6
 aa8:	01 12       	cpse	r0, r17
 aaa:	01 03       	mulsu	r16, r17
 aac:	08 1b       	sub	r16, r24
 aae:	08 25       	eor	r16, r8
 ab0:	08 13       	cpse	r16, r24
 ab2:	05 00       	.word	0x0005	; ????
 ab4:	00 00       	nop
 ab6:	01 11       	cpse	r16, r1
 ab8:	00 10       	cpse	r0, r0
 aba:	06 11       	cpse	r16, r6
 abc:	01 12       	cpse	r0, r17
 abe:	01 03       	mulsu	r16, r17
 ac0:	08 1b       	sub	r16, r24
 ac2:	08 25       	eor	r16, r8
 ac4:	08 13       	cpse	r16, r24
 ac6:	05 00       	.word	0x0005	; ????
 ac8:	00 00       	nop
 aca:	01 11       	cpse	r16, r1
 acc:	00 10       	cpse	r0, r0
 ace:	06 11       	cpse	r16, r6
 ad0:	01 12       	cpse	r0, r17
 ad2:	01 03       	mulsu	r16, r17
 ad4:	08 1b       	sub	r16, r24
 ad6:	08 25       	eor	r16, r8
 ad8:	08 13       	cpse	r16, r24
 ada:	05 00       	.word	0x0005	; ????
 adc:	00 00       	nop
 ade:	01 11       	cpse	r16, r1
 ae0:	00 10       	cpse	r0, r0
 ae2:	06 11       	cpse	r16, r6
 ae4:	01 12       	cpse	r0, r17
 ae6:	01 03       	mulsu	r16, r17
 ae8:	08 1b       	sub	r16, r24
 aea:	08 25       	eor	r16, r8
 aec:	08 13       	cpse	r16, r24
 aee:	05 00       	.word	0x0005	; ????
 af0:	00 00       	nop
 af2:	01 11       	cpse	r16, r1
 af4:	00 10       	cpse	r0, r0
 af6:	06 11       	cpse	r16, r6
 af8:	01 12       	cpse	r0, r17
 afa:	01 03       	mulsu	r16, r17
 afc:	08 1b       	sub	r16, r24
 afe:	08 25       	eor	r16, r8
 b00:	08 13       	cpse	r16, r24
 b02:	05 00       	.word	0x0005	; ????
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
   0:	16 00       	.word	0x0016	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	10 00       	.word	0x0010	; ????
   8:	00 00       	nop
   a:	02 01       	movw	r0, r4
   c:	fb 0e       	add	r15, r27
   e:	0a 00       	.word	0x000a	; ????
  10:	01 01       	movw	r0, r2
  12:	01 01       	movw	r0, r2
  14:	00 00       	nop
  16:	00 01       	movw	r0, r0
  18:	00 00       	nop
  1a:	c3 07       	cpc	r28, r19
  1c:	00 00       	nop
  1e:	02 00       	.word	0x0002	; ????
  20:	07 03       	mulsu	r16, r23
  22:	00 00       	nop
  24:	02 01       	movw	r0, r4
  26:	fb 0e       	add	r15, r27
  28:	0a 00       	.word	0x000a	; ????
  2a:	01 01       	movw	r0, r2
  2c:	01 01       	movw	r0, r2
  2e:	00 00       	nop
  30:	00 01       	movw	r0, r0
  32:	43 3a       	cpi	r20, 0xA3	; 163
  34:	5c 50       	subi	r21, 0x0C	; 12
  36:	72 6f       	ori	r23, 0xF2	; 242
  38:	67 72       	andi	r22, 0x27	; 39
  3a:	61 6d       	ori	r22, 0xD1	; 209
  3c:	20 46       	sbci	r18, 0x60	; 96
  3e:	69 6c       	ori	r22, 0xC9	; 201
  40:	65 73       	andi	r22, 0x35	; 53
  42:	20 28       	or	r2, r0
  44:	78 38       	cpi	r23, 0x88	; 136
  46:	36 29       	or	r19, r6
  48:	5c 41       	sbci	r21, 0x1C	; 28
  4a:	72 64       	ori	r23, 0x42	; 66
  4c:	75 69       	ori	r23, 0x95	; 149
  4e:	6e 6f       	ori	r22, 0xFE	; 254
  50:	5c 68       	ori	r21, 0x8C	; 140
  52:	61 72       	andi	r22, 0x21	; 33
  54:	64 77       	andi	r22, 0x74	; 116
  56:	61 72       	andi	r22, 0x21	; 33
  58:	65 5c       	subi	r22, 0xC5	; 197
  5a:	61 72       	andi	r22, 0x21	; 33
  5c:	64 75       	andi	r22, 0x54	; 84
  5e:	69 6e       	ori	r22, 0xE9	; 233
  60:	6f 5c       	subi	r22, 0xCF	; 207
  62:	61 76       	andi	r22, 0x61	; 97
  64:	72 5c       	subi	r23, 0xC2	; 194
  66:	63 6f       	ori	r22, 0xF3	; 243
  68:	72 65       	ori	r23, 0x52	; 82
  6a:	73 5c       	subi	r23, 0xC3	; 195
  6c:	61 72       	andi	r22, 0x21	; 33
  6e:	64 75       	andi	r22, 0x54	; 84
  70:	69 6e       	ori	r22, 0xE9	; 233
  72:	6f 00       	.word	0x006f	; ????
  74:	63 3a       	cpi	r22, 0xA3	; 163
  76:	5c 70       	andi	r21, 0x0C	; 12
  78:	72 6f       	ori	r23, 0xF2	; 242
  7a:	67 72       	andi	r22, 0x27	; 39
  7c:	61 6d       	ori	r22, 0xD1	; 209
  7e:	20 66       	ori	r18, 0x60	; 96
  80:	69 6c       	ori	r22, 0xC9	; 201
  82:	65 73       	andi	r22, 0x35	; 53
  84:	20 28       	or	r2, r0
  86:	78 38       	cpi	r23, 0x88	; 136
  88:	36 29       	or	r19, r6
  8a:	5c 61       	ori	r21, 0x1C	; 28
  8c:	72 64       	ori	r23, 0x42	; 66
  8e:	75 69       	ori	r23, 0x95	; 149
  90:	6e 6f       	ori	r22, 0xFE	; 254
  92:	5c 68       	ori	r21, 0x8C	; 140
  94:	61 72       	andi	r22, 0x21	; 33
  96:	64 77       	andi	r22, 0x74	; 116
  98:	61 72       	andi	r22, 0x21	; 33
  9a:	65 5c       	subi	r22, 0xC5	; 197
  9c:	74 6f       	ori	r23, 0xF4	; 244
  9e:	6f 6c       	ori	r22, 0xCF	; 207
  a0:	73 5c       	subi	r23, 0xC3	; 195
  a2:	61 76       	andi	r22, 0x61	; 97
  a4:	72 5c       	subi	r23, 0xC2	; 194
  a6:	61 76       	andi	r22, 0x61	; 97
  a8:	72 5c       	subi	r23, 0xC2	; 194
  aa:	69 6e       	ori	r22, 0xE9	; 233
  ac:	63 6c       	ori	r22, 0xC3	; 195
  ae:	75 64       	ori	r23, 0x45	; 69
  b0:	65 5c       	subi	r22, 0xC5	; 197
  b2:	75 74       	andi	r23, 0x45	; 69
  b4:	69 6c       	ori	r22, 0xC9	; 201
  b6:	00 43       	sbci	r16, 0x30	; 48
  b8:	3a 5c       	subi	r19, 0xCA	; 202
  ba:	55 73       	andi	r21, 0x35	; 53
  bc:	65 72       	andi	r22, 0x25	; 37
  be:	73 5c       	subi	r23, 0xC3	; 195
  c0:	52 79       	andi	r21, 0x92	; 146
  c2:	61 6e       	ori	r22, 0xE1	; 225
  c4:	79 75       	andi	r23, 0x59	; 89
  c6:	32 2d       	mov	r19, r2
  c8:	61 64       	ori	r22, 0x41	; 65
  ca:	6d 69       	ori	r22, 0x9D	; 157
  cc:	6e 5c       	subi	r22, 0xCE	; 206
  ce:	44 65       	ori	r20, 0x54	; 84
  d0:	73 6b       	ori	r23, 0xB3	; 179
  d2:	74 6f       	ori	r23, 0xF4	; 244
  d4:	70 5c       	subi	r23, 0xC0	; 192
  d6:	42 55       	subi	r20, 0x52	; 82
  d8:	20 50       	subi	r18, 0x00	; 0
  da:	48 44       	sbci	r20, 0x48	; 72
  dc:	5c 53       	subi	r21, 0x3C	; 60
  de:	70 72       	andi	r23, 0x20	; 32
  e0:	69 6e       	ori	r22, 0xE9	; 233
  e2:	67 20       	and	r6, r7
  e4:	32 30       	cpi	r19, 0x02	; 2
  e6:	5c 50       	subi	r21, 0x0C	; 12
  e8:	46 50       	subi	r20, 0x06	; 6
  ea:	5c 41       	sbci	r21, 0x1C	; 28
  ec:	72 64       	ori	r23, 0x42	; 66
  ee:	75 69       	ori	r23, 0x95	; 149
  f0:	6e 6f       	ori	r22, 0xFE	; 254
  f2:	41 73       	andi	r20, 0x31	; 49
  f4:	73 65       	ori	r23, 0x53	; 83
  f6:	6d 62       	ori	r22, 0x2D	; 45
  f8:	6c 79       	andi	r22, 0x9C	; 156
  fa:	50 61       	ori	r21, 0x10	; 16
  fc:	72 73       	andi	r23, 0x32	; 50
  fe:	65 72       	andi	r22, 0x25	; 37
 100:	5c 50       	subi	r21, 0x0C	; 12
 102:	61 72       	andi	r22, 0x21	; 33
 104:	73 65       	ori	r23, 0x53	; 83
 106:	72 49       	sbci	r23, 0x92	; 146
 108:	6e 70       	andi	r22, 0x0E	; 14
 10a:	75 74       	andi	r23, 0x45	; 69
 10c:	46 69       	ori	r20, 0x96	; 150
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	6c 65       	ori	r22, 0x5C	; 92
 110:	73 5c       	subi	r23, 0xC3	; 195
 112:	52 61       	ori	r21, 0x12	; 18
	uint8_t bit = digitalPinToBitMask(pin);
 114:	77 41       	sbci	r23, 0x17	; 23
 116:	72 64       	ori	r23, 0x42	; 66
 118:	75 69       	ori	r23, 0x95	; 149
	uint8_t port = digitalPinToPort(pin);
 11a:	6e 6f       	ori	r22, 0xFE	; 254
 11c:	46 69       	ori	r20, 0x96	; 150
 11e:	6c 65       	ori	r22, 0x5C	; 92
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	73 5c       	subi	r23, 0xC3	; 195
 122:	56 32       	cpi	r21, 0x26	; 38

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	5c 70       	andi	r21, 0x0C	; 12
 126:	72 65       	ori	r23, 0x52	; 82
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	4d 75       	andi	r20, 0x5D	; 93
 12a:	6c 74       	andi	r22, 0x4C	; 76
 12c:	00 63       	ori	r16, 0x30	; 48
 12e:	3a 5c       	subi	r19, 0xCA	; 202
 130:	70 72       	andi	r23, 0x20	; 32
 132:	6f 67       	ori	r22, 0x7F	; 127
 134:	72 61       	ori	r23, 0x12	; 18

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	6d 20       	and	r6, r13
 138:	66 69       	ori	r22, 0x96	; 150
 13a:	6c 65       	ori	r22, 0x5C	; 92
 13c:	73 20       	and	r7, r3
 13e:	28 78       	andi	r18, 0x88	; 136
 140:	38 36       	cpi	r19, 0x68	; 104
 142:	29 5c       	subi	r18, 0xC9	; 201

	uint8_t oldSREG = SREG;
 144:	61 72       	andi	r22, 0x21	; 33
	cli();
 146:	64 75       	andi	r22, 0x54	; 84

	if (val == LOW) {
		*out &= ~bit;
 148:	69 6e       	ori	r22, 0xE9	; 233
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	6f 5c       	subi	r22, 0xCF	; 207
 14c:	68 61       	ori	r22, 0x18	; 24
		*out &= ~bit;
 14e:	72 64       	ori	r23, 0x42	; 66
 150:	77 61       	ori	r23, 0x17	; 23
	} else {
		*out |= bit;
 152:	72 65       	ori	r23, 0x52	; 82
	}

	SREG = oldSREG;
 154:	5c 74       	andi	r21, 0x4C	; 76
}
 156:	6f 6f       	ori	r22, 0xFF	; 255
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	6c 73       	andi	r22, 0x3C	; 60
 15a:	5c 61       	ori	r21, 0x1C	; 28
 15c:	76 72       	andi	r23, 0x26	; 38
 15e:	5c 61       	ori	r21, 0x1C	; 28
 160:	76 72       	andi	r23, 0x26	; 38
 162:	5c 69       	ori	r21, 0x9C	; 156
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	6e 63       	ori	r22, 0x3E	; 62
 166:	6c 75       	andi	r22, 0x5C	; 92
 168:	64 65       	ori	r22, 0x54	; 84
 16a:	00 63       	ori	r16, 0x30	; 48
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	3a 5c       	subi	r19, 0xCA	; 202
 16e:	70 72       	andi	r23, 0x20	; 32
 170:	6f 67       	ori	r22, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	72 61       	ori	r23, 0x12	; 18
 174:	6d 20       	and	r6, r13
 176:	66 69       	ori	r22, 0x96	; 150
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	6c 65       	ori	r22, 0x5C	; 92
 17a:	73 20       	and	r7, r3
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17c:	28 78       	andi	r18, 0x88	; 136
 17e:	38 36       	cpi	r19, 0x68	; 104
 180:	29 5c       	subi	r18, 0xC9	; 201
 182:	61 72       	andi	r22, 0x21	; 33
 184:	64 75       	andi	r22, 0x54	; 84
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	69 6e       	ori	r22, 0xE9	; 233
 188:	6f 5c       	subi	r22, 0xCF	; 207
 18a:	68 61       	ori	r22, 0x18	; 24
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	72 64       	ori	r23, 0x42	; 66
 18e:	77 61       	ori	r23, 0x17	; 23
 190:	72 65       	ori	r23, 0x52	; 82
 192:	5c 74       	andi	r21, 0x4C	; 76
 194:	6f 6f       	ori	r22, 0xFF	; 255
 196:	6c 73       	andi	r22, 0x3C	; 60
 198:	5c 61       	ori	r21, 0x1C	; 28
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	76 72       	andi	r23, 0x26	; 38
 19c:	5c 6c       	ori	r21, 0xCC	; 204

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	69 62       	ori	r22, 0x29	; 41
 1a0:	5c 67       	ori	r21, 0x7C	; 124
 1a2:	63 63       	ori	r22, 0x33	; 51
 1a4:	5c 61       	ori	r21, 0x1C	; 28
 1a6:	76 72       	andi	r23, 0x26	; 38
 1a8:	5c 37       	cpi	r21, 0x7C	; 124
 1aa:	2e 33       	cpi	r18, 0x3E	; 62
 1ac:	2e 30       	cpi	r18, 0x0E	; 14
 1ae:	5c 69       	ori	r21, 0x9C	; 156
 1b0:	6e 63       	ori	r22, 0x3E	; 62
 1b2:	6c 75       	andi	r22, 0x5C	; 92
 1b4:	64 65       	ori	r22, 0x54	; 84
 1b6:	00 43       	sbci	r16, 0x30	; 48
 1b8:	3a 5c       	subi	r19, 0xCA	; 202
 1ba:	50 72       	andi	r21, 0x20	; 32
 1bc:	6f 67       	ori	r22, 0x7F	; 127
 1be:	72 61       	ori	r23, 0x12	; 18
 1c0:	6d 20       	and	r6, r13
 1c2:	46 69       	ori	r20, 0x96	; 150
  size_t n = 0;
  while (size--) {
 1c4:	6c 65       	ori	r22, 0x5C	; 92
 1c6:	73 20       	and	r7, r3
 1c8:	28 78       	andi	r18, 0x88	; 136
    if (write(*buffer++)) n++;
 1ca:	38 36       	cpi	r19, 0x68	; 104
 1cc:	29 5c       	subi	r18, 0xC9	; 201
 1ce:	41 72       	andi	r20, 0x21	; 33
 1d0:	64 75       	andi	r22, 0x54	; 84
 1d2:	69 6e       	ori	r22, 0xE9	; 233
 1d4:	6f 5c       	subi	r22, 0xCF	; 207
 1d6:	68 61       	ori	r22, 0x18	; 24
 1d8:	72 64       	ori	r23, 0x42	; 66
 1da:	77 61       	ori	r23, 0x17	; 23
 1dc:	72 65       	ori	r23, 0x52	; 82
 1de:	5c 61       	ori	r21, 0x1C	; 28
    else break;
  }
  return n;
}
 1e0:	72 64       	ori	r23, 0x42	; 66
 1e2:	75 69       	ori	r23, 0x95	; 149
 1e4:	6e 6f       	ori	r22, 0xFE	; 254
 1e6:	5c 61       	ori	r21, 0x1C	; 28
 1e8:	76 72       	andi	r23, 0x26	; 38
 1ea:	5c 76       	andi	r21, 0x6C	; 108
 1ec:	61 72       	andi	r22, 0x21	; 33
 1ee:	69 61       	ori	r22, 0x19	; 25
 1f0:	6e 74       	andi	r22, 0x4E	; 78
 1f2:	73 5c       	subi	r23, 0xC3	; 195
 1f4:	73 74       	andi	r23, 0x43	; 67
 1f6:	61 6e       	ori	r22, 0xE1	; 225
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	64 61       	ori	r22, 0x14	; 20
 1fa:	72 64       	ori	r23, 0x42	; 66
    tail = _tx_buffer_tail;
 1fc:	00 00       	nop
 1fe:	77 69       	ori	r23, 0x97	; 151
 200:	72 69       	ori	r23, 0x92	; 146
 202:	6e 67       	ori	r22, 0x7E	; 126
 204:	5f 64       	ori	r21, 0x4F	; 79
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	69 67       	ori	r22, 0x79	; 121
 208:	69 74       	andi	r22, 0x49	; 73
 20a:	61 6c       	ori	r22, 0xC1	; 193
 20c:	2e 63       	ori	r18, 0x3E	; 62
 20e:	00 01       	movw	r0, r0
 210:	00 00       	nop
  return tail - head - 1;
 212:	50 72       	andi	r21, 0x20	; 32
}
 214:	69 6e       	ori	r22, 0xE9	; 233
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	74 2e       	mov	r7, r20
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	63 70       	andi	r22, 0x03	; 3
 21a:	70 00       	.word	0x0070	; ????
 21c:	01 00       	.word	0x0001	; ????
 21e:	00 48       	sbci	r16, 0x80	; 128
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	61 72       	andi	r22, 0x21	; 33
 222:	64 77       	andi	r22, 0x74	; 116
 224:	61 72       	andi	r22, 0x21	; 33
 226:	65 53       	subi	r22, 0x35	; 53
 228:	65 72       	andi	r22, 0x25	; 37
 22a:	69 61       	ori	r22, 0x19	; 25
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 22c:	6c 2e       	mov	r6, r28
 22e:	63 70       	andi	r22, 0x03	; 3
 230:	70 00       	.word	0x0070	; ????
 232:	01 00       	.word	0x0001	; ????
    return c;
 234:	00 48       	sbci	r16, 0x80	; 128
 236:	61 72       	andi	r22, 0x21	; 33

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 238:	64 77       	andi	r22, 0x74	; 116
 23a:	61 72       	andi	r22, 0x21	; 33
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 23c:	65 53       	subi	r22, 0x35	; 53
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 23e:	65 72       	andi	r22, 0x25	; 37
  if (_rx_buffer_head == _rx_buffer_tail) {
 240:	69 61       	ori	r22, 0x19	; 25
 242:	6c 30       	cpi	r22, 0x0C	; 12
 244:	2e 63       	ori	r18, 0x3E	; 62
 246:	70 70       	andi	r23, 0x00	; 0
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 248:	00 01       	movw	r0, r0
 24a:	00 00       	nop
 24c:	61 74       	andi	r22, 0x41	; 65
 24e:	6f 6d       	ori	r22, 0xDF	; 223
 250:	69 63       	ori	r22, 0x39	; 57
 252:	2e 68       	ori	r18, 0x8E	; 142
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 254:	00 02       	muls	r16, r16
 256:	00 00       	nop
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 258:	50 72       	andi	r21, 0x20	; 32
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 25a:	69 6e       	ori	r22, 0xE9	; 233
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 25c:	74 2e       	mov	r7, r20
 25e:	68 00       	.word	0x0068	; ????
 260:	01 00       	.word	0x0001	; ????
 262:	00 77       	andi	r16, 0x70	; 112
 264:	69 72       	andi	r22, 0x29	; 41
 266:	69 6e       	ori	r22, 0xE9	; 233
 268:	67 2e       	mov	r6, r23
 26a:	63 00       	.word	0x0063	; ????
}
 26c:	01 00       	.word	0x0001	; ????
 26e:	00 6d       	ori	r16, 0xD0	; 208
 270:	61 69       	ori	r22, 0x91	; 145
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 272:	6e 2e       	mov	r6, r30
 274:	63 70       	andi	r22, 0x03	; 3
 276:	70 00       	.word	0x0070	; ????
 278:	01 00       	.word	0x0001	; ????
 27a:	00 70       	andi	r16, 0x00	; 0
 27c:	72 65       	ori	r23, 0x52	; 82
 27e:	4d 75       	andi	r20, 0x5D	; 93
 280:	6c 74       	andi	r22, 0x4C	; 76
}
 282:	2e 69       	ori	r18, 0x9E	; 158
 284:	6e 6f       	ori	r22, 0xFE	; 254
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 286:	00 03       	mulsu	r16, r16
 288:	00 00       	nop
 28a:	53 74       	andi	r21, 0x43	; 67
 28c:	72 65       	ori	r23, 0x52	; 82
 28e:	61 6d       	ori	r22, 0xD1	; 209
 290:	2e 68       	ori	r18, 0x8E	; 142
 292:	00 01       	movw	r0, r0
 294:	00 00       	nop
 296:	48 61       	ori	r20, 0x18	; 24
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 298:	72 64       	ori	r23, 0x42	; 66
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 29a:	77 61       	ori	r23, 0x17	; 23
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 29c:	72 65       	ori	r23, 0x52	; 82
 29e:	53 65       	ori	r21, 0x53	; 83
 2a0:	72 69       	ori	r23, 0x92	; 146
 2a2:	61 6c       	ori	r22, 0xC1	; 193
 2a4:	5f 70       	andi	r21, 0x0F	; 15
 2a6:	72 69       	ori	r23, 0x92	; 146
 2a8:	76 61       	ori	r23, 0x16	; 22
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2aa:	74 65       	ori	r23, 0x54	; 84
 2ac:	2e 68       	ori	r18, 0x8E	; 142
 2ae:	00 01       	movw	r0, r0
 2b0:	00 00       	nop
 2b2:	53 74       	andi	r21, 0x43	; 67
 2b4:	72 65       	ori	r23, 0x52	; 82

  *_udr = c;
 2b6:	61 6d       	ori	r22, 0xD1	; 209
 2b8:	2e 68       	ori	r18, 0x8E	; 142
 2ba:	00 01       	movw	r0, r0
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 2bc:	00 00       	nop
 2be:	73 74       	andi	r23, 0x43	; 67
 2c0:	64 69       	ori	r22, 0x94	; 148
 2c2:	6e 74       	andi	r22, 0x4E	; 78
 2c4:	2e 68       	ori	r18, 0x8E	; 142
 2c6:	00 04       	cpc	r0, r0
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 2c8:	00 00       	nop
 2ca:	48 61       	ori	r20, 0x18	; 24
 2cc:	72 64       	ori	r23, 0x42	; 66
 2ce:	77 61       	ori	r23, 0x17	; 23
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 2d0:	72 65       	ori	r23, 0x52	; 82
 2d2:	53 65       	ori	r21, 0x53	; 83
 2d4:	72 69       	ori	r23, 0x92	; 146
 2d6:	61 6c       	ori	r22, 0xC1	; 193
 2d8:	2e 68       	ori	r18, 0x8E	; 142
 2da:	00 01       	movw	r0, r0
  }
}
 2dc:	00 00       	nop
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 2de:	48 61       	ori	r20, 0x18	; 24
 2e0:	72 64       	ori	r23, 0x42	; 66
 2e2:	77 61       	ori	r23, 0x17	; 23
 2e4:	72 65       	ori	r23, 0x52	; 82
 2e6:	53 65       	ori	r21, 0x53	; 83
 2e8:	72 69       	ori	r23, 0x92	; 146
 2ea:	61 6c       	ori	r22, 0xC1	; 193
  _written = true;
 2ec:	2e 68       	ori	r18, 0x8E	; 142
 2ee:	00 01       	movw	r0, r0
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 2f0:	00 00       	nop
 2f2:	73 74       	andi	r23, 0x43	; 67
 2f4:	64 64       	ori	r22, 0x44	; 68
 2f6:	65 66       	ori	r22, 0x65	; 101
 2f8:	2e 68       	ori	r18, 0x8E	; 142
 2fa:	00 05       	cpc	r16, r0
 2fc:	00 00       	nop
 2fe:	41 72       	andi	r20, 0x21	; 33
 300:	64 75       	andi	r22, 0x54	; 84
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 302:	69 6e       	ori	r22, 0xE9	; 233
 304:	6f 2e       	mov	r6, r31
      *_udr = c;
 306:	68 00       	.word	0x0068	; ????
 308:	01 00       	.word	0x0001	; ????
 30a:	00 57       	subi	r16, 0x70	; 112
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 30c:	4d 61       	ori	r20, 0x1D	; 29
 30e:	74 68       	ori	r23, 0x84	; 132
 310:	2e 63       	ori	r18, 0x3E	; 62
 312:	70 70       	andi	r23, 0x00	; 0
 314:	00 01       	movw	r0, r0
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 316:	00 00       	nop
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 318:	70 69       	ori	r23, 0x90	; 144
  }
  
  return 1;
}
 31a:	6e 73       	andi	r22, 0x3E	; 62
 31c:	5f 61       	ori	r21, 0x1F	; 31
 31e:	72 64       	ori	r23, 0x42	; 66
 320:	75 69       	ori	r23, 0x95	; 149
 322:	6e 6f       	ori	r22, 0xFE	; 254
 324:	2e 68       	ori	r18, 0x8E	; 142
 326:	00 06       	cpc	r0, r16
 328:	00 00       	nop
 32a:	00 00       	nop
 32c:	05 02       	muls	r16, r21
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 32e:	0e 01       	movw	r0, r28
 330:	00 00       	nop
 332:	03 89       	ldd	r16, Z+19	; 0x13
 334:	01 01       	movw	r0, r2
 336:	03 02       	muls	r16, r19
 338:	09 00       	.word	0x0009	; ????
 33a:	00 01       	movw	r0, r0
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 33c:	03 01       	movw	r0, r6
 33e:	09 06       	cpc	r0, r25
 340:	00 01       	movw	r0, r0
    if (bit_is_clear(SREG, SREG_I)) {
 342:	03 01       	movw	r0, r6
 344:	09 06       	cpc	r0, r25
 346:	00 01       	movw	r0, r0
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 348:	03 03       	mulsu	r16, r19
 34a:	09 06       	cpc	r0, r25
 34c:	00 01       	movw	r0, r0
 34e:	03 04       	cpc	r0, r3
 350:	09 04       	cpc	r0, r9
	_tx_udr_empty_irq();
 352:	00 01       	movw	r0, r0
 354:	03 b8       	out	0x03, r0	; 3
 356:	7f 09       	sbc	r23, r15
 358:	04 00       	.word	0x0004	; ????
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 35a:	01 03       	mulsu	r16, r17
 35c:	ca 00       	.word	0x00ca	; ????
 35e:	09 0e       	add	r0, r25
 360:	00 01       	movw	r0, r0
 362:	03 02       	muls	r16, r19
 364:	09 0e       	add	r0, r25
 366:	00 01       	movw	r0, r0

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 368:	03 01       	movw	r0, r6
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 36a:	09 02       	muls	r16, r25
    _tx_buffer_head = i;
 36c:	00 01       	movw	r0, r0
    sbi(*_ucsrb, UDRIE0);
 36e:	03 03       	mulsu	r16, r19
 370:	09 02       	muls	r16, r25
 372:	00 01       	movw	r0, r0
 374:	03 7f       	andi	r16, 0xF3	; 243
 376:	09 02       	muls	r16, r25
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 378:	00 01       	movw	r0, r0
 37a:	03 01       	movw	r0, r6
 37c:	09 04       	cpc	r0, r9
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 37e:	00 01       	movw	r0, r0
 380:	03 02       	muls	r16, r19
 382:	09 04       	cpc	r0, r9
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 384:	00 01       	movw	r0, r0
 386:	03 03       	mulsu	r16, r19
 388:	09 02       	muls	r16, r25
 38a:	00 01       	movw	r0, r0
 38c:	03 01       	movw	r0, r6
 38e:	09 02       	muls	r16, r25
 390:	00 01       	movw	r0, r0
 392:	03 aa       	std	Z+51, r0	; 0x33
 394:	7f 09       	sbc	r23, r15
 396:	02 00       	.word	0x0002	; ????
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 398:	01 03       	mulsu	r16, r17
 39a:	06 09       	sbc	r16, r6
 39c:	0c 00       	.word	0x000c	; ????
 39e:	01 03       	mulsu	r16, r17
 3a0:	7d 09       	sbc	r23, r13
 3a2:	08 00       	.word	0x0008	; ????
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 3a4:	01 03       	mulsu	r16, r17
 3a6:	03 09       	sbc	r16, r3
 3a8:	06 00       	.word	0x0006	; ????
	  _tx_udr_empty_irq();
 3aa:	01 03       	mulsu	r16, r17
 3ac:	0b 09       	sbc	r16, r11
 3ae:	06 00       	.word	0x0006	; ????
 3b0:	01 03       	mulsu	r16, r17
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3b2:	04 09       	sbc	r16, r4
 3b4:	04 00       	.word	0x0004	; ????
 3b6:	01 03       	mulsu	r16, r17
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 3b8:	03 09       	sbc	r16, r3
 3ba:	0a 00       	.word	0x000a	; ????
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 3bc:	01 03       	mulsu	r16, r17
 3be:	03 09       	sbc	r16, r3
 3c0:	06 00       	.word	0x0006	; ????
 3c2:	01 03       	mulsu	r16, r17
 3c4:	37 09       	sbc	r19, r7
 3c6:	0e 00       	.word	0x000e	; ????
 3c8:	01 04       	cpc	r0, r1
 3ca:	02 03       	mulsu	r16, r18
 3cc:	84 7f       	andi	r24, 0xF4	; 244
 3ce:	09 04       	cpc	r0, r9
 3d0:	00 01       	movw	r0, r0
 3d2:	03 00       	.word	0x0003	; ????
 3d4:	09 1e       	adc	r0, r25
 3d6:	00 01       	movw	r0, r0
 3d8:	03 02       	muls	r16, r19
 3da:	09 08       	sbc	r0, r9
 3dc:	00 01       	movw	r0, r0
 3de:	03 01       	movw	r0, r6
 3e0:	09 06       	cpc	r0, r25
 3e2:	00 01       	movw	r0, r0
 3e4:	03 04       	cpc	r0, r3
 3e6:	09 16       	cp	r0, r25
{
  size_t n = print(c);
  n += println();
  return n;
}
 3e8:	00 01       	movw	r0, r0
 3ea:	04 03       	mulsu	r16, r20
 3ec:	03 97       	sbiw	r24, 0x03	; 3
 3ee:	01 09       	sbc	r16, r1
 3f0:	18 00       	.word	0x0018	; ????
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3f2:	01 03       	mulsu	r16, r17
 3f4:	05 09       	sbc	r16, r5
 3f6:	00 00       	nop
 3f8:	01 03       	mulsu	r16, r17
 3fa:	01 09       	sbc	r16, r1
 3fc:	04 00       	.word	0x0004	; ????
 3fe:	01 03       	mulsu	r16, r17
 400:	02 09       	sbc	r16, r2
 402:	0a 00       	.word	0x000a	; ????
 404:	01 03       	mulsu	r16, r17
 406:	01 09       	sbc	r16, r1
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 408:	0c 00       	.word	0x000c	; ????
 40a:	01 03       	mulsu	r16, r17
 40c:	01 09       	sbc	r16, r1
 40e:	02 00       	.word	0x0002	; ????
 410:	01 03       	mulsu	r16, r17
 412:	6a 09       	sbc	r22, r10
 414:	02 00       	.word	0x0002	; ????
 416:	01 03       	mulsu	r16, r17
	unsigned char f = timer0_fract;
 418:	02 09       	sbc	r16, r2
 41a:	02 00       	.word	0x0002	; ????

	m += MILLIS_INC;
	f += FRACT_INC;
 41c:	01 03       	mulsu	r16, r17
 41e:	03 09       	sbc	r16, r3
	if (f >= FRACT_MAX) {
 420:	08 00       	.word	0x0008	; ????
 422:	01 03       	mulsu	r16, r17
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 424:	01 09       	sbc	r16, r1
 426:	0c 00       	.word	0x000c	; ????
 428:	01 03       	mulsu	r16, r17
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 42a:	01 09       	sbc	r16, r1
 42c:	08 00       	.word	0x0008	; ????
	timer0_millis = m;
 42e:	01 03       	mulsu	r16, r17
 430:	7c 09       	sbc	r23, r12
 432:	04 00       	.word	0x0004	; ????
 434:	01 03       	mulsu	r16, r17
 436:	06 09       	sbc	r16, r6
 438:	04 00       	.word	0x0004	; ????
 43a:	01 03       	mulsu	r16, r17
 43c:	6e 09       	sbc	r22, r14
	timer0_overflow_count++;
 43e:	02 00       	.word	0x0002	; ????
 440:	01 03       	mulsu	r16, r17
 442:	01 09       	sbc	r16, r1
 444:	02 00       	.word	0x0002	; ????
 446:	01 03       	mulsu	r16, r17
 448:	03 09       	sbc	r16, r3
 44a:	08 00       	.word	0x0008	; ????
 44c:	01 03       	mulsu	r16, r17
 44e:	7e 09       	sbc	r23, r14
 450:	0c 00       	.word	0x000c	; ????
 452:	01 03       	mulsu	r16, r17
 454:	04 09       	sbc	r16, r4
 456:	04 00       	.word	0x0004	; ????
 458:	01 03       	mulsu	r16, r17
 45a:	75 09       	sbc	r23, r5
 45c:	02 00       	.word	0x0002	; ????
 45e:	01 03       	mulsu	r16, r17
 460:	01 09       	sbc	r16, r1
 462:	02 00       	.word	0x0002	; ????
}
 464:	01 03       	mulsu	r16, r17
 466:	01 09       	sbc	r16, r1
 468:	10 00       	.word	0x0010	; ????
 46a:	01 04       	cpc	r0, r1
 46c:	04 03       	mulsu	r16, r20
 46e:	a2 7f       	andi	r26, 0xF2	; 242
 470:	09 06       	cpc	r0, r25
 472:	00 01       	movw	r0, r0
 474:	03 01       	movw	r0, r6
 476:	09 00       	.word	0x0009	; ????
 478:	00 01       	movw	r0, r0
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 47a:	03 01       	movw	r0, r6
 47c:	09 10       	cpse	r0, r9
		m += 1;
 47e:	00 01       	movw	r0, r0
 480:	04 03       	mulsu	r16, r20
 482:	03 74       	andi	r16, 0x43	; 67
 484:	09 04       	cpc	r0, r9
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 486:	00 01       	movw	r0, r0
 488:	03 02       	muls	r16, r19
 48a:	09 00       	.word	0x0009	; ????
 48c:	00 01       	movw	r0, r0
 48e:	03 0b       	sbc	r16, r19
 490:	09 12       	cpse	r0, r25
 492:	00 01       	movw	r0, r0
 494:	03 0c       	add	r0, r3
 496:	09 02       	muls	r16, r25
 498:	00 01       	movw	r0, r0
 49a:	03 03       	mulsu	r16, r19
 49c:	09 02       	muls	r16, r25
 49e:	00 01       	movw	r0, r0
 4a0:	03 01       	movw	r0, r6
 4a2:	09 0e       	add	r0, r25
 4a4:	00 01       	movw	r0, r0
 4a6:	03 02       	muls	r16, r19
  Serial._tx_udr_empty_irq();
 4a8:	09 0c       	add	r0, r9
 4aa:	00 01       	movw	r0, r0
 4ac:	03 08       	sbc	r0, r3
 4ae:	09 06       	cpc	r0, r25
}
 4b0:	00 01       	movw	r0, r0
 4b2:	03 05       	cpc	r16, r3
 4b4:	09 0c       	add	r0, r9
 4b6:	00 01       	movw	r0, r0
 4b8:	03 02       	muls	r16, r19
 4ba:	09 08       	sbc	r0, r9
 4bc:	00 01       	movw	r0, r0
 4be:	03 02       	muls	r16, r19
 4c0:	09 0c       	add	r0, r9
 4c2:	00 01       	movw	r0, r0
 4c4:	03 f1       	brvs	.+64     	; 0x506 <__vector_18+0x34>
 4c6:	00 09       	sbc	r16, r0
 4c8:	02 00       	.word	0x0002	; ????
 4ca:	01 03       	mulsu	r16, r17
 4cc:	01 09       	sbc	r16, r1
 4ce:	0e 00       	.word	0x000e	; ????
 4d0:	01 03       	mulsu	r16, r17
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4d2:	05 09       	sbc	r16, r5
 4d4:	04 00       	.word	0x0004	; ????
 4d6:	01 03       	mulsu	r16, r17
 4d8:	09 09       	sbc	r16, r9
 4da:	12 00       	.word	0x0012	; ????
 4dc:	01 04       	cpc	r0, r1
 4de:	05 03       	mulsu	r16, r21
 4e0:	c1 7e       	andi	r28, 0xE1	; 225
 4e2:	09 02       	muls	r16, r25
 4e4:	00 01       	movw	r0, r0

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 4e6:	04 03       	mulsu	r16, r20
 4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <__vector_18+0x1e>
 4ea:	01 09       	sbc	r16, r1
 4ec:	02 00       	.word	0x0002	; ????
 4ee:	01 03       	mulsu	r16, r17
 4f0:	02 09       	sbc	r16, r2
 4f2:	06 00       	.word	0x0006	; ????
 4f4:	01 03       	mulsu	r16, r17
 4f6:	1f 09       	sbc	r17, r15
 4f8:	0a 00       	.word	0x000a	; ????
 4fa:	01 04       	cpc	r0, r1
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 4fc:	05 03       	mulsu	r16, r21
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 4fe:	b3 7e       	andi	r27, 0xE3	; 227
 500:	09 02       	muls	r16, r25
 502:	00 01       	movw	r0, r0
 504:	03 01       	movw	r0, r6

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 506:	09 02       	muls	r16, r25
 508:	00 01       	movw	r0, r0
 50a:	04 03       	mulsu	r16, r20
 50c:	03 d0       	rcall	.+6      	; 0x514 <__vector_18+0x42>
      _rx_buffer[_rx_buffer_head] = c;
 50e:	01 09       	sbc	r16, r1
 510:	00 00       	nop
 512:	01 03       	mulsu	r16, r17
 514:	64 09       	sbc	r22, r4
 516:	14 00       	.word	0x0014	; ????
 518:	01 03       	mulsu	r16, r17
      _rx_buffer_head = i;
 51a:	04 09       	sbc	r16, r4
 51c:	0e 00       	.word	0x000e	; ????
    Serial._rx_complete_irq();
  }
 51e:	01 03       	mulsu	r16, r17
 520:	01 09       	sbc	r16, r1
 522:	06 00       	.word	0x0006	; ????
 524:	01 03       	mulsu	r16, r17
 526:	05 09       	sbc	r16, r5
 528:	06 00       	.word	0x0006	; ????
 52a:	01 03       	mulsu	r16, r17
 52c:	01 09       	sbc	r16, r1
 52e:	0a 00       	.word	0x000a	; ????
 530:	01 03       	mulsu	r16, r17
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 532:	06 09       	sbc	r16, r6
 534:	08 00       	.word	0x0008	; ????

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 536:	01 03       	mulsu	r16, r17
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 538:	05 09       	sbc	r16, r5
 53a:	0e 00       	.word	0x000e	; ????
 53c:	01 04       	cpc	r0, r1
	sbi(TCCR0A, WGM00);
 53e:	05 03       	mulsu	r16, r21
 540:	a1 7e       	andi	r26, 0xE1	; 225
 542:	09 02       	muls	r16, r25
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 544:	00 01       	movw	r0, r0
 546:	04 03       	mulsu	r16, r20
 548:	03 e0       	ldi	r16, 0x03	; 3
	sbi(TCCR0B, CS00);
 54a:	01 09       	sbc	r16, r1
 54c:	02 00       	.word	0x0002	; ????
 54e:	01 03       	mulsu	r16, r17

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 550:	01 09       	sbc	r16, r1
 552:	02 00       	.word	0x0002	; ????
 554:	01 03       	mulsu	r16, r17
 556:	bb 7f       	andi	r27, 0xFB	; 251
 558:	09 0a       	sbc	r0, r25
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 55a:	00 01       	movw	r0, r0
 55c:	03 04       	cpc	r0, r3

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 55e:	09 06       	cpc	r0, r25
 560:	00 01       	movw	r0, r0
 562:	03 03       	mulsu	r16, r19
 564:	09 06       	cpc	r0, r25
 566:	00 01       	movw	r0, r0
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 568:	03 01       	movw	r0, r6
 56a:	09 14       	cp	r0, r9
 56c:	00 01       	movw	r0, r0
 56e:	03 04       	cpc	r0, r3
 570:	09 0c       	add	r0, r9
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 572:	00 01       	movw	r0, r0
 574:	03 01       	movw	r0, r6
 576:	09 06       	cpc	r0, r25
 578:	00 01       	movw	r0, r0
 57a:	03 04       	cpc	r0, r3

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 57c:	09 08       	sbc	r0, r9
 57e:	00 01       	movw	r0, r0
 580:	04 02       	muls	r16, r20
 582:	03 ab       	std	Z+51, r16	; 0x33
 584:	7f 09       	sbc	r23, r15

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 586:	06 00       	.word	0x0006	; ????
 588:	01 04       	cpc	r0, r1
 58a:	06 03       	mulsu	r16, r22
 58c:	ac 7f       	andi	r26, 0xFC	; 252
 58e:	09 04       	cpc	r0, r9
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 590:	00 01       	movw	r0, r0
 592:	04 02       	muls	r16, r20
 594:	03 d9       	rcall	.-3578   	; 0xfffff79c <__eeprom_end+0xff7ef79c>
 596:	00 09       	sbc	r16, r0
 598:	2c 00       	.word	0x002c	; ????
		sbi(ADCSRA, ADPS1);
 59a:	01 04       	cpc	r0, r1
 59c:	07 03       	mulsu	r16, r23
 59e:	a0 7f       	andi	r26, 0xF0	; 240
 5a0:	09 0a       	sbc	r0, r25
 5a2:	00 01       	movw	r0, r0
		sbi(ADCSRA, ADPS0);
 5a4:	03 03       	mulsu	r16, r19
 5a6:	09 16       	cp	r0, r25
 5a8:	00 01       	movw	r0, r0
 5aa:	03 01       	movw	r0, r6
 5ac:	09 10       	cpse	r0, r9
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 5ae:	00 01       	movw	r0, r0
 5b0:	03 03       	mulsu	r16, r19
 5b2:	09 04       	cpc	r0, r9
 5b4:	00 01       	movw	r0, r0
 5b6:	03 01       	movw	r0, r6
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 5b8:	09 04       	cpc	r0, r9
 5ba:	00 01       	movw	r0, r0
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 5bc:	03 7e       	andi	r16, 0xE3	; 227
 5be:	09 04       	cpc	r0, r9
 5c0:	00 01       	movw	r0, r0
	uint8_t port = digitalPinToPort(pin);
 5c2:	03 07       	cpc	r16, r19
 5c4:	09 06       	cpc	r0, r25
 5c6:	00 01       	movw	r0, r0
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 5c8:	03 01       	movw	r0, r6
 5ca:	09 04       	cpc	r0, r9

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 5cc:	00 01       	movw	r0, r0
 5ce:	03 01       	movw	r0, r6
 5d0:	09 10       	cpse	r0, r9
 5d2:	00 01       	movw	r0, r0
 5d4:	03 01       	movw	r0, r6
 5d6:	09 26       	eor	r0, r25
 5d8:	00 01       	movw	r0, r0
 5da:	03 79       	andi	r16, 0x93	; 147
	out = portOutputRegister(port);
 5dc:	09 16       	cp	r0, r25
 5de:	00 01       	movw	r0, r0
 5e0:	03 01       	movw	r0, r6
 5e2:	09 04       	cpc	r0, r9
 5e4:	00 01       	movw	r0, r0
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 5e6:	04 04       	cpc	r0, r4
                cli();
 5e8:	03 06       	cpc	r0, r19
		*reg |= bit;
 5ea:	09 08       	sbc	r0, r9
 5ec:	00 01       	movw	r0, r0
 5ee:	03 01       	movw	r0, r6
		SREG = oldSREG;
 5f0:	09 22       	and	r0, r25

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 5f2:	00 01       	movw	r0, r0
 5f4:	03 01       	movw	r0, r6
 5f6:	09 08       	sbc	r0, r9
 5f8:	00 01       	movw	r0, r0
 5fa:	03 6f       	ori	r16, 0xF3	; 243
 5fc:	09 22       	and	r0, r25
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5fe:	00 01       	movw	r0, r0
 600:	04 0b       	sbc	r16, r20
 602:	03 37       	cpi	r16, 0x73	; 115
 604:	09 14       	cp	r0, r9
 606:	00 01       	movw	r0, r0
  *_ubrrl = baud_setting;
 608:	03 03       	mulsu	r16, r19
 60a:	09 16       	cp	r0, r25
 60c:	00 01       	movw	r0, r0
 60e:	03 01       	movw	r0, r6
 610:	09 02       	muls	r16, r25
 612:	00 01       	movw	r0, r0

  _written = false;
 614:	03 06       	cpc	r0, r19
 616:	09 08       	sbc	r0, r9

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 618:	00 01       	movw	r0, r0
 61a:	03 01       	movw	r0, r6
 61c:	09 08       	sbc	r0, r9
 61e:	00 01       	movw	r0, r0
 620:	03 01       	movw	r0, r6
 622:	09 0c       	add	r0, r9
  
  sbi(*_ucsrb, RXEN0);
 624:	00 01       	movw	r0, r0
 626:	04 04       	cpc	r0, r4
 628:	03 bf       	out	0x33, r16	; 51
 62a:	7f 09       	sbc	r23, r15
 62c:	04 00       	.word	0x0004	; ????
 62e:	01 04       	cpc	r0, r1
 630:	0b 03       	fmul	r16, r19
  sbi(*_ucsrb, TXEN0);
 632:	c5 00       	.word	0x00c5	; ????
 634:	09 14       	cp	r0, r9
 636:	00 01       	movw	r0, r0
 638:	09 04       	cpc	r0, r9
 63a:	00 00       	nop
 63c:	01 01       	movw	r0, r2
 63e:	04 08       	sbc	r0, r4
  sbi(*_ucsrb, RXCIE0);
 640:	00 05       	cpc	r16, r0
 642:	02 36       	cpi	r16, 0x62	; 98
 644:	05 00       	.word	0x0005	; ????
 646:	00 03       	mulsu	r16, r16
 648:	21 01       	movw	r4, r2
 64a:	04 07       	cpc	r16, r20
 64c:	03 d3       	rcall	.+1542   	; 0xc54 <__data_load_end+0x352>
  cbi(*_ucsrb, UDRIE0);
 64e:	01 09       	sbc	r16, r1
 650:	00 00       	nop
 652:	01 03       	mulsu	r16, r17
 654:	06 09       	sbc	r16, r6
 656:	02 00       	.word	0x0002	; ????
 658:	01 03       	mulsu	r16, r17
 65a:	01 09       	sbc	r16, r1
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
 65c:	06 00       	.word	0x0006	; ????
 65e:	01 03       	mulsu	r16, r17
 660:	0d 09       	sbc	r16, r13
 662:	06 00       	.word	0x0006	; ????
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
 664:	01 03       	mulsu	r16, r17
 666:	01 09       	sbc	r16, r1
 668:	06 00       	.word	0x0006	; ????
 66a:	01 03       	mulsu	r16, r17
 66c:	0d 09       	sbc	r16, r13
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
 66e:	06 00       	.word	0x0006	; ????
 670:	01 03       	mulsu	r16, r17
 672:	0b 09       	sbc	r16, r11
 674:	0a 00       	.word	0x000a	; ????
 676:	01 03       	mulsu	r16, r17
 678:	03 09       	sbc	r16, r3
 67a:	04 00       	.word	0x0004	; ????
 67c:	01 03       	mulsu	r16, r17
 67e:	02 09       	sbc	r16, r2
 680:	0a 00       	.word	0x000a	; ????
 682:	01 03       	mulsu	r16, r17
 684:	0a 09       	sbc	r16, r10
 686:	0a 00       	.word	0x000a	; ????
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
 688:	01 03       	mulsu	r16, r17
 68a:	07 09       	sbc	r16, r7
 68c:	0a 00       	.word	0x000a	; ????
 68e:	01 03       	mulsu	r16, r17
 690:	09 09       	sbc	r16, r9
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
 692:	0a 00       	.word	0x000a	; ????
 694:	01 03       	mulsu	r16, r17
 696:	23 09       	sbc	r18, r3
 698:	0a 00       	.word	0x000a	; ????
 69a:	01 03       	mulsu	r16, r17
 69c:	01 09       	sbc	r16, r1
 69e:	0a 00       	.word	0x000a	; ????
 6a0:	01 03       	mulsu	r16, r17
 6a2:	01 09       	sbc	r16, r1
 6a4:	0a 00       	.word	0x000a	; ????
 6a6:	01 03       	mulsu	r16, r17
 6a8:	17 09       	sbc	r17, r7
 6aa:	0a 00       	.word	0x000a	; ????
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
 6ac:	01 03       	mulsu	r16, r17
 6ae:	09 09       	sbc	r16, r9
 6b0:	0a 00       	.word	0x000a	; ????
 6b2:	01 04       	cpc	r0, r1
 6b4:	01 03       	mulsu	r16, r17
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
 6b6:	99 7d       	andi	r25, 0xD9	; 217
 6b8:	09 04       	cpc	r0, r9
 6ba:	00 01       	movw	r0, r0
 6bc:	03 01       	movw	r0, r6
 6be:	09 06       	cpc	r0, r25
 6c0:	00 01       	movw	r0, r0
 6c2:	03 03       	mulsu	r16, r19
 6c4:	09 06       	cpc	r0, r25
 6c6:	00 01       	movw	r0, r0
 6c8:	03 03       	mulsu	r16, r19
 6ca:	09 04       	cpc	r0, r9
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
 6cc:	00 01       	movw	r0, r0
 6ce:	03 01       	movw	r0, r6
 6d0:	09 10       	cpse	r0, r9
 6d2:	00 01       	movw	r0, r0
 6d4:	03 0f       	add	r16, r19
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
 6d6:	09 0a       	sbc	r0, r25
 6d8:	00 01       	movw	r0, r0
 6da:	03 01       	movw	r0, r6
 6dc:	09 02       	muls	r16, r25
 6de:	00 01       	movw	r0, r0
 6e0:	03 01       	movw	r0, r6
 6e2:	09 02       	muls	r16, r25
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 6e4:	00 01       	movw	r0, r0
 6e6:	03 01       	movw	r0, r6
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
 6e8:	09 06       	cpc	r0, r25
 6ea:	00 01       	movw	r0, r0
 6ec:	04 03       	mulsu	r16, r20
 6ee:	03 c0       	rjmp	.+6      	; 0x6f6 <__LDST+0x20>
  randomSeed(0);
  noInterrupts();
 6f0:	00 09       	sbc	r16, r0
  
  digitalWrite(LED_BUILTIN, LOW);   
 6f2:	02 00       	.word	0x0002	; ????
 6f4:	01 03       	mulsu	r16, r17
 6f6:	0e 09       	sbc	r16, r14
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 6f8:	0c 00       	.word	0x000c	; ????
 6fa:	01 03       	mulsu	r16, r17
 6fc:	01 09       	sbc	r16, r1
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
 6fe:	0a 00       	.word	0x000a	; ????
 700:	01 03       	mulsu	r16, r17
 702:	02 09       	sbc	r16, r2
 704:	0c 00       	.word	0x000c	; ????
 706:	01 03       	mulsu	r16, r17
 708:	06 09       	sbc	r16, r6
 70a:	04 00       	.word	0x0004	; ????
 70c:	01 03       	mulsu	r16, r17
 70e:	02 09       	sbc	r16, r2
 710:	0c 00       	.word	0x000c	; ????
 712:	01 03       	mulsu	r16, r17
 714:	01 09       	sbc	r16, r1
 716:	0e 00       	.word	0x000e	; ????
 718:	01 03       	mulsu	r16, r17
 71a:	01 09       	sbc	r16, r1
 71c:	0e 00       	.word	0x000e	; ????
 71e:	01 03       	mulsu	r16, r17
 720:	01 09       	sbc	r16, r1
 722:	0e 00       	.word	0x000e	; ????
 724:	01 04       	cpc	r0, r1
 726:	09 03       	fmul	r16, r17
 728:	f7 7e       	andi	r31, 0xE7	; 231
 72a:	09 0e       	add	r0, r25
 72c:	00 01       	movw	r0, r0
 72e:	03 07       	cpc	r16, r19
 730:	09 08       	sbc	r0, r9
 732:	00 01       	movw	r0, r0
 734:	03 08       	sbc	r0, r3
 736:	09 0a       	sbc	r0, r25
 738:	00 01       	movw	r0, r0
 73a:	03 08       	sbc	r0, r3
 73c:	09 1a       	sub	r0, r25
 73e:	00 01       	movw	r0, r0
 740:	03 08       	sbc	r0, r3
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
 742:	09 0a       	sbc	r0, r25
 744:	00 01       	movw	r0, r0
 746:	03 08       	sbc	r0, r3
 748:	09 1a       	sub	r0, r25
 74a:	00 01       	movw	r0, r0
 74c:	03 07       	cpc	r16, r19
 74e:	09 0a       	sbc	r0, r25
 750:	00 01       	movw	r0, r0
 752:	03 08       	sbc	r0, r3
 754:	09 16       	cp	r0, r25
 756:	00 01       	movw	r0, r0
 758:	03 07       	cpc	r16, r19
 75a:	09 0a       	sbc	r0, r25
 75c:	00 01       	movw	r0, r0
 75e:	04 03       	mulsu	r16, r20
 760:	03 7a       	andi	r16, 0xA3	; 163
 762:	09 0e       	add	r0, r25
 764:	00 01       	movw	r0, r0
 766:	04 09       	sbc	r16, r4
 768:	03 0b       	sbc	r16, r19
 76a:	09 04       	cpc	r0, r9
 76c:	00 01       	movw	r0, r0
 76e:	03 02       	muls	r16, r19
 770:	09 08       	sbc	r0, r9
 772:	00 01       	movw	r0, r0
 774:	03 02       	muls	r16, r19
 776:	09 02       	muls	r16, r25
 778:	00 01       	movw	r0, r0
 77a:	03 01       	movw	r0, r6
 77c:	09 06       	cpc	r0, r25
 77e:	00 01       	movw	r0, r0
 780:	03 22       	and	r0, r19
 782:	09 06       	cpc	r0, r25
 784:	00 01       	movw	r0, r0
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
 786:	03 1e       	adc	r0, r19
 788:	09 44       	sbci	r16, 0x49	; 73
 78a:	00 01       	movw	r0, r0
 78c:	03 1d       	adc	r16, r3
 78e:	09 44       	sbci	r16, 0x49	; 73
 790:	00 01       	movw	r0, r0
 792:	03 1d       	adc	r16, r3
 794:	09 44       	sbci	r16, 0x49	; 73
 796:	00 01       	movw	r0, r0
 798:	03 1b       	sub	r16, r19
 79a:	09 44       	sbci	r16, 0x49	; 73
 79c:	00 01       	movw	r0, r0
 79e:	03 01       	movw	r0, r6
 7a0:	09 30       	cpi	r16, 0x09	; 9
 7a2:	00 01       	movw	r0, r0
 7a4:	03 01       	movw	r0, r6
 7a6:	09 08       	sbc	r0, r9
 7a8:	00 01       	movw	r0, r0
 7aa:	04 03       	mulsu	r16, r20
 7ac:	03 d9       	rcall	.-3578   	; 0xfffff9b4 <__eeprom_end+0xff7ef9b4>
 7ae:	7e 09       	sbc	r23, r14
 7b0:	02 00       	.word	0x0002	; ????
 7b2:	01 04       	cpc	r0, r1
 7b4:	04 03       	mulsu	r16, r20
 7b6:	0a 09       	sbc	r16, r10
 7b8:	16 00       	.word	0x0016	; ????
 7ba:	01 04       	cpc	r0, r1
 7bc:	06 03       	mulsu	r16, r22
 7be:	61 09       	sbc	r22, r1
 7c0:	00 00       	nop
 7c2:	01 04       	cpc	r0, r1
 7c4:	0a 03       	fmul	r16, r18
 7c6:	11 09       	sbc	r17, r1
 7c8:	08 00       	.word	0x0008	; ????
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
 7ca:	01 04       	cpc	r0, r1
 7cc:	0b 03       	fmul	r16, r19
 7ce:	20 09       	sbc	r18, r0
 7d0:	10 00       	.word	0x0010	; ????
 7d2:	01 04       	cpc	r0, r1
 7d4:	04 03       	mulsu	r16, r20
 7d6:	6e 09       	sbc	r22, r14
 7d8:	40 00       	.word	0x0040	; ????
 7da:	01 09       	sbc	r16, r1
 7dc:	02 00       	.word	0x0002	; ????
 7de:	00 01       	movw	r0, r0
 7e0:	01 5e       	subi	r16, 0xE1	; 225
 7e2:	00 00       	nop
 7e4:	00 02       	muls	r16, r16
 7e6:	00 41       	sbci	r16, 0x10	; 16
 7e8:	00 00       	nop
 7ea:	00 02       	muls	r16, r16
 7ec:	01 fb       	bst	r16, 1
 7ee:	0e 0a       	sbc	r0, r30
 7f0:	00 01       	movw	r0, r0
 7f2:	01 01       	movw	r0, r2
 7f4:	01 00       	.word	0x0001	; ????
 7f6:	00 00       	nop
 7f8:	01 2e       	mov	r0, r17
 7fa:	2e 2f       	mov	r18, r30
 7fc:	2e 2e       	mov	r2, r30
 7fe:	2f 2e       	mov	r2, r31
 800:	2e 2f       	mov	r18, r30
 802:	2e 2e       	mov	r2, r30
 804:	2f 67       	ori	r18, 0x7F	; 127
 806:	63 63       	ori	r22, 0x33	; 51
 808:	2f 6c       	ori	r18, 0xCF	; 207
 80a:	69 62       	ori	r22, 0x29	; 41
 80c:	67 63       	ori	r22, 0x37	; 55
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
 80e:	63 2f       	mov	r22, r19
 810:	63 6f       	ori	r22, 0xF3	; 243
 812:	6e 66       	ori	r22, 0x6E	; 110
 814:	69 67       	ori	r22, 0x79	; 121
 816:	2f 61       	ori	r18, 0x1F	; 31
 818:	76 72       	andi	r23, 0x26	; 38
 81a:	00 00       	nop
 81c:	6c 69       	ori	r22, 0x9C	; 156
 81e:	62 31       	cpi	r22, 0x12	; 18
 820:	66 75       	andi	r22, 0x56	; 86
 822:	6e 63       	ori	r22, 0x3E	; 62
 824:	73 2e       	mov	r7, r19
 826:	53 00       	.word	0x0053	; ????
 828:	01 00       	.word	0x0001	; ????
 82a:	00 00       	nop
 82c:	00 05       	cpc	r16, r0
 82e:	02 c4       	rjmp	.+2052   	; 0x1034 <__data_load_end+0x732>
 830:	08 00       	.word	0x0008	; ????
 832:	00 03       	mulsu	r16, r16
 834:	e5 11       	cpse	r30, r5
 836:	01 03       	mulsu	r16, r17
 838:	02 09       	sbc	r16, r2
 83a:	02 00       	.word	0x0002	; ????
 83c:	01 09       	sbc	r16, r1
  Serial.println("End of loop");
 83e:	02 00       	.word	0x0002	; ????
 840:	00 01       	movw	r0, r0
 842:	01 94       	neg	r0
 844:	00 00       	nop
  interrupts();
 846:	00 02       	muls	r16, r16
 848:	00 41       	sbci	r16, 0x10	; 16
 84a:	00 00       	nop
 84c:	00 02       	muls	r16, r16
 84e:	01 fb       	bst	r16, 1
 850:	0e 0a       	sbc	r0, r30
 852:	00 01       	movw	r0, r0
 854:	01 01       	movw	r0, r2
 856:	01 00       	.word	0x0001	; ????
 858:	00 00       	nop
 85a:	01 2e       	mov	r0, r17
 85c:	2e 2f       	mov	r18, r30
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 85e:	2e 2e       	mov	r2, r30
 860:	2f 2e       	mov	r2, r31
 862:	2e 2f       	mov	r18, r30
 864:	2e 2e       	mov	r2, r30
 866:	2f 67       	ori	r18, 0x7F	; 127
 868:	63 63       	ori	r22, 0x33	; 51
 86a:	2f 6c       	ori	r18, 0xCF	; 207
 86c:	69 62       	ori	r22, 0x29	; 41
 86e:	67 63       	ori	r22, 0x37	; 55
 870:	63 2f       	mov	r22, r19
 872:	63 6f       	ori	r22, 0xF3	; 243
 874:	6e 66       	ori	r22, 0x6E	; 110
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 876:	69 67       	ori	r22, 0x79	; 121
 878:	2f 61       	ori	r18, 0x1F	; 31
 87a:	76 72       	andi	r23, 0x26	; 38
 87c:	00 00       	nop
 87e:	6c 69       	ori	r22, 0x9C	; 156
 880:	62 31       	cpi	r22, 0x12	; 18
 882:	66 75       	andi	r22, 0x56	; 86
 884:	6e 63       	ori	r22, 0x3E	; 62
 886:	73 2e       	mov	r7, r19
 888:	53 00       	.word	0x0053	; ????
 88a:	01 00       	.word	0x0001	; ????
 88c:	00 00       	nop
 88e:	00 05       	cpc	r16, r0
 890:	02 c6       	rjmp	.+3076   	; 0x1496 <__data_load_end+0xb94>
 892:	00 00       	nop
 894:	00 03       	mulsu	r16, r16
 896:	e8 12       	cpse	r14, r24
 898:	01 03       	mulsu	r16, r17
 89a:	01 09       	sbc	r16, r1
 89c:	02 00       	.word	0x0002	; ????
 89e:	01 03       	mulsu	r16, r17
 8a0:	01 09       	sbc	r16, r1
 8a2:	02 00       	.word	0x0002	; ????
 8a4:	01 03       	mulsu	r16, r17
 8a6:	01 09       	sbc	r16, r1
 8a8:	02 00       	.word	0x0002	; ????
 8aa:	01 03       	mulsu	r16, r17
 8ac:	01 09       	sbc	r16, r1
 8ae:	02 00       	.word	0x0002	; ????
 8b0:	01 03       	mulsu	r16, r17
 8b2:	01 09       	sbc	r16, r1
 8b4:	02 00       	.word	0x0002	; ????

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
 8b6:	01 03       	mulsu	r16, r17
 8b8:	03 09       	sbc	r16, r3
 8ba:	02 00       	.word	0x0002	; ????
 8bc:	01 03       	mulsu	r16, r17
 8be:	05 09       	sbc	r16, r5
 8c0:	02 00       	.word	0x0002	; ????
 8c2:	01 03       	mulsu	r16, r17
 8c4:	02 09       	sbc	r16, r2
 8c6:	02 00       	.word	0x0002	; ????
 8c8:	01 03       	mulsu	r16, r17
 8ca:	01 09       	sbc	r16, r1
 8cc:	02 00       	.word	0x0002	; ????
 8ce:	01 03       	mulsu	r16, r17
 8d0:	01 09       	sbc	r16, r1
 8d2:	02 00       	.word	0x0002	; ????
 8d4:	01 09       	sbc	r16, r1
 8d6:	02 00       	.word	0x0002	; ????
 8d8:	00 01       	movw	r0, r0
 8da:	01 82       	std	Z+1, r0	; 0x01
 8dc:	00 00       	nop
 8de:	00 02       	muls	r16, r16
 8e0:	00 41       	sbci	r16, 0x10	; 16
 8e2:	00 00       	nop
 8e4:	00 02       	muls	r16, r16
 8e6:	01 fb       	bst	r16, 1
 8e8:	0e 0a       	sbc	r0, r30
 8ea:	00 01       	movw	r0, r0
 8ec:	01 01       	movw	r0, r2
 8ee:	01 00       	.word	0x0001	; ????
 8f0:	00 00       	nop
 8f2:	01 2e       	mov	r0, r17
 8f4:	2e 2f       	mov	r18, r30
 8f6:	2e 2e       	mov	r2, r30
 8f8:	2f 2e       	mov	r2, r31
 8fa:	2e 2f       	mov	r18, r30
 8fc:	2e 2e       	mov	r2, r30
 8fe:	2f 67       	ori	r18, 0x7F	; 127
 900:	63 63       	ori	r22, 0x33	; 51
 902:	2f 6c       	ori	r18, 0xCF	; 207
 904:	69 62       	ori	r22, 0x29	; 41
 906:	67 63       	ori	r22, 0x37	; 55
 908:	63 2f       	mov	r22, r19
 90a:	63 6f       	ori	r22, 0xF3	; 243
 90c:	6e 66       	ori	r22, 0x6E	; 110
 90e:	69 67       	ori	r22, 0x79	; 121
 910:	2f 61       	ori	r18, 0x1F	; 31
 912:	76 72       	andi	r23, 0x26	; 38
 914:	00 00       	nop
 916:	6c 69       	ori	r22, 0x9C	; 156
 918:	62 31       	cpi	r22, 0x12	; 18
 91a:	66 75       	andi	r22, 0x56	; 86
 91c:	6e 63       	ori	r22, 0x3E	; 62
 91e:	73 2e       	mov	r7, r19
 920:	53 00       	.word	0x0053	; ????
 922:	01 00       	.word	0x0001	; ????
 924:	00 00       	nop
 926:	00 05       	cpc	r16, r0
 928:	02 dc       	rcall	.-2044   	; 0x12e <digitalWrite.constprop.4+0x20>
 92a:	00 00       	nop
 92c:	00 03       	mulsu	r16, r16
 92e:	88 13       	cpse	r24, r24
 930:	01 03       	mulsu	r16, r17
 932:	01 09       	sbc	r16, r1
 934:	02 00       	.word	0x0002	; ????
 936:	01 03       	mulsu	r16, r17
 938:	01 09       	sbc	r16, r1
 93a:	02 00       	.word	0x0002	; ????
 93c:	01 03       	mulsu	r16, r17
 93e:	01 09       	sbc	r16, r1
 940:	02 00       	.word	0x0002	; ????
 942:	01 03       	mulsu	r16, r17
 944:	02 09       	sbc	r16, r2
 946:	02 00       	.word	0x0002	; ????
 948:	01 03       	mulsu	r16, r17
 94a:	02 09       	sbc	r16, r2
 94c:	02 00       	.word	0x0002	; ????
 94e:	01 03       	mulsu	r16, r17
 950:	01 09       	sbc	r16, r1
 952:	02 00       	.word	0x0002	; ????
 954:	01 03       	mulsu	r16, r17
 956:	01 09       	sbc	r16, r1
 958:	02 00       	.word	0x0002	; ????
 95a:	01 09       	sbc	r16, r1
 95c:	02 00       	.word	0x0002	; ????
 95e:	00 01       	movw	r0, r0
 960:	01 8e       	std	Z+25, r0	; 0x19
 962:	00 00       	nop
 964:	00 02       	muls	r16, r16
 966:	00 41       	sbci	r16, 0x10	; 16
 968:	00 00       	nop
 96a:	00 02       	muls	r16, r16
 96c:	01 fb       	bst	r16, 1
 96e:	0e 0a       	sbc	r0, r30
 970:	00 01       	movw	r0, r0
 972:	01 01       	movw	r0, r2
 974:	01 00       	.word	0x0001	; ????
 976:	00 00       	nop
 978:	01 2e       	mov	r0, r17
 97a:	2e 2f       	mov	r18, r30
 97c:	2e 2e       	mov	r2, r30
 97e:	2f 2e       	mov	r2, r31
 980:	2e 2f       	mov	r18, r30
 982:	2e 2e       	mov	r2, r30
 984:	2f 67       	ori	r18, 0x7F	; 127
 986:	63 63       	ori	r22, 0x33	; 51
 988:	2f 6c       	ori	r18, 0xCF	; 207
 98a:	69 62       	ori	r22, 0x29	; 41
 98c:	67 63       	ori	r22, 0x37	; 55
 98e:	63 2f       	mov	r22, r19
 990:	63 6f       	ori	r22, 0xF3	; 243
 992:	6e 66       	ori	r22, 0x6E	; 110
 994:	69 67       	ori	r22, 0x79	; 121
 996:	2f 61       	ori	r18, 0x1F	; 31
 998:	76 72       	andi	r23, 0x26	; 38
 99a:	00 00       	nop
 99c:	6c 69       	ori	r22, 0x9C	; 156
 99e:	62 31       	cpi	r22, 0x12	; 18
 9a0:	66 75       	andi	r22, 0x56	; 86
 9a2:	6e 63       	ori	r22, 0x3E	; 62
 9a4:	73 2e       	mov	r7, r19
 9a6:	53 00       	.word	0x0053	; ????
 9a8:	01 00       	.word	0x0001	; ????
 9aa:	00 00       	nop
 9ac:	00 05       	cpc	r16, r0
 9ae:	02 ec       	ldi	r16, 0xC2	; 194
 9b0:	00 00       	nop
 9b2:	00 03       	mulsu	r16, r16
 9b4:	a1 13       	cpse	r26, r17
 9b6:	01 03       	mulsu	r16, r17
 9b8:	01 09       	sbc	r16, r1
 9ba:	02 00       	.word	0x0002	; ????
 9bc:	01 03       	mulsu	r16, r17
 9be:	01 09       	sbc	r16, r1
 9c0:	02 00       	.word	0x0002	; ????
 9c2:	01 03       	mulsu	r16, r17
 9c4:	04 09       	sbc	r16, r4
 9c6:	02 00       	.word	0x0002	; ????
 9c8:	01 03       	mulsu	r16, r17
 9ca:	02 09       	sbc	r16, r2
 9cc:	02 00       	.word	0x0002	; ????
 9ce:	01 03       	mulsu	r16, r17
 9d0:	06 09       	sbc	r16, r6
 9d2:	02 00       	.word	0x0002	; ????
 9d4:	01 03       	mulsu	r16, r17
 9d6:	01 09       	sbc	r16, r1
 9d8:	02 00       	.word	0x0002	; ????
 9da:	01 03       	mulsu	r16, r17
 9dc:	02 09       	sbc	r16, r2
 9de:	04 00       	.word	0x0004	; ????
 9e0:	01 03       	mulsu	r16, r17
 9e2:	01 09       	sbc	r16, r1
 9e4:	02 00       	.word	0x0002	; ????
 9e6:	01 03       	mulsu	r16, r17
 9e8:	05 09       	sbc	r16, r5
 9ea:	02 00       	.word	0x0002	; ????
 9ec:	01 09       	sbc	r16, r1
 9ee:	02 00       	.word	0x0002	; ????
 9f0:	00 01       	movw	r0, r0
 9f2:	01 76       	andi	r16, 0x61	; 97
 9f4:	00 00       	nop
 9f6:	00 02       	muls	r16, r16
 9f8:	00 41       	sbci	r16, 0x10	; 16
 9fa:	00 00       	nop
 9fc:	00 02       	muls	r16, r16
 9fe:	01 fb       	bst	r16, 1
 a00:	0e 0a       	sbc	r0, r30
 a02:	00 01       	movw	r0, r0
 a04:	01 01       	movw	r0, r2
 a06:	01 00       	.word	0x0001	; ????
 a08:	00 00       	nop
 a0a:	01 2e       	mov	r0, r17
 a0c:	2e 2f       	mov	r18, r30
 a0e:	2e 2e       	mov	r2, r30
 a10:	2f 2e       	mov	r2, r31
 a12:	2e 2f       	mov	r18, r30
 a14:	2e 2e       	mov	r2, r30
 a16:	2f 67       	ori	r18, 0x7F	; 127
 a18:	63 63       	ori	r22, 0x33	; 51
 a1a:	2f 6c       	ori	r18, 0xCF	; 207
 a1c:	69 62       	ori	r22, 0x29	; 41
 a1e:	67 63       	ori	r22, 0x37	; 55
 a20:	63 2f       	mov	r22, r19
 a22:	63 6f       	ori	r22, 0xF3	; 243
 a24:	6e 66       	ori	r22, 0x6E	; 110
 a26:	69 67       	ori	r22, 0x79	; 121
 a28:	2f 61       	ori	r18, 0x1F	; 31
 a2a:	76 72       	andi	r23, 0x26	; 38
 a2c:	00 00       	nop
 a2e:	6c 69       	ori	r22, 0x9C	; 156
 a30:	62 31       	cpi	r22, 0x12	; 18
 a32:	66 75       	andi	r22, 0x56	; 86
 a34:	6e 63       	ori	r22, 0x3E	; 62
 a36:	73 2e       	mov	r7, r19
 a38:	53 00       	.word	0x0053	; ????
 a3a:	01 00       	.word	0x0001	; ????
 a3c:	00 00       	nop
 a3e:	00 05       	cpc	r16, r0
 a40:	02 b8       	out	0x02, r0	; 2
 a42:	08 00       	.word	0x0008	; ????
 a44:	00 03       	mulsu	r16, r16
 a46:	f7 11       	cpse	r31, r7
 a48:	01 03       	mulsu	r16, r17
 a4a:	01 09       	sbc	r16, r1
 a4c:	02 00       	.word	0x0002	; ????
 a4e:	01 03       	mulsu	r16, r17
 a50:	1f 09       	sbc	r17, r15
 a52:	02 00       	.word	0x0002	; ????
 a54:	01 03       	mulsu	r16, r17
 a56:	01 09       	sbc	r16, r1
 a58:	02 00       	.word	0x0002	; ????
 a5a:	01 03       	mulsu	r16, r17
 a5c:	01 09       	sbc	r16, r1
 a5e:	02 00       	.word	0x0002	; ????
 a60:	01 03       	mulsu	r16, r17
 a62:	01 09       	sbc	r16, r1
 a64:	02 00       	.word	0x0002	; ????
 a66:	01 09       	sbc	r16, r1
 a68:	02 00       	.word	0x0002	; ????
 a6a:	00 01       	movw	r0, r0
 a6c:	01 00       	Address 0x00000a6c is out of bounds.
.word	0xffff	; ????

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	10 00       	.word	0x0010	; ????
   2:	00 00       	nop
   4:	ff ff       	.word	0xffff	; ????
   6:	ff ff       	.word	0xffff	; ????
   8:	01 00       	.word	0x0001	; ????
   a:	02 7f       	andi	r16, 0xF2	; 242
   c:	24 0c       	add	r2, r4
   e:	20 02       	muls	r18, r16
  10:	a4 01       	movw	r20, r8
  12:	00 00       	nop
  14:	0c 00       	.word	0x000c	; ????
  16:	00 00       	nop
  18:	00 00       	nop
  1a:	00 00       	nop
  1c:	0e 01       	movw	r0, r28
  1e:	00 00       	nop
  20:	90 00       	.word	0x0090	; ????
  22:	00 00       	nop
  24:	40 00       	.word	0x0040	; ????
  26:	00 00       	nop
  28:	00 00       	nop
  2a:	00 00       	nop
  2c:	9e 01       	movw	r18, r28
  2e:	00 00       	nop
  30:	5a 00       	.word	0x005a	; ????
  32:	00 00       	nop
  34:	41 0e       	add	r4, r17
  36:	03 8a       	std	Z+19, r0	; 0x13
  38:	02 41       	sbci	r16, 0x12	; 18
  3a:	0e 04       	cpc	r0, r14
  3c:	8b 03       	fmulsu	r16, r19
  3e:	41 0e       	add	r4, r17
  40:	05 8c       	ldd	r0, Z+29	; 0x1d
  42:	04 41       	sbci	r16, 0x14	; 20
  44:	0e 06       	cpc	r0, r30
  46:	8d 05       	cpc	r24, r13
  48:	41 0e       	add	r4, r17
  4a:	07 8e       	std	Z+31, r0	; 0x1f
  4c:	06 41       	sbci	r16, 0x16	; 22
  4e:	0e 08       	sbc	r0, r14
  50:	8f 07       	cpc	r24, r31
  52:	41 0e       	add	r4, r17
  54:	09 90       	ld	r0, Y+
  56:	08 41       	sbci	r16, 0x18	; 24
  58:	0e 0a       	sbc	r0, r30
  5a:	91 09       	sbc	r25, r1
  5c:	41 0e       	add	r4, r17
  5e:	0b 9c       	mul	r0, r11
  60:	0a 41       	sbci	r16, 0x1A	; 26
  62:	0e 0c       	add	r0, r14
  64:	9d 0b       	sbc	r25, r29
  66:	00 00       	nop
  68:	0c 00       	.word	0x000c	; ????
  6a:	00 00       	nop
  6c:	00 00       	nop
  6e:	00 00       	nop
  70:	f8 01       	movw	r30, r16
  72:	00 00       	nop
  74:	1e 00       	.word	0x001e	; ????
  76:	00 00       	nop
  78:	0c 00       	.word	0x000c	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	16 02       	muls	r17, r22
  82:	00 00       	nop
  84:	28 00       	.word	0x0028	; ????
  86:	00 00       	nop
  88:	0c 00       	.word	0x000c	; ????
  8a:	00 00       	nop
  8c:	00 00       	nop
  8e:	00 00       	nop
  90:	3e 02       	muls	r19, r30
  92:	00 00       	nop
  94:	1c 00       	.word	0x001c	; ????
  96:	00 00       	nop
  98:	0c 00       	.word	0x000c	; ????
  9a:	00 00       	nop
  9c:	00 00       	nop
  9e:	00 00       	nop
  a0:	5a 02       	muls	r21, r26
  a2:	00 00       	nop
  a4:	18 00       	.word	0x0018	; ????
  a6:	00 00       	nop
  a8:	0c 00       	.word	0x000c	; ????
  aa:	00 00       	nop
  ac:	00 00       	nop
  ae:	00 00       	nop
  b0:	72 02       	muls	r23, r18
  b2:	00 00       	nop
  b4:	14 00       	.word	0x0014	; ????
  b6:	00 00       	nop
  b8:	0c 00       	.word	0x000c	; ????
  ba:	00 00       	nop
  bc:	00 00       	nop
  be:	00 00       	nop
  c0:	86 02       	muls	r24, r22
  c2:	00 00       	nop
  c4:	14 00       	.word	0x0014	; ????
  c6:	00 00       	nop
  c8:	0c 00       	.word	0x000c	; ????
  ca:	00 00       	nop
  cc:	00 00       	nop
  ce:	00 00       	nop
  d0:	9a 02       	muls	r25, r26
  d2:	00 00       	nop
  d4:	44 00       	.word	0x0044	; ????
  d6:	00 00       	nop
  d8:	2c 00       	.word	0x002c	; ????
  da:	00 00       	nop
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	de 02       	muls	r29, r30
  e2:	00 00       	nop
  e4:	9a 00       	.word	0x009a	; ????
  e6:	00 00       	nop
  e8:	41 0e       	add	r4, r17
  ea:	03 8e       	std	Z+27, r0	; 0x1b
  ec:	02 41       	sbci	r16, 0x12	; 18
  ee:	0e 04       	cpc	r0, r14
  f0:	8f 03       	fmulsu	r16, r23
  f2:	41 0e       	add	r4, r17
  f4:	05 90       	lpm	r0, Z+
  f6:	04 41       	sbci	r16, 0x14	; 20
  f8:	0e 06       	cpc	r0, r30
  fa:	91 05       	cpc	r25, r1
  fc:	41 0e       	add	r4, r17
  fe:	07 9c       	mul	r0, r7
 100:	06 41       	sbci	r16, 0x16	; 22
 102:	0e 08       	sbc	r0, r14
 104:	9d 07       	cpc	r25, r29
 106:	00 00       	nop
 108:	18 00       	.word	0x0018	; ????
 10a:	00 00       	nop
 10c:	00 00       	nop
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	00 00       	nop
 110:	78 03       	fmul	r23, r16
 112:	00 00       	nop
	uint8_t bit = digitalPinToBitMask(pin);
 114:	40 00       	.word	0x0040	; ????
 116:	00 00       	nop
 118:	41 0e       	add	r4, r17
	uint8_t port = digitalPinToPort(pin);
 11a:	03 9c       	mul	r0, r3
 11c:	02 41       	sbci	r16, 0x12	; 18
 11e:	0e 04       	cpc	r0, r14
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	9d 03       	fmulsu	r17, r21
 122:	00 00       	nop

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	18 00       	.word	0x0018	; ????
 126:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	00 00       	nop
 12a:	00 00       	nop
 12c:	b8 03       	fmulsu	r19, r16
 12e:	00 00       	nop
 130:	3a 00       	.word	0x003a	; ????
 132:	00 00       	nop
 134:	41 0e       	add	r4, r17

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	03 9c       	mul	r0, r3
 138:	02 41       	sbci	r16, 0x12	; 18
 13a:	0e 04       	cpc	r0, r14
 13c:	9d 03       	fmulsu	r17, r21
 13e:	00 00       	nop
 140:	34 00       	.word	0x0034	; ????
 142:	00 00       	nop

	uint8_t oldSREG = SREG;
 144:	00 00       	nop
	cli();
 146:	00 00       	nop

	if (val == LOW) {
		*out &= ~bit;
 148:	f2 03       	fmuls	r23, r18
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	00 00       	nop
 14c:	94 00       	.word	0x0094	; ????
		*out &= ~bit;
 14e:	00 00       	nop
 150:	41 0e       	add	r4, r17
	} else {
		*out |= bit;
 152:	03 81       	ldd	r16, Z+3	; 0x03
	}

	SREG = oldSREG;
 154:	02 41       	sbci	r16, 0x12	; 18
}
 156:	0e 04       	cpc	r0, r14
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	80 03       	fmuls	r16, r16
 15a:	44 0e       	add	r4, r20
 15c:	05 92       	las	Z, r0
 15e:	04 41       	sbci	r16, 0x14	; 20
 160:	0e 06       	cpc	r0, r30
 162:	93 05       	cpc	r25, r3
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	41 0e       	add	r4, r17
 166:	07 98       	cbi	0x00, 7	; 0
 168:	06 41       	sbci	r16, 0x16	; 22
 16a:	0e 08       	sbc	r0, r14
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	99 07       	cpc	r25, r25
 16e:	41 0e       	add	r4, r17
 170:	09 9a       	sbi	0x01, 1	; 1
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	08 41       	sbci	r16, 0x18	; 24
 174:	0e 0a       	sbc	r0, r30
 176:	9b 09       	sbc	r25, r11
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	0c 00       	.word	0x000c	; ????
 17a:	00 00       	nop
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17c:	00 00       	nop
 17e:	00 00       	nop
 180:	36 05       	cpc	r19, r6
 182:	00 00       	nop
 184:	28 03       	fmul	r18, r16
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	00 00       	nop
 188:	0c 00       	.word	0x000c	; ????
 18a:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	00 00       	nop
 18e:	00 00       	nop
 190:	5e 08       	sbc	r5, r14
 192:	00 00       	nop
 194:	5a 00       	.word	0x005a	; ????
 196:	00 00       	nop
 198:	54 00       	.word	0x0054	; ????
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	00 00       	nop
 19c:	00 00       	nop

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	00 00       	nop
 1a0:	86 04       	cpc	r8, r6
 1a2:	00 00       	nop
 1a4:	4c 00       	.word	0x004c	; ????
 1a6:	00 00       	nop
 1a8:	41 0e       	add	r4, r17
 1aa:	03 81       	ldd	r16, Z+3	; 0x03
 1ac:	02 41       	sbci	r16, 0x12	; 18
 1ae:	0e 04       	cpc	r0, r14
 1b0:	80 03       	fmuls	r16, r16
 1b2:	44 0e       	add	r4, r20
 1b4:	05 92       	las	Z, r0
 1b6:	04 41       	sbci	r16, 0x14	; 20
 1b8:	0e 06       	cpc	r0, r30
 1ba:	93 05       	cpc	r25, r3
 1bc:	41 0e       	add	r4, r17
 1be:	07 94       	ror	r0
 1c0:	06 41       	sbci	r16, 0x16	; 22
 1c2:	0e 08       	sbc	r0, r14
  size_t n = 0;
  while (size--) {
 1c4:	95 07       	cpc	r25, r21
 1c6:	41 0e       	add	r4, r17
 1c8:	09 96       	adiw	r24, 0x09	; 9
    if (write(*buffer++)) n++;
 1ca:	08 41       	sbci	r16, 0x18	; 24
 1cc:	0e 0a       	sbc	r0, r30
 1ce:	97 09       	sbc	r25, r7
 1d0:	41 0e       	add	r4, r17
 1d2:	0b 98       	cbi	0x01, 3	; 1
 1d4:	0a 41       	sbci	r16, 0x1A	; 26
 1d6:	0e 0c       	add	r0, r14
 1d8:	99 0b       	sbc	r25, r25
 1da:	41 0e       	add	r4, r17
 1dc:	0d 9a       	sbi	0x01, 5	; 1
 1de:	0c 41       	sbci	r16, 0x1C	; 28
    else break;
  }
  return n;
}
 1e0:	0e 0e       	add	r0, r30
 1e2:	9b 0d       	add	r25, r11
 1e4:	41 0e       	add	r4, r17
 1e6:	0f 9e       	mul	r0, r31
 1e8:	0e 41       	sbci	r16, 0x1E	; 30
 1ea:	0e 10       	cpse	r0, r14
 1ec:	9f 0f       	add	r25, r31
 1ee:	00 00       	nop
 1f0:	30 00       	.word	0x0030	; ????
 1f2:	00 00       	nop
 1f4:	00 00       	nop
 1f6:	00 00       	nop
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	d2 04       	cpc	r13, r2
 1fa:	00 00       	nop
    tail = _tx_buffer_tail;
 1fc:	64 00       	.word	0x0064	; ????
 1fe:	00 00       	nop
 200:	41 0e       	add	r4, r17
 202:	03 81       	ldd	r16, Z+3	; 0x03
 204:	02 41       	sbci	r16, 0x12	; 18
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	0e 04       	cpc	r0, r14
 208:	80 03       	fmuls	r16, r16
 20a:	44 0e       	add	r4, r20
 20c:	05 92       	las	Z, r0
 20e:	04 41       	sbci	r16, 0x14	; 20
 210:	0e 06       	cpc	r0, r30
  return tail - head - 1;
 212:	98 05       	cpc	r25, r8
}
 214:	41 0e       	add	r4, r17
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	07 99       	sbic	0x00, 7	; 0
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	06 41       	sbci	r16, 0x16	; 22
 21a:	0e 08       	sbc	r0, r14
 21c:	9e 07       	cpc	r25, r30
 21e:	41 0e       	add	r4, r17
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	09 9f       	mul	r16, r25
 222:	08 00       	.word	0x0008	; ????

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	61 76       	andi	r22, 0x61	; 97
   2:	72 2d       	mov	r23, r2
   4:	6c 69       	ori	r22, 0x9C	; 156
   6:	62 63       	ori	r22, 0x32	; 50
   8:	20 32       	cpi	r18, 0x20	; 32
   a:	2e 30       	cpi	r18, 0x0E	; 14
   c:	2e 30       	cpi	r18, 0x0E	; 14
   e:	00 75       	andi	r16, 0x50	; 80
  10:	69 6e       	ori	r22, 0xE9	; 233
  12:	74 38       	cpi	r23, 0x84	; 132
  14:	5f 74       	andi	r21, 0x4F	; 79
  16:	00 75       	andi	r16, 0x50	; 80
  18:	69 6e       	ori	r22, 0xE9	; 233
  1a:	74 31       	cpi	r23, 0x14	; 20
  1c:	36 5f       	subi	r19, 0xF6	; 246
  1e:	74 00       	.word	0x0074	; ????
  20:	5f 5f       	subi	r21, 0xFF	; 255
  22:	65 65       	ori	r22, 0x55	; 85
  24:	70 72       	andi	r23, 0x20	; 32
  26:	6f 6d       	ori	r22, 0xDF	; 223
  28:	00 55       	subi	r16, 0x50	; 80
  2a:	44 52       	subi	r20, 0x24	; 36
  2c:	30 00       	.word	0x0030	; ????
  2e:	55 43       	sbci	r21, 0x35	; 53
  30:	53 52       	subi	r21, 0x23	; 35
  32:	30 41       	sbci	r19, 0x10	; 16
  34:	00 55       	subi	r16, 0x50	; 80
  36:	43 53       	subi	r20, 0x33	; 51
  38:	52 30       	cpi	r21, 0x02	; 2
  3a:	42 00       	.word	0x0042	; ????
  3c:	55 43       	sbci	r21, 0x35	; 53
  3e:	53 52       	subi	r21, 0x23	; 35
  40:	30 43       	sbci	r19, 0x30	; 48
  42:	00 55       	subi	r16, 0x50	; 80
  44:	42 52       	subi	r20, 0x22	; 34
  46:	52 30       	cpi	r21, 0x02	; 2
  48:	00 54       	subi	r16, 0x40	; 64
  4a:	57 41       	sbci	r21, 0x17	; 23
  4c:	4d 52       	subi	r20, 0x2D	; 45
  4e:	00 54       	subi	r16, 0x40	; 64
  50:	57 42       	sbci	r21, 0x27	; 39
  52:	52 00       	.word	0x0052	; ????
  54:	54 57       	subi	r21, 0x74	; 116
  56:	43 52       	subi	r20, 0x23	; 35
  58:	00 54       	subi	r16, 0x40	; 64
  5a:	57 53       	subi	r21, 0x37	; 55
  5c:	52 00       	.word	0x0052	; ????
  5e:	54 57       	subi	r21, 0x74	; 116
  60:	44 52       	subi	r20, 0x24	; 36
  62:	00 54       	subi	r16, 0x40	; 64
  64:	57 41       	sbci	r21, 0x17	; 23
  66:	52 00       	.word	0x0052	; ????
  68:	54 49       	sbci	r21, 0x94	; 148
  6a:	4d 53       	subi	r20, 0x3D	; 61
  6c:	4b 31       	cpi	r20, 0x1B	; 27
  6e:	00 54       	subi	r16, 0x40	; 64
  70:	49 46       	sbci	r20, 0x69	; 105
  72:	52 31       	cpi	r21, 0x12	; 18
  74:	00 54       	subi	r16, 0x40	; 64
  76:	43 43       	sbci	r20, 0x33	; 51
  78:	52 31       	cpi	r21, 0x12	; 18
  7a:	41 00       	.word	0x0041	; ????
  7c:	54 43       	sbci	r21, 0x34	; 52
  7e:	43 52       	subi	r20, 0x23	; 35
  80:	31 42       	sbci	r19, 0x21	; 33
  82:	00 54       	subi	r16, 0x40	; 64
  84:	43 43       	sbci	r20, 0x33	; 51
  86:	52 31       	cpi	r21, 0x12	; 18
  88:	43 00       	.word	0x0043	; ????
  8a:	54 43       	sbci	r21, 0x34	; 52
  8c:	4e 54       	subi	r20, 0x4E	; 78
  8e:	31 00       	.word	0x0031	; ????
  90:	4f 43       	sbci	r20, 0x3F	; 63
  92:	52 31       	cpi	r21, 0x12	; 18
  94:	41 00       	.word	0x0041	; ????
  96:	4f 43       	sbci	r20, 0x3F	; 63
  98:	52 31       	cpi	r21, 0x12	; 18
  9a:	42 00       	.word	0x0042	; ????
  9c:	49 43       	sbci	r20, 0x39	; 57
  9e:	52 31       	cpi	r21, 0x12	; 18
  a0:	00 47       	sbci	r16, 0x70	; 112
  a2:	54 43       	sbci	r21, 0x34	; 52
  a4:	43 52       	subi	r20, 0x23	; 35
  a6:	00 54       	subi	r16, 0x40	; 64
  a8:	49 4d       	sbci	r20, 0xD9	; 217
  aa:	53 4b       	sbci	r21, 0xB3	; 179
  ac:	32 00       	.word	0x0032	; ????
  ae:	54 49       	sbci	r21, 0x94	; 148
  b0:	46 52       	subi	r20, 0x26	; 38
  b2:	32 00       	.word	0x0032	; ????
  b4:	54 43       	sbci	r21, 0x34	; 52
  b6:	43 52       	subi	r20, 0x23	; 35
  b8:	32 41       	sbci	r19, 0x12	; 18
  ba:	00 54       	subi	r16, 0x40	; 64
  bc:	43 43       	sbci	r20, 0x33	; 51
  be:	52 32       	cpi	r21, 0x22	; 34
  c0:	42 00       	.word	0x0042	; ????
  c2:	54 43       	sbci	r21, 0x34	; 52
  c4:	4e 54       	subi	r20, 0x4E	; 78
  c6:	32 00       	.word	0x0032	; ????
  c8:	4f 43       	sbci	r20, 0x3F	; 63
  ca:	52 32       	cpi	r21, 0x22	; 34
  cc:	42 00       	.word	0x0042	; ????
  ce:	4f 43       	sbci	r20, 0x3F	; 63
  d0:	52 32       	cpi	r21, 0x22	; 34
  d2:	41 00       	.word	0x0041	; ????
  d4:	41 53       	subi	r20, 0x31	; 49
  d6:	53 52       	subi	r21, 0x23	; 35
  d8:	00 47       	sbci	r16, 0x70	; 112
  da:	54 43       	sbci	r21, 0x34	; 52
  dc:	43 52       	subi	r20, 0x23	; 35
  de:	00 41       	sbci	r16, 0x10	; 16
  e0:	44 4d       	sbci	r20, 0xD4	; 212
  e2:	55 58       	subi	r21, 0x85	; 133
  e4:	00 41       	sbci	r16, 0x10	; 16
  e6:	44 43       	sbci	r20, 0x34	; 52
  e8:	00 41       	sbci	r16, 0x10	; 16
  ea:	44 43       	sbci	r20, 0x34	; 52
  ec:	53 52       	subi	r21, 0x23	; 35
  ee:	41 00       	.word	0x0041	; ????
  f0:	41 44       	sbci	r20, 0x41	; 65
  f2:	43 53       	subi	r20, 0x33	; 51
  f4:	52 42       	sbci	r21, 0x22	; 34
  f6:	00 44       	sbci	r16, 0x40	; 64
  f8:	49 44       	sbci	r20, 0x49	; 73
  fa:	52 30       	cpi	r21, 0x02	; 2
  fc:	00 41       	sbci	r16, 0x10	; 16
  fe:	43 53       	subi	r20, 0x33	; 51
 100:	52 00       	.word	0x0052	; ????
 102:	44 49       	sbci	r20, 0x94	; 148
 104:	44 52       	subi	r20, 0x24	; 36
 106:	31 00       	.word	0x0031	; ????
 108:	50 4f       	sbci	r21, 0xF0	; 240
 10a:	52 54       	subi	r21, 0x42	; 66
 10c:	42 00       	.word	0x0042	; ????
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	44 44       	sbci	r20, 0x44	; 68
 110:	52 42       	sbci	r21, 0x22	; 34
 112:	00 50       	subi	r16, 0x00	; 0
	uint8_t bit = digitalPinToBitMask(pin);
 114:	49 4e       	sbci	r20, 0xE9	; 233
 116:	42 00       	.word	0x0042	; ????
 118:	50 4f       	sbci	r21, 0xF0	; 240
	uint8_t port = digitalPinToPort(pin);
 11a:	52 54       	subi	r21, 0x42	; 66
 11c:	43 00       	.word	0x0043	; ????
 11e:	44 44       	sbci	r20, 0x44	; 68
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	52 43       	sbci	r21, 0x32	; 50
 122:	00 50       	subi	r16, 0x00	; 0

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	49 4e       	sbci	r20, 0xE9	; 233
 126:	43 00       	.word	0x0043	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	50 4f       	sbci	r21, 0xF0	; 240
 12a:	52 54       	subi	r21, 0x42	; 66
 12c:	44 00       	.word	0x0044	; ????
 12e:	44 44       	sbci	r20, 0x44	; 68
 130:	52 44       	sbci	r21, 0x42	; 66
 132:	00 50       	subi	r16, 0x00	; 0
 134:	49 4e       	sbci	r20, 0xE9	; 233

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	44 00       	.word	0x0044	; ????
 138:	4f 43       	sbci	r20, 0x3F	; 63
 13a:	52 30       	cpi	r21, 0x02	; 2
 13c:	42 00       	.word	0x0042	; ????
 13e:	4f 43       	sbci	r20, 0x3F	; 63
 140:	52 30       	cpi	r21, 0x02	; 2
 142:	41 00       	.word	0x0041	; ????

	uint8_t oldSREG = SREG;
 144:	54 43       	sbci	r21, 0x34	; 52
	cli();
 146:	4e 54       	subi	r20, 0x4E	; 78

	if (val == LOW) {
		*out &= ~bit;
 148:	30 00       	.word	0x0030	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	54 43       	sbci	r21, 0x34	; 52
 14c:	43 52       	subi	r20, 0x23	; 35
		*out &= ~bit;
 14e:	30 42       	sbci	r19, 0x20	; 32
 150:	00 54       	subi	r16, 0x40	; 64
	} else {
		*out |= bit;
 152:	43 43       	sbci	r20, 0x33	; 51
	}

	SREG = oldSREG;
 154:	52 30       	cpi	r21, 0x02	; 2
}
 156:	41 00       	.word	0x0041	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	54 49       	sbci	r21, 0x94	; 148
 15a:	4d 53       	subi	r20, 0x3D	; 61
 15c:	4b 30       	cpi	r20, 0x0B	; 11
 15e:	00 54       	subi	r16, 0x40	; 64
 160:	49 46       	sbci	r20, 0x69	; 105
 162:	52 30       	cpi	r21, 0x02	; 2
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	00 47       	sbci	r16, 0x70	; 112
 166:	54 43       	sbci	r21, 0x34	; 52
 168:	43 52       	subi	r20, 0x23	; 35
 16a:	00 45       	sbci	r16, 0x50	; 80
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	49 43       	sbci	r20, 0x39	; 57
 16e:	52 41       	sbci	r21, 0x12	; 18
 170:	00 45       	sbci	r16, 0x50	; 80
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	49 4d       	sbci	r20, 0xD9	; 217
 174:	53 4b       	sbci	r21, 0xB3	; 179
 176:	00 45       	sbci	r16, 0x50	; 80
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	49 46       	sbci	r20, 0x69	; 105
 17a:	52 00       	.word	0x0052	; ????
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17c:	50 43       	sbci	r21, 0x30	; 48
 17e:	49 43       	sbci	r20, 0x39	; 57
 180:	52 00       	.word	0x0052	; ????
 182:	50 43       	sbci	r21, 0x30	; 48
 184:	4d 53       	subi	r20, 0x3D	; 61
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	4b 32       	cpi	r20, 0x2B	; 43
 188:	00 50       	subi	r16, 0x00	; 0
 18a:	43 4d       	sbci	r20, 0xD3	; 211
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	53 4b       	sbci	r21, 0xB3	; 179
 18e:	31 00       	.word	0x0031	; ????
 190:	50 43       	sbci	r21, 0x30	; 48
 192:	4d 53       	subi	r20, 0x3D	; 61
 194:	4b 30       	cpi	r20, 0x0B	; 11
 196:	00 50       	subi	r16, 0x00	; 0
 198:	43 49       	sbci	r20, 0x93	; 147
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	46 52       	subi	r20, 0x26	; 38
 19c:	00 53       	subi	r16, 0x30	; 48

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	50 44       	sbci	r21, 0x40	; 64
 1a0:	52 00       	.word	0x0052	; ????
 1a2:	53 50       	subi	r21, 0x03	; 3
 1a4:	53 52       	subi	r21, 0x23	; 35
 1a6:	00 53       	subi	r16, 0x30	; 48
 1a8:	50 43       	sbci	r21, 0x30	; 48
 1aa:	52 00       	.word	0x0052	; ????
 1ac:	57 44       	sbci	r21, 0x47	; 71
 1ae:	54 43       	sbci	r21, 0x34	; 52
 1b0:	53 52       	subi	r21, 0x23	; 35
 1b2:	00 50       	subi	r16, 0x00	; 0
 1b4:	52 52       	subi	r21, 0x22	; 34
 1b6:	00 4f       	sbci	r16, 0xF0	; 240
 1b8:	53 43       	sbci	r21, 0x33	; 51
 1ba:	43 41       	sbci	r20, 0x13	; 19
 1bc:	4c 00       	.word	0x004c	; ????
 1be:	43 4c       	sbci	r20, 0xC3	; 195
 1c0:	4b 50       	subi	r20, 0x0B	; 11
 1c2:	52 00       	.word	0x0052	; ????
  size_t n = 0;
  while (size--) {
 1c4:	53 52       	subi	r21, 0x23	; 35
 1c6:	45 47       	sbci	r20, 0x75	; 117
 1c8:	00 53       	subi	r16, 0x30	; 48
    if (write(*buffer++)) n++;
 1ca:	50 00       	.word	0x0050	; ????
 1cc:	53 50       	subi	r21, 0x03	; 3
 1ce:	4d 43       	sbci	r20, 0x3D	; 61
 1d0:	53 52       	subi	r21, 0x23	; 35
 1d2:	00 4d       	sbci	r16, 0xD0	; 208
 1d4:	43 55       	subi	r20, 0x53	; 83
 1d6:	43 52       	subi	r20, 0x23	; 35
 1d8:	00 4d       	sbci	r16, 0xD0	; 208
 1da:	43 55       	subi	r20, 0x53	; 83
 1dc:	53 52       	subi	r21, 0x23	; 35
 1de:	00 53       	subi	r16, 0x30	; 48
    else break;
  }
  return n;
}
 1e0:	4d 43       	sbci	r20, 0x3D	; 61
 1e2:	52 00       	.word	0x0052	; ????
 1e4:	47 50       	subi	r20, 0x07	; 7
 1e6:	49 4f       	sbci	r20, 0xF9	; 249
 1e8:	52 32       	cpi	r21, 0x22	; 34
 1ea:	00 47       	sbci	r16, 0x70	; 112
 1ec:	50 49       	sbci	r21, 0x90	; 144
 1ee:	4f 52       	subi	r20, 0x2F	; 47
 1f0:	31 00       	.word	0x0031	; ????
 1f2:	47 50       	subi	r20, 0x07	; 7
 1f4:	49 4f       	sbci	r20, 0xF9	; 249
 1f6:	52 30       	cpi	r21, 0x02	; 2
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	00 45       	sbci	r16, 0x50	; 80
 1fa:	45 41       	sbci	r20, 0x15	; 21
    tail = _tx_buffer_tail;
 1fc:	52 00       	.word	0x0052	; ????
 1fe:	45 45       	sbci	r20, 0x55	; 85
 200:	44 52       	subi	r20, 0x24	; 36
 202:	00 45       	sbci	r16, 0x50	; 80
 204:	45 43       	sbci	r20, 0x35	; 53
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	52 00       	.word	0x0052	; ????
 208:	5f 74       	andi	r21, 0x4F	; 79
 20a:	78 5f       	subi	r23, 0xF8	; 248
 20c:	62 75       	andi	r22, 0x52	; 82
 20e:	66 66       	ori	r22, 0x66	; 102
 210:	65 72       	andi	r22, 0x25	; 37
  return tail - head - 1;
 212:	5f 68       	ori	r21, 0x8F	; 143
}
 214:	65 61       	ori	r22, 0x15	; 21
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	64 00       	.word	0x0064	; ????
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	5f 76       	andi	r21, 0x6F	; 111
 21a:	70 74       	andi	r23, 0x40	; 64
 21c:	72 2e       	mov	r7, r18
 21e:	50 72       	andi	r21, 0x20	; 32
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	69 6e       	ori	r22, 0xE9	; 233
 222:	74 00       	.word	0x0074	; ????
 224:	5f 72       	andi	r21, 0x2F	; 47
 226:	78 5f       	subi	r23, 0xF8	; 248
 228:	62 75       	andi	r22, 0x52	; 82
 22a:	66 66       	ori	r22, 0x66	; 102
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 22c:	65 72       	andi	r22, 0x25	; 37
 22e:	5f 74       	andi	r21, 0x4F	; 79
 230:	61 69       	ori	r22, 0x91	; 145
 232:	6c 00       	.word	0x006c	; ????
    return c;
 234:	77 72       	andi	r23, 0x27	; 39
 236:	69 74       	andi	r22, 0x49	; 73

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 238:	65 00       	.word	0x0065	; ????
 23a:	74 78       	andi	r23, 0x84	; 132
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 23c:	5f 62       	ori	r21, 0x2F	; 47
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 23e:	75 66       	ori	r23, 0x65	; 101
  if (_rx_buffer_head == _rx_buffer_tail) {
 240:	66 65       	ori	r22, 0x56	; 86
 242:	72 5f       	subi	r23, 0xF2	; 242
 244:	69 6e       	ori	r22, 0xE9	; 233
 246:	64 65       	ori	r22, 0x54	; 84
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 248:	78 5f       	subi	r23, 0xF8	; 248
 24a:	74 00       	.word	0x0074	; ????
 24c:	5f 5a       	subi	r21, 0xAF	; 175
 24e:	4e 36       	cpi	r20, 0x6E	; 110
 250:	53 74       	andi	r21, 0x43	; 67
 252:	72 65       	ori	r23, 0x52	; 82
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 254:	61 6d       	ori	r22, 0xD1	; 209
 256:	43 32       	cpi	r20, 0x23	; 35
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 258:	45 76       	andi	r20, 0x65	; 101
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 25a:	00 74       	andi	r16, 0x40	; 64
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 25c:	69 6d       	ori	r22, 0xD9	; 217
 25e:	65 72       	andi	r22, 0x25	; 37
 260:	30 5f       	subi	r19, 0xF0	; 240
 262:	66 72       	andi	r22, 0x26	; 38
 264:	61 63       	ori	r22, 0x31	; 49
 266:	74 00       	.word	0x0074	; ????
 268:	77 72       	andi	r23, 0x27	; 39
 26a:	69 74       	andi	r22, 0x49	; 73
}
 26c:	65 5f       	subi	r22, 0xF5	; 245
 26e:	65 72       	andi	r22, 0x25	; 37
 270:	72 6f       	ori	r23, 0xF2	; 242
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 272:	72 00       	.word	0x0072	; ????
 274:	53 65       	ori	r21, 0x53	; 83
 276:	72 69       	ori	r23, 0x92	; 146
 278:	61 6c       	ori	r22, 0xC1	; 193
 27a:	30 5f       	subi	r19, 0xF0	; 240
 27c:	61 76       	andi	r22, 0x61	; 97
 27e:	61 69       	ori	r22, 0x91	; 145
 280:	6c 61       	ori	r22, 0x1C	; 28
}
 282:	62 6c       	ori	r22, 0xC2	; 194
 284:	65 00       	.word	0x0065	; ????
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 286:	73 69       	ori	r23, 0x93	; 147
 288:	7a 65       	ori	r23, 0x5A	; 90
 28a:	5f 74       	andi	r21, 0x4F	; 79
 28c:	00 6d       	ori	r16, 0xD0	; 208
 28e:	61 69       	ori	r22, 0x91	; 145
 290:	6e 00       	.word	0x006e	; ????
 292:	5f 5a       	subi	r21, 0xAF	; 175
 294:	31 34       	cpi	r19, 0x41	; 65
 296:	73 65       	ori	r23, 0x53	; 83
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 298:	72 69       	ori	r23, 0x92	; 146
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 29a:	61 6c       	ori	r22, 0xC1	; 193
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 29c:	45 76       	andi	r20, 0x65	; 101
 29e:	65 6e       	ori	r22, 0xE5	; 229
 2a0:	74 52       	subi	r23, 0x24	; 36
 2a2:	75 6e       	ori	r23, 0xE5	; 229
 2a4:	76 2e       	mov	r7, r22
 2a6:	70 61       	ori	r23, 0x10	; 16
 2a8:	72 74       	andi	r23, 0x42	; 66
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2aa:	2e 31       	cpi	r18, 0x1E	; 30
 2ac:	00 62       	ori	r16, 0x20	; 32
 2ae:	65 67       	ori	r22, 0x75	; 117
 2b0:	69 6e       	ori	r22, 0xE9	; 233
 2b2:	00 69       	ori	r16, 0x90	; 144
 2b4:	6e 69       	ori	r22, 0x9E	; 158

  *_udr = c;
 2b6:	74 56       	subi	r23, 0x64	; 100
 2b8:	61 72       	andi	r22, 0x21	; 33
 2ba:	69 61       	ori	r22, 0x19	; 25
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 2bc:	6e 74       	andi	r22, 0x4E	; 78
 2be:	00 5f       	subi	r16, 0xF0	; 240
 2c0:	5a 4e       	sbci	r21, 0xEA	; 234
 2c2:	31 34       	cpi	r19, 0x41	; 65
 2c4:	48 61       	ori	r20, 0x18	; 24
 2c6:	72 64       	ori	r23, 0x42	; 66
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 2c8:	77 61       	ori	r23, 0x17	; 23
 2ca:	72 65       	ori	r23, 0x52	; 82
 2cc:	53 65       	ori	r21, 0x53	; 83
 2ce:	72 69       	ori	r23, 0x92	; 146
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 2d0:	61 6c       	ori	r22, 0xC1	; 193
 2d2:	35 66       	ori	r19, 0x65	; 101
 2d4:	6c 75       	andi	r22, 0x5C	; 92
 2d6:	73 68       	ori	r23, 0x83	; 131
 2d8:	45 76       	andi	r20, 0x65	; 101
 2da:	2e 70       	andi	r18, 0x0E	; 14
  }
}
 2dc:	61 72       	andi	r22, 0x21	; 33
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 2de:	74 2e       	mov	r7, r20
 2e0:	33 00       	.word	0x0033	; ????
 2e2:	5f 5a       	subi	r21, 0xAF	; 175
 2e4:	4e 31       	cpi	r20, 0x1E	; 30
 2e6:	34 48       	sbci	r19, 0x84	; 132
 2e8:	61 72       	andi	r22, 0x21	; 33
 2ea:	64 77       	andi	r22, 0x74	; 116
  _written = true;
 2ec:	61 72       	andi	r22, 0x21	; 33
 2ee:	65 53       	subi	r22, 0x35	; 53
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 2f0:	65 72       	andi	r22, 0x25	; 37
 2f2:	69 61       	ori	r22, 0x19	; 25
 2f4:	6c 43       	sbci	r22, 0x3C	; 60
 2f6:	32 45       	sbci	r19, 0x52	; 82
 2f8:	50 56       	subi	r21, 0x60	; 96
 2fa:	68 53       	subi	r22, 0x38	; 56
 2fc:	31 5f       	subi	r19, 0xF1	; 241
 2fe:	53 31       	cpi	r21, 0x13	; 19
 300:	5f 53       	subi	r21, 0x3F	; 63
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 302:	31 5f       	subi	r19, 0xF1	; 241
 304:	53 31       	cpi	r21, 0x13	; 19
      *_udr = c;
 306:	5f 53       	subi	r21, 0x3F	; 63
 308:	31 5f       	subi	r19, 0xF1	; 241
 30a:	00 72       	andi	r16, 0x20	; 32
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 30c:	61 6e       	ori	r22, 0xE1	; 225
 30e:	64 4e       	sbci	r22, 0xE4	; 228
 310:	75 6d       	ori	r23, 0xD5	; 213
 312:	62 65       	ori	r22, 0x52	; 82
 314:	72 31       	cpi	r23, 0x12	; 18
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 316:	00 6d       	ori	r16, 0xD0	; 208
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 318:	6f 64       	ori	r22, 0x4F	; 79
  }
  
  return 1;
}
 31a:	65 00       	.word	0x0065	; ????
 31c:	64 69       	ori	r22, 0x94	; 148
 31e:	67 69       	ori	r22, 0x97	; 151
 320:	74 61       	ori	r23, 0x14	; 20
 322:	6c 5f       	subi	r22, 0xFC	; 252
 324:	70 69       	ori	r23, 0x90	; 144
 326:	6e 5f       	subi	r22, 0xFE	; 254
 328:	74 6f       	ori	r23, 0xF4	; 244
 32a:	5f 74       	andi	r21, 0x4F	; 79
 32c:	69 6d       	ori	r22, 0xD9	; 217
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 32e:	65 72       	andi	r22, 0x25	; 37
 330:	5f 50       	subi	r21, 0x0F	; 15
 332:	47 4d       	sbci	r20, 0xD7	; 215
 334:	00 63       	ori	r16, 0x30	; 48
 336:	6f 6e       	ori	r22, 0xEF	; 239
 338:	66 69       	ori	r22, 0x96	; 150
 33a:	67 00       	.word	0x0067	; ????
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 33c:	75 69       	ori	r23, 0x95	; 149
 33e:	6e 74       	andi	r22, 0x4E	; 78
 340:	38 5f       	subi	r19, 0xF8	; 248
    if (bit_is_clear(SREG, SREG_I)) {
 342:	74 00       	.word	0x0074	; ????
 344:	73 65       	ori	r23, 0x53	; 83
 346:	72 69       	ori	r23, 0x92	; 146
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 348:	61 6c       	ori	r22, 0xC1	; 193
 34a:	45 76       	andi	r20, 0x65	; 101
 34c:	65 6e       	ori	r22, 0xE5	; 229
 34e:	74 52       	subi	r23, 0x24	; 36
 350:	75 6e       	ori	r23, 0xE5	; 229
	_tx_udr_empty_irq();
 352:	00 74       	andi	r16, 0x40	; 64
 354:	69 6d       	ori	r22, 0xD9	; 217
 356:	65 72       	andi	r22, 0x25	; 37
 358:	00 62       	ori	r16, 0x20	; 32
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 35a:	6f 6f       	ori	r22, 0xFF	; 255
 35c:	6c 00       	.word	0x006c	; ????
 35e:	5f 5f       	subi	r21, 0xFF	; 255
 360:	61 64       	ori	r22, 0x41	; 65
 362:	64 72       	andi	r22, 0x24	; 36
 364:	31 36       	cpi	r19, 0x61	; 97
 366:	00 5f       	subi	r16, 0xF0	; 240

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 368:	72 78       	andi	r23, 0x82	; 130
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 36a:	5f 62       	ori	r21, 0x2F	; 47
    _tx_buffer_head = i;
 36c:	75 66       	ori	r23, 0x65	; 101
    sbi(*_ucsrb, UDRIE0);
 36e:	66 65       	ori	r22, 0x56	; 86
 370:	72 5f       	subi	r23, 0xF2	; 242
 372:	68 65       	ori	r22, 0x58	; 88
 374:	61 64       	ori	r22, 0x41	; 65
 376:	00 73       	andi	r16, 0x30	; 48
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 378:	65 74       	andi	r22, 0x45	; 69
 37a:	75 70       	andi	r23, 0x05	; 5
 37c:	00 73       	andi	r16, 0x30	; 48
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 37e:	72 65       	ori	r23, 0x52	; 82
 380:	67 5f       	subi	r22, 0xF7	; 247
 382:	73 61       	ori	r23, 0x13	; 19
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 384:	76 65       	ori	r23, 0x56	; 86
 386:	00 72       	andi	r16, 0x20	; 32
 388:	65 61       	ori	r22, 0x15	; 21
 38a:	64 00       	.word	0x0064	; ????
 38c:	70 69       	ori	r23, 0x90	; 144
 38e:	6e 4d       	sbci	r22, 0xDE	; 222
 390:	6f 64       	ori	r22, 0x4F	; 79
 392:	65 00       	.word	0x0065	; ????
 394:	5f 72       	andi	r21, 0x2F	; 47
 396:	78 5f       	subi	r23, 0xF8	; 248
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 398:	63 6f       	ori	r22, 0xF3	; 243
 39a:	6d 70       	andi	r22, 0x0D	; 13
 39c:	6c 65       	ori	r22, 0x5C	; 92
 39e:	74 65       	ori	r23, 0x54	; 84
 3a0:	5f 69       	ori	r21, 0x9F	; 159
 3a2:	72 71       	andi	r23, 0x12	; 18
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 3a4:	00 66       	ori	r16, 0x60	; 96
 3a6:	6c 75       	andi	r22, 0x5C	; 92
 3a8:	73 68       	ori	r23, 0x83	; 131
	  _tx_udr_empty_irq();
 3aa:	00 5f       	subi	r16, 0xF0	; 240
 3ac:	5a 4e       	sbci	r21, 0xEA	; 234
 3ae:	35 50       	subi	r19, 0x05	; 5
 3b0:	72 69       	ori	r23, 0x92	; 146
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3b2:	6e 74       	andi	r22, 0x4E	; 78
 3b4:	35 77       	andi	r19, 0x75	; 117
 3b6:	72 69       	ori	r23, 0x92	; 146
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 3b8:	74 65       	ori	r23, 0x54	; 84
 3ba:	45 50       	subi	r20, 0x05	; 5
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 3bc:	4b 63       	ori	r20, 0x3B	; 59
 3be:	2e 70       	andi	r18, 0x0E	; 14
 3c0:	61 72       	andi	r22, 0x21	; 33
 3c2:	74 2e       	mov	r7, r20
 3c4:	32 00       	.word	0x0032	; ????
 3c6:	74 69       	ori	r23, 0x94	; 148
 3c8:	6d 65       	ori	r22, 0x5D	; 93
 3ca:	72 30       	cpi	r23, 0x02	; 2
 3cc:	5f 6d       	ori	r21, 0xDF	; 223
 3ce:	69 6c       	ori	r22, 0xC9	; 201
 3d0:	6c 69       	ori	r22, 0x9C	; 156
 3d2:	73 00       	.word	0x0073	; ????
 3d4:	61 76       	andi	r22, 0x61	; 97
 3d6:	61 69       	ori	r22, 0x91	; 145
 3d8:	6c 61       	ori	r22, 0x1C	; 28
 3da:	62 6c       	ori	r22, 0xC2	; 194
 3dc:	65 46       	sbci	r22, 0x65	; 101
 3de:	6f 72       	andi	r22, 0x2F	; 47
 3e0:	57 72       	andi	r21, 0x27	; 39
 3e2:	69 74       	andi	r22, 0x49	; 73
 3e4:	65 00       	.word	0x0065	; ????
 3e6:	5f 75       	andi	r21, 0x5F	; 95
{
  size_t n = print(c);
  n += println();
  return n;
}
 3e8:	62 72       	andi	r22, 0x22	; 34
 3ea:	72 68       	ori	r23, 0x82	; 130
 3ec:	00 70       	andi	r16, 0x00	; 0
 3ee:	6f 72       	andi	r22, 0x2F	; 47
 3f0:	74 5f       	subi	r23, 0xF4	; 244
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3f2:	74 6f       	ori	r23, 0xF4	; 244
 3f4:	5f 6d       	ori	r21, 0xDF	; 223
 3f6:	6f 64       	ori	r22, 0x4F	; 79
 3f8:	65 5f       	subi	r22, 0xF5	; 245
 3fa:	50 47       	sbci	r21, 0x70	; 112
 3fc:	4d 00       	.word	0x004d	; ????
 3fe:	3c 61       	ori	r19, 0x1C	; 28
 400:	72 74       	andi	r23, 0x42	; 66
 402:	69 66       	ori	r22, 0x69	; 105
 404:	69 63       	ori	r22, 0x39	; 57
 406:	69 61       	ori	r22, 0x19	; 25
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 408:	6c 3e       	cpi	r22, 0xEC	; 236
 40a:	00 62       	ori	r16, 0x20	; 32
 40c:	61 75       	andi	r22, 0x51	; 81
 40e:	64 00       	.word	0x0064	; ????
 410:	6f 6c       	ori	r22, 0xCF	; 207
 412:	64 53       	subi	r22, 0x34	; 52
 414:	52 45       	sbci	r21, 0x52	; 82
 416:	47 00       	.word	0x0047	; ????
	unsigned char f = timer0_fract;
 418:	5f 5f       	subi	r21, 0xFF	; 255
 41a:	69 6e       	ori	r22, 0xE9	; 233

	m += MILLIS_INC;
	f += FRACT_INC;
 41c:	69 74       	andi	r22, 0x49	; 73
 41e:	69 61       	ori	r22, 0x19	; 25
	if (f >= FRACT_MAX) {
 420:	6c 69       	ori	r22, 0x9C	; 156
 422:	7a 65       	ori	r23, 0x5A	; 90
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 424:	5f 70       	andi	r21, 0x0F	; 15
 426:	00 72       	andi	r16, 0x20	; 32
 428:	78 5f       	subi	r23, 0xF8	; 248
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 42a:	62 75       	andi	r22, 0x52	; 82
 42c:	66 66       	ori	r22, 0x66	; 102
	timer0_millis = m;
 42e:	65 72       	andi	r22, 0x25	; 37
 430:	5f 69       	ori	r21, 0x9F	; 159
 432:	6e 64       	ori	r22, 0x4E	; 78
 434:	65 78       	andi	r22, 0x85	; 133
 436:	5f 74       	andi	r21, 0x4F	; 79
 438:	00 75       	andi	r16, 0x50	; 80
 43a:	6e 73       	andi	r22, 0x3E	; 62
 43c:	69 67       	ori	r22, 0x79	; 121
	timer0_overflow_count++;
 43e:	6e 65       	ori	r22, 0x5E	; 94
 440:	64 20       	and	r6, r4
 442:	63 68       	ori	r22, 0x83	; 131
 444:	61 72       	andi	r22, 0x21	; 33
 446:	00 5f       	subi	r16, 0xF0	; 240
 448:	5a 4e       	sbci	r21, 0xEA	; 234
 44a:	31 34       	cpi	r19, 0x41	; 65
 44c:	48 61       	ori	r20, 0x18	; 24
 44e:	72 64       	ori	r23, 0x42	; 66
 450:	77 61       	ori	r23, 0x17	; 23
 452:	72 65       	ori	r23, 0x52	; 82
 454:	53 65       	ori	r21, 0x53	; 83
 456:	72 69       	ori	r23, 0x92	; 146
 458:	61 6c       	ori	r22, 0xC1	; 193
 45a:	31 36       	cpi	r19, 0x61	; 97
 45c:	5f 72       	andi	r21, 0x2F	; 47
 45e:	78 5f       	subi	r23, 0xF8	; 248
 460:	63 6f       	ori	r22, 0xF3	; 243
 462:	6d 70       	andi	r22, 0x0D	; 13
}
 464:	6c 65       	ori	r22, 0x5C	; 92
 466:	74 65       	ori	r23, 0x54	; 84
 468:	5f 69       	ori	r21, 0x9F	; 159
 46a:	72 71       	andi	r23, 0x12	; 18
 46c:	45 76       	andi	r20, 0x65	; 101
 46e:	2e 70       	andi	r18, 0x0E	; 14
 470:	61 72       	andi	r22, 0x21	; 33
 472:	74 2e       	mov	r7, r20
 474:	30 00       	.word	0x0030	; ????
 476:	72 61       	ori	r23, 0x12	; 18
 478:	6e 64       	ori	r22, 0x4E	; 78
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 47a:	4e 75       	andi	r20, 0x5E	; 94
 47c:	6d 62       	ori	r22, 0x2D	; 45
		m += 1;
 47e:	65 72       	andi	r22, 0x25	; 37
 480:	32 00       	.word	0x0032	; ????
 482:	5f 74       	andi	r21, 0x4F	; 79
 484:	78 5f       	subi	r23, 0xF8	; 248
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 486:	62 75       	andi	r22, 0x52	; 82
 488:	66 66       	ori	r22, 0x66	; 102
 48a:	65 72       	andi	r22, 0x25	; 37
 48c:	5f 74       	andi	r21, 0x4F	; 79
 48e:	61 69       	ori	r22, 0x91	; 145
 490:	6c 00       	.word	0x006c	; ????
 492:	5f 5f       	subi	r21, 0xFF	; 255
 494:	54 6f       	ori	r21, 0xF4	; 244
 496:	44 6f       	ori	r20, 0xF4	; 244
 498:	00 70       	andi	r16, 0x00	; 0
 49a:	72 69       	ori	r23, 0x92	; 146
 49c:	6e 74       	andi	r22, 0x4E	; 78
 49e:	00 43       	sbci	r16, 0x30	; 48
 4a0:	3a 5c       	subi	r19, 0xCA	; 202
 4a2:	55 73       	andi	r21, 0x35	; 53
 4a4:	65 72       	andi	r22, 0x25	; 37
 4a6:	73 5c       	subi	r23, 0xC3	; 195
  Serial._tx_udr_empty_irq();
 4a8:	52 79       	andi	r21, 0x92	; 146
 4aa:	61 6e       	ori	r22, 0xE1	; 225
 4ac:	79 75       	andi	r23, 0x59	; 89
 4ae:	32 2d       	mov	r19, r2
}
 4b0:	61 64       	ori	r22, 0x41	; 65
 4b2:	6d 69       	ori	r22, 0x9D	; 157
 4b4:	6e 5c       	subi	r22, 0xCE	; 206
 4b6:	44 65       	ori	r20, 0x54	; 84
 4b8:	73 6b       	ori	r23, 0xB3	; 179
 4ba:	74 6f       	ori	r23, 0xF4	; 244
 4bc:	70 5c       	subi	r23, 0xC0	; 192
 4be:	42 55       	subi	r20, 0x52	; 82
 4c0:	20 50       	subi	r18, 0x00	; 0
 4c2:	48 44       	sbci	r20, 0x48	; 72
 4c4:	5c 53       	subi	r21, 0x3C	; 60
 4c6:	70 72       	andi	r23, 0x20	; 32
 4c8:	69 6e       	ori	r22, 0xE9	; 233
 4ca:	67 20       	and	r6, r7
 4cc:	32 30       	cpi	r19, 0x02	; 2
 4ce:	5c 50       	subi	r21, 0x0C	; 12
 4d0:	46 50       	subi	r20, 0x06	; 6
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4d2:	5c 41       	sbci	r21, 0x1C	; 28
 4d4:	72 64       	ori	r23, 0x42	; 66
 4d6:	75 69       	ori	r23, 0x95	; 149
 4d8:	6e 6f       	ori	r22, 0xFE	; 254
 4da:	41 73       	andi	r20, 0x31	; 49
 4dc:	73 65       	ori	r23, 0x53	; 83
 4de:	6d 62       	ori	r22, 0x2D	; 45
 4e0:	6c 79       	andi	r22, 0x9C	; 156
 4e2:	50 61       	ori	r21, 0x10	; 16
 4e4:	72 73       	andi	r23, 0x32	; 50

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 4e6:	65 72       	andi	r22, 0x25	; 37
 4e8:	5c 50       	subi	r21, 0x0C	; 12
 4ea:	61 72       	andi	r22, 0x21	; 33
 4ec:	73 65       	ori	r23, 0x53	; 83
 4ee:	72 49       	sbci	r23, 0x92	; 146
 4f0:	6e 70       	andi	r22, 0x0E	; 14
 4f2:	75 74       	andi	r23, 0x45	; 69
 4f4:	46 69       	ori	r20, 0x96	; 150
 4f6:	6c 65       	ori	r22, 0x5C	; 92
 4f8:	73 5c       	subi	r23, 0xC3	; 195
 4fa:	52 61       	ori	r21, 0x12	; 18
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 4fc:	77 41       	sbci	r23, 0x17	; 23
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 4fe:	72 64       	ori	r23, 0x42	; 66
 500:	75 69       	ori	r23, 0x95	; 149
 502:	6e 6f       	ori	r22, 0xFE	; 254
 504:	46 69       	ori	r20, 0x96	; 150

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 506:	6c 65       	ori	r22, 0x5C	; 92
 508:	73 5c       	subi	r23, 0xC3	; 195
 50a:	56 32       	cpi	r21, 0x26	; 38
 50c:	5c 70       	andi	r21, 0x0C	; 12
      _rx_buffer[_rx_buffer_head] = c;
 50e:	72 65       	ori	r23, 0x52	; 82
 510:	4d 75       	andi	r20, 0x5D	; 93
 512:	6c 74       	andi	r22, 0x4C	; 76
 514:	00 70       	andi	r16, 0x00	; 0
 516:	6f 72       	andi	r22, 0x2F	; 47
 518:	74 5f       	subi	r23, 0xF4	; 244
      _rx_buffer_head = i;
 51a:	74 6f       	ori	r23, 0xF4	; 244
 51c:	5f 6f       	ori	r21, 0xFF	; 255
    Serial._rx_complete_irq();
  }
 51e:	75 74       	andi	r23, 0x45	; 69
 520:	70 75       	andi	r23, 0x50	; 80
 522:	74 5f       	subi	r23, 0xF4	; 244
 524:	50 47       	sbci	r21, 0x70	; 112
 526:	4d 00       	.word	0x004d	; ????
 528:	62 61       	ori	r22, 0x12	; 18
 52a:	75 64       	ori	r23, 0x45	; 69
 52c:	5f 73       	andi	r21, 0x3F	; 63
 52e:	65 74       	andi	r22, 0x45	; 69
 530:	74 69       	ori	r23, 0x94	; 148
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 532:	6e 67       	ori	r22, 0x7E	; 126
 534:	00 5f       	subi	r16, 0xF0	; 240

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 536:	5f 69       	ori	r21, 0x9F	; 159
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 538:	52 65       	ori	r21, 0x52	; 82
 53a:	73 74       	andi	r23, 0x43	; 67
 53c:	6f 72       	andi	r22, 0x2F	; 47
	sbi(TCCR0A, WGM00);
 53e:	65 00       	.word	0x0065	; ????
 540:	5f 5f       	subi	r21, 0xFF	; 255
 542:	72 65       	ori	r23, 0x52	; 82
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 544:	73 75       	andi	r23, 0x53	; 83
 546:	6c 74       	andi	r22, 0x4C	; 76
 548:	00 74       	andi	r16, 0x40	; 64
	sbi(TCCR0B, CS00);
 54a:	75 72       	andi	r23, 0x25	; 37
 54c:	6e 4f       	sbci	r22, 0xFE	; 254
 54e:	66 66       	ori	r22, 0x66	; 102

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 550:	50 57       	subi	r21, 0x70	; 112
 552:	4d 2e       	mov	r4, r29
 554:	70 61       	ori	r23, 0x10	; 16
 556:	72 74       	andi	r23, 0x42	; 66
 558:	2e 30       	cpi	r18, 0x0E	; 14
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 55a:	00 74       	andi	r16, 0x40	; 64
 55c:	69 6d       	ori	r22, 0xD9	; 217

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 55e:	65 72       	andi	r22, 0x25	; 37
 560:	30 5f       	subi	r19, 0xF0	; 240
 562:	6f 76       	andi	r22, 0x6F	; 111
 564:	65 72       	andi	r22, 0x25	; 37
 566:	66 6c       	ori	r22, 0xC6	; 198
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 568:	6f 77       	andi	r22, 0x7F	; 127
 56a:	5f 63       	ori	r21, 0x3F	; 63
 56c:	6f 75       	andi	r22, 0x5F	; 95
 56e:	6e 74       	andi	r22, 0x4E	; 78
 570:	00 53       	subi	r16, 0x30	; 48
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 572:	74 72       	andi	r23, 0x24	; 36
 574:	65 61       	ori	r22, 0x15	; 21
 576:	6d 00       	.word	0x006d	; ????
 578:	75 69       	ori	r23, 0x95	; 149
 57a:	6e 74       	andi	r22, 0x4E	; 78

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 57c:	31 36       	cpi	r19, 0x61	; 97
 57e:	5f 74       	andi	r21, 0x4F	; 79
 580:	00 5f       	subi	r16, 0xF0	; 240
 582:	74 78       	andi	r23, 0x84	; 132
 584:	5f 75       	andi	r21, 0x5F	; 95

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 586:	64 72       	andi	r22, 0x24	; 36
 588:	5f 65       	ori	r21, 0x5F	; 95
 58a:	6d 70       	andi	r22, 0x0D	; 13
 58c:	74 79       	andi	r23, 0x94	; 148
 58e:	5f 69       	ori	r21, 0x9F	; 159
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 590:	72 71       	andi	r23, 0x12	; 18
 592:	00 70       	andi	r16, 0x00	; 0
 594:	72 69       	ori	r23, 0x92	; 146
 596:	6e 74       	andi	r22, 0x4E	; 78
 598:	6c 6e       	ori	r22, 0xEC	; 236
		sbi(ADCSRA, ADPS1);
 59a:	00 5f       	subi	r16, 0xF0	; 240
 59c:	5f 73       	andi	r21, 0x3F	; 63
 59e:	74 61       	ori	r23, 0x14	; 20
 5a0:	74 69       	ori	r23, 0x94	; 148
 5a2:	63 5f       	subi	r22, 0xF3	; 243
		sbi(ADCSRA, ADPS0);
 5a4:	69 6e       	ori	r22, 0xE9	; 233
 5a6:	69 74       	andi	r22, 0x49	; 73
 5a8:	69 61       	ori	r22, 0x19	; 25
 5aa:	6c 69       	ori	r22, 0x9C	; 156
 5ac:	7a 61       	ori	r23, 0x1A	; 26
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 5ae:	74 69       	ori	r23, 0x94	; 148
 5b0:	6f 6e       	ori	r22, 0xEF	; 239
 5b2:	5f 61       	ori	r21, 0x1F	; 31
 5b4:	6e 64       	ori	r22, 0x4E	; 78
 5b6:	5f 64       	ori	r21, 0x4F	; 79
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 5b8:	65 73       	andi	r22, 0x35	; 53
 5ba:	74 72       	andi	r23, 0x24	; 36
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 5bc:	75 63       	ori	r23, 0x35	; 53
 5be:	74 69       	ori	r23, 0x94	; 148
 5c0:	6f 6e       	ori	r22, 0xEF	; 239
	uint8_t port = digitalPinToPort(pin);
 5c2:	5f 30       	cpi	r21, 0x0F	; 15
 5c4:	00 5f       	subi	r16, 0xF0	; 240
 5c6:	5f 70       	andi	r21, 0x0F	; 15
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 5c8:	72 69       	ori	r23, 0x92	; 146
 5ca:	6f 72       	andi	r22, 0x2F	; 47

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 5cc:	69 74       	andi	r22, 0x49	; 73
 5ce:	79 00       	.word	0x0079	; ????
 5d0:	74 68       	ori	r23, 0x84	; 132
 5d2:	69 73       	andi	r22, 0x39	; 57
 5d4:	00 5f       	subi	r16, 0xF0	; 240
 5d6:	47 4c       	sbci	r20, 0xC7	; 199
 5d8:	4f 42       	sbci	r20, 0x2F	; 47
 5da:	41 4c       	sbci	r20, 0xC1	; 193
	out = portOutputRegister(port);
 5dc:	5f 5f       	subi	r21, 0xFF	; 255
 5de:	73 75       	andi	r23, 0x53	; 83
 5e0:	62 5f       	subi	r22, 0xF2	; 242
 5e2:	49 5f       	subi	r20, 0xF9	; 249
 5e4:	5f 5f       	subi	r21, 0xFF	; 255
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 5e6:	76 65       	ori	r23, 0x56	; 86
                cli();
 5e8:	63 74       	andi	r22, 0x43	; 67
		*reg |= bit;
 5ea:	6f 72       	andi	r22, 0x2F	; 47
 5ec:	5f 31       	cpi	r21, 0x1F	; 31
 5ee:	38 00       	.word	0x0038	; ????
		SREG = oldSREG;
 5f0:	74 75       	andi	r23, 0x54	; 84

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 5f2:	72 6e       	ori	r23, 0xE2	; 226
 5f4:	4f 66       	ori	r20, 0x6F	; 111
 5f6:	66 50       	subi	r22, 0x06	; 6
 5f8:	57 4d       	sbci	r21, 0xD7	; 215
 5fa:	00 48       	sbci	r16, 0x80	; 128
 5fc:	61 72       	andi	r22, 0x21	; 33
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5fe:	64 77       	andi	r22, 0x74	; 116
 600:	61 72       	andi	r22, 0x21	; 33
 602:	65 53       	subi	r22, 0x35	; 53
 604:	65 72       	andi	r22, 0x25	; 37
 606:	69 61       	ori	r22, 0x19	; 25
  *_ubrrl = baud_setting;
 608:	6c 00       	.word	0x006c	; ????
 60a:	5f 5a       	subi	r21, 0xAF	; 175
 60c:	4e 35       	cpi	r20, 0x5E	; 94
 60e:	50 72       	andi	r21, 0x20	; 32
 610:	69 6e       	ori	r22, 0xE9	; 233
 612:	74 43       	sbci	r23, 0x34	; 52

  _written = false;
 614:	32 45       	sbci	r19, 0x52	; 82
 616:	76 00       	.word	0x0076	; ????

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 618:	72 61       	ori	r23, 0x12	; 18
 61a:	6e 64       	ori	r22, 0x4E	; 78
 61c:	6f 6d       	ori	r22, 0xDF	; 223
 61e:	53 65       	ori	r21, 0x53	; 83
 620:	65 64       	ori	r22, 0x45	; 69
 622:	00 64       	ori	r16, 0x40	; 64
  
  sbi(*_ucsrb, RXEN0);
 624:	69 67       	ori	r22, 0x79	; 121
 626:	69 74       	andi	r22, 0x49	; 73
 628:	61 6c       	ori	r22, 0xC1	; 193
 62a:	57 72       	andi	r21, 0x27	; 39
 62c:	69 74       	andi	r22, 0x49	; 73
 62e:	65 00       	.word	0x0065	; ????
 630:	70 65       	ori	r23, 0x50	; 80
  sbi(*_ucsrb, TXEN0);
 632:	65 6b       	ori	r22, 0xB5	; 181
 634:	00 70       	andi	r16, 0x00	; 0
 636:	6f 72       	andi	r22, 0x2F	; 47
 638:	74 00       	.word	0x0074	; ????
 63a:	5f 74       	andi	r21, 0x4F	; 79
 63c:	78 5f       	subi	r23, 0xF8	; 248
 63e:	62 75       	andi	r22, 0x52	; 82
  sbi(*_ucsrb, RXCIE0);
 640:	66 66       	ori	r22, 0x66	; 102
 642:	65 72       	andi	r22, 0x25	; 37
 644:	00 5f       	subi	r16, 0xF0	; 240
 646:	5f 62       	ori	r21, 0x2F	; 47
 648:	61 73       	andi	r22, 0x31	; 49
 64a:	65 5f       	subi	r22, 0xF5	; 245
 64c:	63 74       	andi	r22, 0x43	; 67
  cbi(*_ucsrb, UDRIE0);
 64e:	6f 72       	andi	r22, 0x2F	; 47
 650:	20 00       	.word	0x0020	; ????
 652:	6c 6f       	ori	r22, 0xFC	; 252
 654:	6e 67       	ori	r22, 0x7E	; 126
 656:	20 75       	andi	r18, 0x50	; 80
 658:	6e 73       	andi	r22, 0x3E	; 62
 65a:	69 67       	ori	r22, 0x79	; 121
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
 65c:	6e 65       	ori	r22, 0x5E	; 94
 65e:	64 20       	and	r6, r4
 660:	69 6e       	ori	r22, 0xE9	; 233
 662:	74 00       	.word	0x0074	; ????
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
 664:	64 69       	ori	r22, 0x94	; 148
 666:	67 69       	ori	r22, 0x97	; 151
 668:	74 61       	ori	r23, 0x14	; 20
 66a:	6c 5f       	subi	r22, 0xFC	; 252
 66c:	70 69       	ori	r23, 0x90	; 144
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
 66e:	6e 5f       	subi	r22, 0xFE	; 254
 670:	74 6f       	ori	r23, 0xF4	; 244
 672:	5f 70       	andi	r21, 0x0F	; 15
 674:	6f 72       	andi	r22, 0x2F	; 47
 676:	74 5f       	subi	r23, 0xF4	; 244
 678:	50 47       	sbci	r21, 0x70	; 112
 67a:	4d 00       	.word	0x004d	; ????
 67c:	5f 5f       	subi	r21, 0xFF	; 255
 67e:	76 65       	ori	r23, 0x56	; 86
 680:	63 74       	andi	r22, 0x43	; 67
 682:	6f 72       	andi	r22, 0x2F	; 47
 684:	5f 31       	cpi	r21, 0x1F	; 31
 686:	36 00       	.word	0x0036	; ????
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
 688:	5f 75       	andi	r21, 0x5F	; 95
 68a:	62 72       	andi	r22, 0x22	; 34
 68c:	72 6c       	ori	r23, 0xC2	; 194
 68e:	00 47       	sbci	r16, 0x70	; 112
 690:	4e 55       	subi	r20, 0x5E	; 94
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
 692:	20 47       	sbci	r18, 0x70	; 112
 694:	49 4d       	sbci	r20, 0xD9	; 217
 696:	50 4c       	sbci	r21, 0xC0	; 192
 698:	45 20       	and	r4, r5
 69a:	37 2e       	mov	r3, r23
 69c:	33 2e       	mov	r3, r19
 69e:	30 20       	and	r3, r0
 6a0:	2d 6d       	ori	r18, 0xDD	; 221
 6a2:	6e 2d       	mov	r22, r14
 6a4:	66 6c       	ori	r22, 0xC6	; 198
 6a6:	61 73       	andi	r22, 0x31	; 49
 6a8:	68 3d       	cpi	r22, 0xD8	; 216
 6aa:	31 20       	and	r3, r1
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
 6ac:	2d 6d       	ori	r18, 0xDD	; 221
 6ae:	6d 63       	ori	r22, 0x3D	; 61
 6b0:	75 3d       	cpi	r23, 0xD5	; 213
 6b2:	61 76       	andi	r22, 0x61	; 97
 6b4:	72 35       	cpi	r23, 0x52	; 82
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
 6b6:	20 2d       	mov	r18, r0
 6b8:	6d 6e       	ori	r22, 0xED	; 237
 6ba:	2d 66       	ori	r18, 0x6D	; 109
 6bc:	6c 61       	ori	r22, 0x1C	; 28
 6be:	73 68       	ori	r23, 0x83	; 131
 6c0:	3d 31       	cpi	r19, 0x1D	; 29
 6c2:	20 2d       	mov	r18, r0
 6c4:	6d 6e       	ori	r22, 0xED	; 237
 6c6:	6f 2d       	mov	r22, r15
 6c8:	73 6b       	ori	r23, 0xB3	; 179
 6ca:	69 70       	andi	r22, 0x09	; 9
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
 6cc:	2d 62       	ori	r18, 0x2D	; 45
 6ce:	75 67       	ori	r23, 0x75	; 117
 6d0:	20 2d       	mov	r18, r0
 6d2:	6d 6d       	ori	r22, 0xDD	; 221
 6d4:	63 75       	andi	r22, 0x53	; 83
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
 6d6:	3d 61       	ori	r19, 0x1D	; 29
 6d8:	76 72       	andi	r23, 0x26	; 38
 6da:	35 20       	and	r3, r5
 6dc:	2d 67       	ori	r18, 0x7D	; 125
 6de:	20 2d       	mov	r18, r0
 6e0:	4f 73       	andi	r20, 0x3F	; 63
 6e2:	20 2d       	mov	r18, r0
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 6e4:	4f 73       	andi	r20, 0x3F	; 63
 6e6:	20 2d       	mov	r18, r0
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
 6e8:	66 6d       	ori	r22, 0xD6	; 214
 6ea:	61 74       	andi	r22, 0x41	; 65
 6ec:	68 2d       	mov	r22, r8
 6ee:	65 72       	andi	r22, 0x25	; 37
  randomSeed(0);
  noInterrupts();
 6f0:	72 6e       	ori	r23, 0xE2	; 226
  
  digitalWrite(LED_BUILTIN, LOW);   
 6f2:	6f 20       	and	r6, r15
 6f4:	2d 66       	ori	r18, 0x6D	; 109
 6f6:	73 69       	ori	r23, 0x93	; 147
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 6f8:	67 6e       	ori	r22, 0xE7	; 231
 6fa:	65 64       	ori	r22, 0x45	; 69
 6fc:	2d 7a       	andi	r18, 0xAD	; 173
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
 6fe:	65 72       	andi	r22, 0x25	; 37
 700:	6f 73       	andi	r22, 0x3F	; 63
 702:	20 2d       	mov	r18, r0
 704:	66 74       	andi	r22, 0x46	; 70
 706:	72 61       	ori	r23, 0x12	; 18
 708:	70 70       	andi	r23, 0x00	; 0
 70a:	69 6e       	ori	r22, 0xE9	; 233
 70c:	67 2d       	mov	r22, r7
 70e:	6d 61       	ori	r22, 0x1D	; 29
 710:	74 68       	ori	r23, 0x84	; 132
 712:	20 2d       	mov	r18, r0
 714:	66 6e       	ori	r22, 0xE6	; 230
 716:	6f 2d       	mov	r22, r15
 718:	74 72       	andi	r23, 0x24	; 36
 71a:	61 70       	andi	r22, 0x01	; 1
 71c:	76 20       	and	r7, r6
 71e:	2d 66       	ori	r18, 0x6D	; 109
 720:	6e 6f       	ori	r22, 0xFE	; 254
 722:	2d 6f       	ori	r18, 0xFD	; 253
 724:	70 65       	ori	r23, 0x50	; 80
 726:	6e 6d       	ori	r22, 0xDE	; 222
 728:	70 20       	and	r7, r0
 72a:	2d 66       	ori	r18, 0x6D	; 109
 72c:	6e 6f       	ori	r22, 0xFE	; 254
 72e:	2d 6f       	ori	r18, 0xFD	; 253
 730:	70 65       	ori	r23, 0x50	; 80
 732:	6e 61       	ori	r22, 0x1E	; 30
 734:	63 63       	ori	r22, 0x33	; 51
 736:	20 2d       	mov	r18, r0
 738:	66 6e       	ori	r22, 0xE6	; 230
 73a:	6f 2d       	mov	r22, r15
 73c:	65 78       	andi	r22, 0x85	; 133
 73e:	63 65       	ori	r22, 0x53	; 83
 740:	70 74       	andi	r23, 0x40	; 64
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
 742:	69 6f       	ori	r22, 0xF9	; 249
 744:	6e 73       	andi	r22, 0x3E	; 62
 746:	20 2d       	mov	r18, r0
 748:	66 75       	andi	r22, 0x56	; 86
 74a:	73 65       	ori	r23, 0x53	; 83
 74c:	2d 6c       	ori	r18, 0xCD	; 205
 74e:	69 6e       	ori	r22, 0xE9	; 233
 750:	6b 65       	ori	r22, 0x5B	; 91
 752:	72 2d       	mov	r23, r2
 754:	70 6c       	ori	r23, 0xC0	; 192
 756:	75 67       	ori	r23, 0x75	; 117
 758:	69 6e       	ori	r22, 0xE9	; 233
 75a:	20 2d       	mov	r18, r0
 75c:	66 6c       	ori	r22, 0xC6	; 198
 75e:	74 72       	andi	r23, 0x24	; 36
 760:	61 6e       	ori	r22, 0xE1	; 225
 762:	73 00       	.word	0x0073	; ????
 764:	5f 74       	andi	r21, 0x4F	; 79
 766:	69 6d       	ori	r22, 0xD9	; 217
 768:	65 6f       	ori	r22, 0xF5	; 245
 76a:	75 74       	andi	r23, 0x45	; 69
 76c:	00 73       	andi	r16, 0x30	; 48
 76e:	69 7a       	andi	r22, 0xA9	; 169
 770:	65 00       	.word	0x0065	; ????
 772:	62 79       	andi	r22, 0x92	; 146
 774:	74 65       	ori	r23, 0x54	; 84
 776:	00 5f       	subi	r16, 0xF0	; 240
 778:	5a 4e       	sbci	r21, 0xEA	; 234
 77a:	31 34       	cpi	r19, 0x41	; 65
 77c:	48 61       	ori	r20, 0x18	; 24
 77e:	72 64       	ori	r23, 0x42	; 66
 780:	77 61       	ori	r23, 0x17	; 23
 782:	72 65       	ori	r23, 0x52	; 82
 784:	53 65       	ori	r21, 0x53	; 83
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
 786:	72 69       	ori	r23, 0x92	; 146
 788:	61 6c       	ori	r22, 0xC1	; 193
 78a:	31 37       	cpi	r19, 0x71	; 113
 78c:	5f 74       	andi	r21, 0x4F	; 79
 78e:	78 5f       	subi	r23, 0xF8	; 248
 790:	75 64       	ori	r23, 0x45	; 69
 792:	72 5f       	subi	r23, 0xF2	; 242
 794:	65 6d       	ori	r22, 0xD5	; 213
 796:	70 74       	andi	r23, 0x40	; 64
 798:	79 5f       	subi	r23, 0xF9	; 249
 79a:	69 72       	andi	r22, 0x29	; 41
 79c:	71 45       	sbci	r23, 0x51	; 81
 79e:	76 2e       	mov	r7, r22
 7a0:	70 61       	ori	r23, 0x10	; 16
 7a2:	72 74       	andi	r23, 0x42	; 66
 7a4:	2e 32       	cpi	r18, 0x2E	; 46
 7a6:	00 5f       	subi	r16, 0xF0	; 240
 7a8:	75 63       	ori	r23, 0x35	; 53
 7aa:	73 72       	andi	r23, 0x23	; 35
 7ac:	61 00       	.word	0x0061	; ????
 7ae:	5f 75       	andi	r21, 0x5F	; 95
 7b0:	63 73       	andi	r22, 0x33	; 51
 7b2:	72 62       	ori	r23, 0x22	; 34
 7b4:	00 5f       	subi	r16, 0xF0	; 240
 7b6:	75 63       	ori	r23, 0x35	; 53
 7b8:	73 72       	andi	r23, 0x23	; 35
 7ba:	63 00       	.word	0x0063	; ????
 7bc:	5f 5f       	subi	r21, 0xFF	; 255
 7be:	76 74       	andi	r23, 0x46	; 70
 7c0:	62 6c       	ori	r22, 0xC2	; 194
 7c2:	5f 70       	andi	r21, 0x0F	; 15
 7c4:	74 72       	andi	r23, 0x24	; 36
 7c6:	5f 74       	andi	r21, 0x4F	; 79
 7c8:	79 70       	andi	r23, 0x09	; 9
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
 7ca:	65 00       	.word	0x0065	; ????
 7cc:	6c 6f       	ori	r22, 0xFC	; 252
 7ce:	6f 70       	andi	r22, 0x0F	; 15
 7d0:	00 5f       	subi	r16, 0xF0	; 240
 7d2:	73 74       	andi	r23, 0x43	; 67
 7d4:	61 72       	andi	r22, 0x21	; 33
 7d6:	74 4d       	sbci	r23, 0xD4	; 212
 7d8:	69 6c       	ori	r22, 0xC9	; 201
 7da:	6c 69       	ori	r22, 0x9C	; 156
 7dc:	73 00       	.word	0x0073	; ????
 7de:	5f 75       	andi	r21, 0x5F	; 95
 7e0:	64 72       	andi	r22, 0x24	; 36
 7e2:	00 5f       	subi	r16, 0xF0	; 240
 7e4:	72 78       	andi	r23, 0x82	; 130
 7e6:	5f 62       	ori	r21, 0x2F	; 47
 7e8:	75 66       	ori	r23, 0x65	; 101
 7ea:	66 65       	ori	r22, 0x56	; 86
 7ec:	72 00       	.word	0x0072	; ????
 7ee:	64 69       	ori	r22, 0x94	; 148
 7f0:	67 69       	ori	r22, 0x97	; 151
 7f2:	74 61       	ori	r23, 0x14	; 20
 7f4:	6c 5f       	subi	r22, 0xFC	; 252
 7f6:	70 69       	ori	r23, 0x90	; 144
 7f8:	6e 5f       	subi	r22, 0xFE	; 254
 7fa:	74 6f       	ori	r23, 0xF4	; 244
 7fc:	5f 62       	ori	r21, 0x2F	; 47
 7fe:	69 74       	andi	r22, 0x49	; 73
 800:	5f 6d       	ori	r21, 0xDF	; 223
 802:	61 73       	andi	r22, 0x31	; 49
 804:	6b 5f       	subi	r22, 0xFB	; 251
 806:	50 47       	sbci	r21, 0x70	; 112
 808:	4d 00       	.word	0x004d	; ????
 80a:	5f 5f       	subi	r21, 0xFF	; 255
 80c:	69 43       	sbci	r22, 0x39	; 57
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
 80e:	6c 69       	ori	r22, 0x9C	; 156
 810:	52 65       	ori	r21, 0x52	; 82
 812:	74 56       	subi	r23, 0x64	; 100
 814:	61 6c       	ori	r22, 0xC1	; 193
 816:	00 5f       	subi	r16, 0xF0	; 240
 818:	5f 76       	andi	r21, 0x6F	; 111
 81a:	65 63       	ori	r22, 0x35	; 53
 81c:	74 6f       	ori	r23, 0xF4	; 244
 81e:	72 5f       	subi	r23, 0xF2	; 242
 820:	31 39       	cpi	r19, 0x91	; 145
 822:	00 73       	andi	r16, 0x30	; 48
 824:	65 65       	ori	r22, 0x55	; 85
 826:	64 00       	.word	0x0064	; ????
 828:	5f 77       	andi	r21, 0x7F	; 127
 82a:	72 69       	ori	r23, 0x92	; 146
 82c:	74 74       	andi	r23, 0x44	; 68
 82e:	65 6e       	ori	r22, 0xE5	; 229
 830:	00 69       	ori	r16, 0x90	; 144
 832:	6e 69       	ori	r22, 0x9E	; 158
 834:	74 00       	.word	0x0074	; ????

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
   0:	14 01       	movw	r2, r8
   2:	00 00       	nop
   4:	36 01       	movw	r6, r12
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	62 58       	subi	r22, 0x82	; 130
   c:	01 00       	.word	0x0001	; ????
   e:	00 68       	ori	r16, 0x80	; 128
  10:	01 00       	.word	0x0001	; ????
  12:	00 01       	movw	r0, r0
  14:	00 62       	ori	r16, 0x20	; 32
  16:	6c 01       	movw	r12, r24
  18:	00 00       	nop
  1a:	70 01       	movw	r14, r0
  1c:	00 00       	nop
  1e:	01 00       	.word	0x0001	; ????
  20:	62 78       	andi	r22, 0x82	; 130
  22:	01 00       	.word	0x0001	; ????
  24:	00 7a       	andi	r16, 0xA0	; 160
  26:	01 00       	.word	0x0001	; ????
  28:	00 01       	movw	r0, r0
  2a:	00 62       	ori	r16, 0x20	; 32
  2c:	80 01       	movw	r16, r0
  2e:	00 00       	nop
  30:	82 01       	movw	r16, r4
  32:	00 00       	nop
  34:	01 00       	.word	0x0001	; ????
  36:	62 86       	std	Z+10, r6	; 0x0a
  38:	01 00       	.word	0x0001	; ????
  3a:	00 8a       	std	Z+16, r0	; 0x10
  3c:	01 00       	.word	0x0001	; ????
  3e:	00 01       	movw	r0, r0
  40:	00 62       	ori	r16, 0x20	; 32
  42:	92 01       	movw	r18, r4
  44:	00 00       	nop
  46:	96 01       	movw	r18, r12
  48:	00 00       	nop
  4a:	01 00       	.word	0x0001	; ????
  4c:	62 00       	.word	0x0062	; ????
  4e:	00 00       	nop
  50:	00 00       	nop
  52:	00 00       	nop
  54:	00 1a       	sub	r0, r16
  56:	01 00       	.word	0x0001	; ????
  58:	00 50       	subi	r16, 0x00	; 0
  5a:	01 00       	.word	0x0001	; ????
  5c:	00 01       	movw	r0, r0
  5e:	00 69       	ori	r16, 0x90	; 144
  60:	50 01       	movw	r10, r0
  62:	00 00       	nop
  64:	52 01       	movw	r10, r4
  66:	00 00       	nop
  68:	04 00       	.word	0x0004	; ????
  6a:	89 00       	.word	0x0089	; ????
  6c:	20 9f       	mul	r18, r16
  6e:	58 01       	movw	r10, r16
  70:	00 00       	nop
  72:	9c 01       	movw	r18, r24
  74:	00 00       	nop
  76:	01 00       	.word	0x0001	; ????
  78:	69 00       	.word	0x0069	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	00 20       	and	r0, r0
  82:	01 00       	.word	0x0001	; ????
  84:	00 3c       	cpi	r16, 0xC0	; 192
  86:	01 00       	.word	0x0001	; ????
  88:	00 01       	movw	r0, r0
  8a:	00 6e       	ori	r16, 0xE0	; 224
  8c:	58 01       	movw	r10, r16
  8e:	00 00       	nop
  90:	9a 01       	movw	r18, r20
  92:	00 00       	nop
  94:	01 00       	.word	0x0001	; ????
  96:	6e 00       	.word	0x006e	; ????
  98:	00 00       	nop
  9a:	00 00       	nop
  9c:	00 00       	nop
  9e:	00 44       	sbci	r16, 0x40	; 64
  a0:	01 00       	.word	0x0001	; ????
  a2:	00 56       	subi	r16, 0x60	; 96
  a4:	01 00       	.word	0x0001	; ????
  a6:	00 06       	cpc	r0, r16
  a8:	00 6a       	ori	r16, 0xA0	; 160
  aa:	93 01       	movw	r18, r6
  ac:	6b 93       	.word	0x936b	; ????
  ae:	01 9a       	sbi	0x00, 1	; 0
  b0:	01 00       	.word	0x0001	; ????
  b2:	00 9e       	mul	r0, r16
  b4:	01 00       	.word	0x0001	; ????
  b6:	00 06       	cpc	r0, r16
  b8:	00 6a       	ori	r16, 0xA0	; 160
  ba:	93 01       	movw	r18, r6
  bc:	6b 93       	.word	0x936b	; ????
  be:	01 00       	.word	0x0001	; ????
  c0:	00 00       	nop
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	00 46       	sbci	r16, 0x60	; 96
  c8:	01 00       	.word	0x0001	; ????
  ca:	00 56       	subi	r16, 0x60	; 96
  cc:	01 00       	.word	0x0001	; ????
  ce:	00 01       	movw	r0, r0
  d0:	00 62       	ori	r16, 0x20	; 32
  d2:	9a 01       	movw	r18, r20
  d4:	00 00       	nop
  d6:	9e 01       	movw	r18, r28
  d8:	00 00       	nop
  da:	01 00       	.word	0x0001	; ????
  dc:	62 00       	.word	0x0062	; ????
  de:	00 00       	nop
  e0:	00 00       	nop
  e2:	00 00       	nop
  e4:	00 12       	cpse	r0, r16
  e6:	01 00       	.word	0x0001	; ????
  e8:	00 18       	sub	r0, r0
  ea:	01 00       	.word	0x0001	; ????
  ec:	00 06       	cpc	r0, r16
  ee:	00 6e       	ori	r16, 0xE0	; 224
  f0:	93 01       	movw	r18, r6
  f2:	6f 93       	push	r22
  f4:	01 00       	.word	0x0001	; ????
  f6:	00 00       	nop
  f8:	00 00       	nop
  fa:	00 00       	nop
  fc:	00 18       	sub	r0, r0
  fe:	01 00       	.word	0x0001	; ????
 100:	00 1e       	adc	r0, r16
 102:	01 00       	.word	0x0001	; ????
 104:	00 06       	cpc	r0, r16
 106:	00 6e       	ori	r16, 0xE0	; 224
 108:	93 01       	movw	r18, r6
 10a:	6f 93       	push	r22
 10c:	01 00       	.word	0x0001	; ????
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 10e:	00 00       	nop
 110:	00 00       	nop
 112:	00 00       	nop
	uint8_t bit = digitalPinToBitMask(pin);
 114:	00 1e       	adc	r0, r16
 116:	01 00       	.word	0x0001	; ????
 118:	00 20       	and	r0, r0
	uint8_t port = digitalPinToPort(pin);
 11a:	01 00       	.word	0x0001	; ????
 11c:	00 06       	cpc	r0, r16
 11e:	00 6e       	ori	r16, 0xE0	; 224
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 120:	93 01       	movw	r18, r6
 122:	6f 93       	push	r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 124:	01 00       	.word	0x0001	; ????
 126:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 128:	00 00       	nop
 12a:	00 00       	nop
 12c:	00 28       	or	r0, r0
 12e:	01 00       	.word	0x0001	; ????
 130:	00 36       	cpi	r16, 0x60	; 96
 132:	01 00       	.word	0x0001	; ????
 134:	00 01       	movw	r0, r0

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 136:	00 62       	ori	r16, 0x20	; 32
 138:	58 01       	movw	r10, r16
 13a:	00 00       	nop
 13c:	68 01       	movw	r12, r16
 13e:	00 00       	nop
 140:	01 00       	.word	0x0001	; ????
 142:	62 6c       	ori	r22, 0xC2	; 194

	uint8_t oldSREG = SREG;
 144:	01 00       	.word	0x0001	; ????
	cli();
 146:	00 70       	andi	r16, 0x00	; 0

	if (val == LOW) {
		*out &= ~bit;
 148:	01 00       	.word	0x0001	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 14a:	00 01       	movw	r0, r0
 14c:	00 62       	ori	r16, 0x20	; 32
		*out &= ~bit;
 14e:	78 01       	movw	r14, r16
 150:	00 00       	nop
	} else {
		*out |= bit;
 152:	7a 01       	movw	r14, r20
	}

	SREG = oldSREG;
 154:	00 00       	nop
}
 156:	01 00       	.word	0x0001	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 158:	62 80       	ldd	r6, Z+2	; 0x02
 15a:	01 00       	.word	0x0001	; ????
 15c:	00 82       	st	Z, r0
 15e:	01 00       	.word	0x0001	; ????
 160:	00 01       	movw	r0, r0
 162:	00 62       	ori	r16, 0x20	; 32
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 164:	86 01       	movw	r16, r12
 166:	00 00       	nop
 168:	8a 01       	movw	r16, r20
 16a:	00 00       	nop
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 16c:	01 00       	.word	0x0001	; ????
 16e:	62 92       	st	-Z, r6
 170:	01 00       	.word	0x0001	; ????
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 172:	00 96       	adiw	r24, 0x00	; 0
 174:	01 00       	.word	0x0001	; ????
 176:	00 01       	movw	r0, r0
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 178:	00 62       	ori	r16, 0x20	; 32
	...
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 182:	40 01       	movw	r8, r0
 184:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 186:	44 01       	movw	r8, r8
 188:	00 00       	nop
 18a:	06 00       	.word	0x0006	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 18c:	6e 93       	st	-X, r22
 18e:	01 6f       	ori	r16, 0xF1	; 241
 190:	93 01       	movw	r18, r6
	...
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 19a:	9e 01       	movw	r18, r28
 19c:	00 00       	nop

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 19e:	a0 01       	movw	r20, r0
 1a0:	00 00       	nop
 1a2:	03 00       	.word	0x0003	; ????
 1a4:	92 20       	and	r9, r2
 1a6:	02 a0       	ldd	r0, Z+34	; 0x22
 1a8:	01 00       	.word	0x0001	; ????
 1aa:	00 a2       	std	Z+32, r0	; 0x20
 1ac:	01 00       	.word	0x0001	; ????
 1ae:	00 03       	mulsu	r16, r16
 1b0:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x140>
 1b4:	a2 01       	movw	r20, r4
 1b6:	00 00       	nop
 1b8:	a4 01       	movw	r20, r8
 1ba:	00 00       	nop
 1bc:	03 00       	.word	0x0003	; ????
 1be:	92 20       	and	r9, r2
 1c0:	04 a4       	ldd	r0, Z+44	; 0x2c
 1c2:	01 00       	.word	0x0001	; ????
  size_t n = 0;
  while (size--) {
 1c4:	00 a6       	std	Z+40, r0	; 0x28
 1c6:	01 00       	.word	0x0001	; ????
 1c8:	00 03       	mulsu	r16, r16
    if (write(*buffer++)) n++;
 1ca:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x340>
 1ce:	a6 01       	movw	r20, r12
 1d0:	00 00       	nop
 1d2:	a8 01       	movw	r20, r16
 1d4:	00 00       	nop
 1d6:	03 00       	.word	0x0003	; ????
 1d8:	92 20       	and	r9, r2
 1da:	06 a8       	ldd	r0, Z+54	; 0x36
 1dc:	01 00       	.word	0x0001	; ????
 1de:	00 aa       	std	Z+48, r0	; 0x30
    else break;
  }
  return n;
}
 1e0:	01 00       	.word	0x0001	; ????
 1e2:	00 03       	mulsu	r16, r16
 1e4:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x540>
 1e8:	aa 01       	movw	r20, r20
 1ea:	00 00       	nop
 1ec:	ac 01       	movw	r20, r24
 1ee:	00 00       	nop
 1f0:	03 00       	.word	0x0003	; ????
 1f2:	92 20       	and	r9, r2
 1f4:	08 ac       	ldd	r0, Y+56	; 0x38
 1f6:	01 00       	.word	0x0001	; ????
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 1f8:	00 ae       	std	Z+56, r0	; 0x38
 1fa:	01 00       	.word	0x0001	; ????
    tail = _tx_buffer_tail;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x740>
 202:	ae 01       	movw	r20, r28
 204:	00 00       	nop
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 206:	b0 01       	movw	r22, r0
 208:	00 00       	nop
 20a:	03 00       	.word	0x0003	; ????
 20c:	92 20       	and	r9, r2
 20e:	0a b0       	in	r0, 0x0a	; 10
 210:	01 00       	.word	0x0001	; ????
  return tail - head - 1;
 212:	00 b2       	in	r0, 0x10	; 16
}
 214:	01 00       	.word	0x0001	; ????
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 216:	00 03       	mulsu	r16, r16
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 218:	00 92 20 0b 	sts	0x0B20, r0	; 0x800b20 <__bss_end+0x940>
 21c:	b2 01       	movw	r22, r4
 21e:	00 00       	nop
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 220:	f8 01       	movw	r30, r16
 222:	00 00       	nop
 224:	03 00       	.word	0x0003	; ????
 226:	92 20       	and	r9, r2
 228:	0c 00       	.word	0x000c	; ????
 22a:	00 00       	nop
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 22c:	00 00       	nop
 22e:	00 00       	nop
 230:	00 9e       	mul	r0, r16
 232:	01 00       	.word	0x0001	; ????
    return c;
 234:	00 be       	out	0x30, r0	; 48
 236:	01 00       	.word	0x0001	; ????

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 238:	00 06       	cpc	r0, r16
 23a:	00 68       	ori	r16, 0x80	; 128
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 23c:	93 01       	movw	r18, r6
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 23e:	69 93       	st	Y+, r22
  if (_rx_buffer_head == _rx_buffer_tail) {
 240:	01 be       	out	0x31, r0	; 49
 242:	01 00       	.word	0x0001	; ????
 244:	00 f2       	brcs	.-128    	; 0x1c6 <_ZN5Print5writeEPKhj+0x28>
 246:	01 00       	.word	0x0001	; ????
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 248:	00 06       	cpc	r0, r16
 24a:	00 5c       	subi	r16, 0xC0	; 192
 24c:	93 01       	movw	r18, r6
 24e:	5d 93       	st	X+, r21
 250:	01 f2       	breq	.-128    	; 0x1d2 <_ZN5Print5writeEPKhj+0x34>
 252:	01 00       	.word	0x0001	; ????
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 254:	00 f8       	bld	r0, 0
 256:	01 00       	.word	0x0001	; ????
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 258:	00 04       	cpc	r0, r0
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 25a:	00 f3       	brcs	.-64     	; 0x21c <_ZN14HardwareSerial4readEv+0x6>
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 25c:	01 68       	ori	r16, 0x81	; 129
 25e:	9f 00       	.word	0x009f	; ????
 260:	00 00       	nop
 262:	00 00       	nop
 264:	00 00       	nop
 266:	00 9e       	mul	r0, r16
 268:	01 00       	.word	0x0001	; ????
 26a:	00 be       	out	0x30, r0	; 48
}
 26c:	01 00       	.word	0x0001	; ????
 26e:	00 06       	cpc	r0, r16
 270:	00 66       	ori	r16, 0x60	; 96
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 272:	93 01       	movw	r18, r6
 274:	67 93       	lat	Z, r22
 276:	01 be       	out	0x31, r0	; 49
 278:	01 00       	.word	0x0001	; ????
 27a:	00 ca       	rjmp	.-3072   	; 0xfffff67c <__eeprom_end+0xff7ef67c>
 27c:	01 00       	.word	0x0001	; ????
 27e:	00 06       	cpc	r0, r16
 280:	00 6c       	ori	r16, 0xC0	; 192
}
 282:	93 01       	movw	r18, r6
 284:	6d 93       	st	X+, r22
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 286:	01 ca       	rjmp	.-3070   	; 0xfffff68a <__eeprom_end+0xff7ef68a>
 288:	01 00       	.word	0x0001	; ????
 28a:	00 cc       	rjmp	.-2048   	; 0xfffffa8c <__eeprom_end+0xff7efa8c>
 28c:	01 00       	.word	0x0001	; ????
 28e:	00 03       	mulsu	r16, r16
 290:	00 8c       	ldd	r0, Z+24	; 0x18
 292:	01 9f       	mul	r16, r17
 294:	cc 01       	movw	r24, r24
 296:	00 00       	nop
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 298:	e6 01       	movw	r28, r12
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 29a:	00 00       	nop
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 29c:	06 00       	.word	0x0006	; ????
 29e:	6c 93       	st	X, r22
 2a0:	01 6d       	ori	r16, 0xD1	; 209
 2a2:	93 01       	movw	r18, r6
	...
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2ac:	9e 01       	movw	r18, r28
 2ae:	00 00       	nop
 2b0:	be 01       	movw	r22, r28
 2b2:	00 00       	nop
 2b4:	06 00       	.word	0x0006	; ????

  *_udr = c;
 2b6:	64 93       	xch	Z, r22
 2b8:	01 65       	ori	r16, 0x51	; 81
 2ba:	93 01       	movw	r18, r6
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 2bc:	c4 01       	movw	r24, r8
 2be:	00 00       	nop
 2c0:	cc 01       	movw	r24, r24
 2c2:	00 00       	nop
 2c4:	0b 00       	.word	0x000b	; ????
 2c6:	8c 00       	.word	0x008c	; ????
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 2c8:	20 7e       	andi	r18, 0xE0	; 224
 2ca:	00 22       	and	r0, r16
 2cc:	f3 01       	movw	r30, r6
 2ce:	64 22       	and	r6, r20
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 2d0:	9f cc       	rjmp	.-1730   	; 0xfffffc10 <__eeprom_end+0xff7efc10>
 2d2:	01 00       	.word	0x0001	; ????
 2d4:	00 e0       	ldi	r16, 0x00	; 0
 2d6:	01 00       	.word	0x0001	; ????
 2d8:	00 0a       	sbc	r0, r16
 2da:	00 7e       	andi	r16, 0xE0	; 224
  }
}
 2dc:	00 8c       	ldd	r0, Z+24	; 0x18
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 2de:	00 1c       	adc	r0, r0
 2e0:	f3 01       	movw	r30, r6
 2e2:	64 22       	and	r6, r20
 2e4:	9f 00       	.word	0x009f	; ????
 2e6:	00 00       	nop
 2e8:	00 00       	nop
 2ea:	00 00       	nop
  _written = true;
 2ec:	00 b6       	in	r0, 0x30	; 48
 2ee:	01 00       	.word	0x0001	; ????
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 2f0:	00 be       	out	0x30, r0	; 48
 2f2:	01 00       	.word	0x0001	; ????
 2f4:	00 02       	muls	r16, r16
 2f6:	00 30       	cpi	r16, 0x00	; 0
 2f8:	9f c4       	rjmp	.+2366   	; 0xc38 <__data_load_end+0x336>
 2fa:	01 00       	.word	0x0001	; ????
 2fc:	00 f6       	brcc	.-128    	; 0x27e <_Z17Serial0_availablev+0xc>
 2fe:	01 00       	.word	0x0001	; ????
 300:	00 06       	cpc	r0, r16
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 302:	00 5a       	subi	r16, 0xA0	; 160
 304:	93 01       	movw	r18, r6
      *_udr = c;
 306:	5b 93       	.word	0x935b	; ????
 308:	01 f6       	brne	.-128    	; 0x28a <_Z14serialEventRunv+0x4>
 30a:	01 00       	.word	0x0001	; ????
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 30c:	00 f8       	bld	r0, 0
 30e:	01 00       	.word	0x0001	; ????
 310:	00 06       	cpc	r0, r16
 312:	00 68       	ori	r16, 0x80	; 128
 314:	93 01       	movw	r18, r6
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 316:	69 93       	st	Y+, r22
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 318:	01 00       	.word	0x0001	; ????
  }
  
  return 1;
}
 31a:	00 00       	nop
 31c:	00 00       	nop
 31e:	00 00       	nop
 320:	00 f8       	bld	r0, 0
 322:	01 00       	.word	0x0001	; ????
 324:	00 04       	cpc	r0, r0
 326:	02 00       	.word	0x0002	; ????
 328:	00 06       	cpc	r0, r16
 32a:	00 68       	ori	r16, 0x80	; 128
 32c:	93 01       	movw	r18, r6
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 32e:	69 93       	st	Y+, r22
 330:	01 04       	cpc	r0, r1
 332:	02 00       	.word	0x0002	; ????
 334:	00 16       	cp	r0, r16
 336:	02 00       	.word	0x0002	; ????
 338:	00 06       	cpc	r0, r16
 33a:	00 6e       	ori	r16, 0xE0	; 224
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 33c:	93 01       	movw	r18, r6
 33e:	6f 93       	push	r22
 340:	01 00       	.word	0x0001	; ????
    if (bit_is_clear(SREG, SREG_I)) {
 342:	00 00       	nop
 344:	00 00       	nop
 346:	00 00       	nop
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 348:	00 16       	cp	r0, r16
 34a:	02 00       	.word	0x0002	; ????
 34c:	00 1c       	adc	r0, r0
 34e:	02 00       	.word	0x0002	; ????
 350:	00 06       	cpc	r0, r16
	_tx_udr_empty_irq();
 352:	00 68       	ori	r16, 0x80	; 128
 354:	93 01       	movw	r18, r6
 356:	69 93       	st	Y+, r22
 358:	01 1c       	adc	r0, r1
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 35a:	02 00       	.word	0x0002	; ????
 35c:	00 3e       	cpi	r16, 0xE0	; 224
 35e:	02 00       	.word	0x0002	; ????
 360:	00 06       	cpc	r0, r16
 362:	00 6e       	ori	r16, 0xE0	; 224
 364:	93 01       	movw	r18, r6
 366:	6f 93       	push	r22

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 368:	01 00       	.word	0x0001	; ????
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 36a:	00 00       	nop
    _tx_buffer_head = i;
 36c:	00 00       	nop
    sbi(*_ucsrb, UDRIE0);
 36e:	00 00       	nop
 370:	00 2c       	mov	r0, r0
 372:	02 00       	.word	0x0002	; ????
 374:	00 38       	cpi	r16, 0x80	; 128
 376:	02 00       	.word	0x0002	; ????
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 378:	00 01       	movw	r0, r0
 37a:	00 68       	ori	r16, 0x80	; 128
	...
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 384:	3e 02       	muls	r19, r30
 386:	00 00       	nop
 388:	44 02       	muls	r20, r20
 38a:	00 00       	nop
 38c:	06 00       	.word	0x0006	; ????
 38e:	68 93       	.word	0x9368	; ????
 390:	01 69       	ori	r16, 0x91	; 145
 392:	93 01       	movw	r18, r6
 394:	44 02       	muls	r20, r20
 396:	00 00       	nop
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 398:	4e 02       	muls	r20, r30
 39a:	00 00       	nop
 39c:	06 00       	.word	0x0006	; ????
 39e:	6e 93       	st	-X, r22
 3a0:	01 6f       	ori	r16, 0xF1	; 241
 3a2:	93 01       	movw	r18, r6
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 3a4:	4e 02       	muls	r20, r30
 3a6:	00 00       	nop
 3a8:	54 02       	muls	r21, r20
	  _tx_udr_empty_irq();
 3aa:	00 00       	nop
 3ac:	04 00       	.word	0x0004	; ????
 3ae:	f3 01       	movw	r30, r6
 3b0:	68 9f       	mul	r22, r24
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3b2:	54 02       	muls	r21, r20
 3b4:	00 00       	nop
 3b6:	5a 02       	muls	r21, r26
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 3b8:	00 00       	nop
 3ba:	06 00       	.word	0x0006	; ????
 3bc:	6e 93       	st	-X, r22
 3be:	01 6f       	ori	r16, 0xF1	; 241
 3c0:	93 01       	movw	r18, r6
	...
 3ca:	5a 02       	muls	r21, r26
 3cc:	00 00       	nop
 3ce:	62 02       	muls	r22, r18
 3d0:	00 00       	nop
 3d2:	06 00       	.word	0x0006	; ????
 3d4:	68 93       	.word	0x9368	; ????
 3d6:	01 69       	ori	r16, 0x91	; 145
 3d8:	93 01       	movw	r18, r6
 3da:	62 02       	muls	r22, r18
 3dc:	00 00       	nop
 3de:	72 02       	muls	r23, r18
 3e0:	00 00       	nop
 3e2:	06 00       	.word	0x0006	; ????
 3e4:	6e 93       	st	-X, r22
 3e6:	01 6f       	ori	r16, 0xF1	; 241
{
  size_t n = print(c);
  n += println();
  return n;
}
 3e8:	93 01       	movw	r18, r6
	...
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3f2:	9a 02       	muls	r25, r26
 3f4:	00 00       	nop
 3f6:	ac 02       	muls	r26, r28
 3f8:	00 00       	nop
 3fa:	06 00       	.word	0x0006	; ????
 3fc:	68 93       	.word	0x9368	; ????
 3fe:	01 69       	ori	r16, 0x91	; 145
 400:	93 01       	movw	r18, r6
 402:	ac 02       	muls	r26, r28
 404:	00 00       	nop
 406:	d6 02       	muls	r29, r22
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 408:	00 00       	nop
 40a:	06 00       	.word	0x0006	; ????
 40c:	6e 93       	st	-X, r22
 40e:	01 6f       	ori	r16, 0xF1	; 241
 410:	93 01       	movw	r18, r6
 412:	d6 02       	muls	r29, r22
 414:	00 00       	nop
 416:	de 02       	muls	r29, r30
	unsigned char f = timer0_fract;
 418:	00 00       	nop
 41a:	04 00       	.word	0x0004	; ????

	m += MILLIS_INC;
	f += FRACT_INC;
 41c:	f3 01       	movw	r30, r6
 41e:	68 9f       	mul	r22, r24
	...
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 428:	d0 02       	muls	r29, r16
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 42a:	00 00       	nop
 42c:	d6 02       	muls	r29, r22
	timer0_millis = m;
 42e:	00 00       	nop
 430:	06 00       	.word	0x0006	; ????
 432:	6e 93       	st	-X, r22
 434:	01 6f       	ori	r16, 0xF1	; 241
 436:	93 01       	movw	r18, r6
 438:	d6 02       	muls	r29, r22
 43a:	00 00       	nop
 43c:	dc 02       	muls	r29, r28
	timer0_overflow_count++;
 43e:	00 00       	nop
 440:	04 00       	.word	0x0004	; ????
 442:	f3 01       	movw	r30, r6
 444:	68 9f       	mul	r22, r24
	...
 44e:	de 02       	muls	r29, r30
 450:	00 00       	nop
 452:	e0 02       	muls	r30, r16
 454:	00 00       	nop
 456:	03 00       	.word	0x0003	; ????
 458:	92 20       	and	r9, r2
 45a:	02 e0       	ldi	r16, 0x02	; 2
 45c:	02 00       	.word	0x0002	; ????
 45e:	00 e2       	ldi	r16, 0x20	; 32
 460:	02 00       	.word	0x0002	; ????
 462:	00 03       	mulsu	r16, r16
}
 464:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x140>
 468:	e2 02       	muls	r30, r18
 46a:	00 00       	nop
 46c:	e4 02       	muls	r30, r20
 46e:	00 00       	nop
 470:	03 00       	.word	0x0003	; ????
 472:	92 20       	and	r9, r2
 474:	04 e4       	ldi	r16, 0x44	; 68
 476:	02 00       	.word	0x0002	; ????
 478:	00 e6       	ldi	r16, 0x60	; 96
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 47a:	02 00       	.word	0x0002	; ????
 47c:	00 03       	mulsu	r16, r16
		m += 1;
 47e:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x340>
 482:	e6 02       	muls	r30, r22
 484:	00 00       	nop
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 486:	e8 02       	muls	r30, r24
 488:	00 00       	nop
 48a:	03 00       	.word	0x0003	; ????
 48c:	92 20       	and	r9, r2
 48e:	06 e8       	ldi	r16, 0x86	; 134
 490:	02 00       	.word	0x0002	; ????
 492:	00 ea       	ldi	r16, 0xA0	; 160
 494:	02 00       	.word	0x0002	; ????
 496:	00 03       	mulsu	r16, r16
 498:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x540>
 49c:	ea 02       	muls	r30, r26
 49e:	00 00       	nop
 4a0:	78 03       	fmul	r23, r16
 4a2:	00 00       	nop
 4a4:	03 00       	.word	0x0003	; ????
 4a6:	92 20       	and	r9, r2
  Serial._tx_udr_empty_irq();
 4a8:	08 00       	.word	0x0008	; ????
 4aa:	00 00       	nop
 4ac:	00 00       	nop
 4ae:	00 00       	nop
}
 4b0:	00 de       	rcall	.-1024   	; 0xb2 <digital_pin_to_timer_PGM+0xe>
 4b2:	02 00       	.word	0x0002	; ????
 4b4:	00 ee       	ldi	r16, 0xE0	; 224
 4b6:	02 00       	.word	0x0002	; ????
 4b8:	00 06       	cpc	r0, r16
 4ba:	00 68       	ori	r16, 0x80	; 128
 4bc:	93 01       	movw	r18, r6
 4be:	69 93       	st	Y+, r22
 4c0:	01 ee       	ldi	r16, 0xE1	; 225
 4c2:	02 00       	.word	0x0002	; ????
 4c4:	00 22       	and	r0, r16
 4c6:	03 00       	.word	0x0003	; ????
 4c8:	00 06       	cpc	r0, r16
 4ca:	00 6c       	ori	r16, 0xC0	; 192
 4cc:	93 01       	movw	r18, r6
 4ce:	6d 93       	st	X+, r22
 4d0:	01 22       	and	r0, r17
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4d2:	03 00       	.word	0x0003	; ????
 4d4:	00 2c       	mov	r0, r0
 4d6:	03 00       	.word	0x0003	; ????
 4d8:	00 04       	cpc	r0, r0
 4da:	00 f3       	brcs	.-64     	; 0x49c <__vector_19+0x16>
 4dc:	01 68       	ori	r16, 0x81	; 129
 4de:	9f 2c       	mov	r9, r15
 4e0:	03 00       	.word	0x0003	; ????
 4e2:	00 78       	andi	r16, 0x80	; 128
 4e4:	03 00       	.word	0x0003	; ????

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 4e6:	00 06       	cpc	r0, r16
 4e8:	00 6c       	ori	r16, 0xC0	; 192
 4ea:	93 01       	movw	r18, r6
 4ec:	6d 93       	st	X+, r22
 4ee:	01 00       	.word	0x0001	; ????
 4f0:	00 00       	nop
 4f2:	00 00       	nop
 4f4:	00 00       	nop
 4f6:	00 de       	rcall	.-1024   	; 0xf8 <__do_global_ctors+0xc>
 4f8:	02 00       	.word	0x0002	; ????
 4fa:	00 16       	cp	r0, r16
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 4fc:	03 00       	.word	0x0003	; ????
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 4fe:	00 01       	movw	r0, r0
 500:	00 66       	ori	r16, 0x60	; 96
 502:	16 03       	mulsu	r17, r22
 504:	00 00       	nop

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 506:	2c 03       	fmul	r18, r20
 508:	00 00       	nop
 50a:	04 00       	.word	0x0004	; ????
 50c:	f3 01       	movw	r30, r6
      _rx_buffer[_rx_buffer_head] = c;
 50e:	66 9f       	mul	r22, r22
 510:	2c 03       	fmul	r18, r20
 512:	00 00       	nop
 514:	3c 03       	fmul	r19, r20
 516:	00 00       	nop
 518:	01 00       	.word	0x0001	; ????
      _rx_buffer_head = i;
 51a:	66 3c       	cpi	r22, 0xC6	; 198
 51c:	03 00       	.word	0x0003	; ????
    Serial._rx_complete_irq();
  }
 51e:	00 78       	andi	r16, 0x80	; 128
 520:	03 00       	.word	0x0003	; ????
 522:	00 01       	movw	r0, r0
 524:	00 5f       	subi	r16, 0xF0	; 240
	...
 52e:	04 03       	mulsu	r16, r20
 530:	00 00       	nop
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 532:	16 03       	mulsu	r17, r22
 534:	00 00       	nop

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 536:	01 00       	.word	0x0001	; ????
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 538:	69 00       	.word	0x0069	; ????
 53a:	00 00       	nop
 53c:	00 00       	nop
	sbi(TCCR0A, WGM00);
 53e:	00 00       	nop
 540:	00 06       	cpc	r0, r16
 542:	03 00       	.word	0x0003	; ????
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 544:	00 16       	cp	r0, r16
 546:	03 00       	.word	0x0003	; ????
 548:	00 02       	muls	r16, r16
	sbi(TCCR0B, CS00);
 54a:	00 31       	cpi	r16, 0x10	; 16
 54c:	9f 00       	.word	0x009f	; ????
 54e:	00 00       	nop

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 550:	00 00       	nop
 552:	00 00       	nop
 554:	00 6a       	ori	r16, 0xA0	; 160
 556:	03 00       	.word	0x0003	; ????
 558:	00 78       	andi	r16, 0x80	; 128
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 55a:	03 00       	.word	0x0003	; ????
 55c:	00 01       	movw	r0, r0

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 55e:	00 69       	ori	r16, 0x90	; 144
	...
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 568:	18 03       	fmul	r17, r16
 56a:	00 00       	nop
 56c:	2c 03       	fmul	r18, r20
 56e:	00 00       	nop
 570:	02 00       	.word	0x0002	; ????
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 572:	30 9f       	mul	r19, r16
 574:	6c 03       	fmul	r22, r20
 576:	00 00       	nop
 578:	78 03       	fmul	r23, r16
 57a:	00 00       	nop

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 57c:	02 00       	.word	0x0002	; ????
 57e:	31 9f       	mul	r19, r17
	...

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 588:	18 03       	fmul	r17, r16
 58a:	00 00       	nop
 58c:	2c 03       	fmul	r18, r20
 58e:	00 00       	nop
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 590:	06 00       	.word	0x0006	; ????
 592:	f2 ac       	ldd	r15, Z+58	; 0x3a
 594:	12 00       	.word	0x0012	; ????
	...
		sbi(ADCSRA, ADPS1);
 59e:	00 00       	nop
 5a0:	78 03       	fmul	r23, r16
 5a2:	00 00       	nop
		sbi(ADCSRA, ADPS0);
 5a4:	7a 03       	fmul	r23, r18
 5a6:	00 00       	nop
 5a8:	03 00       	.word	0x0003	; ????
 5aa:	92 20       	and	r9, r2
 5ac:	02 7a       	andi	r16, 0xA2	; 162
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 5ae:	03 00       	.word	0x0003	; ????
 5b0:	00 7c       	andi	r16, 0xC0	; 192
 5b2:	03 00       	.word	0x0003	; ????
 5b4:	00 03       	mulsu	r16, r16
 5b6:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x140>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 5ba:	7c 03       	fmul	r23, r20
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 5bc:	00 00       	nop
 5be:	b8 03       	fmulsu	r19, r16
 5c0:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
 5c2:	03 00       	.word	0x0003	; ????
 5c4:	92 20       	and	r9, r2
 5c6:	04 00       	.word	0x0004	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 5c8:	00 00       	nop
 5ca:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 5cc:	00 00       	nop
 5ce:	00 78       	andi	r16, 0x80	; 128
 5d0:	03 00       	.word	0x0003	; ????
 5d2:	00 80       	ld	r0, Z
 5d4:	03 00       	.word	0x0003	; ????
 5d6:	00 06       	cpc	r0, r16
 5d8:	00 68       	ori	r16, 0x80	; 128
 5da:	93 01       	movw	r18, r6
	out = portOutputRegister(port);
 5dc:	69 93       	st	Y+, r22
 5de:	01 80       	ldd	r0, Z+1	; 0x01
 5e0:	03 00       	.word	0x0003	; ????
 5e2:	00 b6       	in	r0, 0x30	; 48
 5e4:	03 00       	.word	0x0003	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 5e6:	00 06       	cpc	r0, r16
                cli();
 5e8:	00 6c       	ori	r16, 0xC0	; 192
		*reg |= bit;
 5ea:	93 01       	movw	r18, r6
 5ec:	6d 93       	st	X+, r22
 5ee:	01 b6       	in	r0, 0x31	; 49
		SREG = oldSREG;
 5f0:	03 00       	.word	0x0003	; ????

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 5f2:	00 b8       	out	0x00, r0	; 0
 5f4:	03 00       	.word	0x0003	; ????
 5f6:	00 04       	cpc	r0, r0
 5f8:	00 f3       	brcs	.-64     	; 0x5ba <main+0x84>
 5fa:	01 68       	ori	r16, 0x81	; 129
 5fc:	9f 00       	.word	0x009f	; ????
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5fe:	00 00       	nop
 600:	00 00       	nop
 602:	00 00       	nop
 604:	00 b8       	out	0x00, r0	; 0
 606:	03 00       	.word	0x0003	; ????
  *_ubrrl = baud_setting;
 608:	00 ba       	out	0x10, r0	; 16
 60a:	03 00       	.word	0x0003	; ????
 60c:	00 03       	mulsu	r16, r16
 60e:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x40>
 612:	ba 03       	fmulsu	r19, r18

  _written = false;
 614:	00 00       	nop
 616:	bc 03       	fmulsu	r19, r20

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 618:	00 00       	nop
 61a:	03 00       	.word	0x0003	; ????
 61c:	92 20       	and	r9, r2
 61e:	03 bc       	out	0x23, r0	; 35
 620:	03 00       	.word	0x0003	; ????
 622:	00 f2       	brcs	.-128    	; 0x5a4 <main+0x6e>
  
  sbi(*_ucsrb, RXEN0);
 624:	03 00       	.word	0x0003	; ????
 626:	00 03       	mulsu	r16, r16
 628:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x240>
	...
  sbi(*_ucsrb, TXEN0);
 634:	b8 03       	fmulsu	r19, r16
 636:	00 00       	nop
 638:	d2 03       	fmuls	r21, r18
 63a:	00 00       	nop
 63c:	06 00       	.word	0x0006	; ????
 63e:	68 93       	.word	0x9368	; ????
  sbi(*_ucsrb, RXCIE0);
 640:	01 69       	ori	r16, 0x91	; 145
 642:	93 01       	movw	r18, r6
 644:	d2 03       	fmuls	r21, r18
 646:	00 00       	nop
 648:	d5 03       	fmuls	r21, r21
 64a:	00 00       	nop
 64c:	06 00       	.word	0x0006	; ????
  cbi(*_ucsrb, UDRIE0);
 64e:	66 93       	lac	Z, r22
 650:	01 67       	ori	r16, 0x71	; 113
 652:	93 01       	movw	r18, r6
 654:	d5 03       	fmuls	r21, r21
 656:	00 00       	nop
 658:	f2 03       	fmuls	r23, r18
 65a:	00 00       	nop
void setup() {
  // put your setup code here, to run once:
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("in setup");
 65c:	04 00       	.word	0x0004	; ????
 65e:	f3 01       	movw	r30, r6
 660:	68 9f       	mul	r22, r24
	...
    "__Noops1: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main2 \n"
    );
 66a:	e8 03       	fmulsu	r22, r16
 66c:	00 00       	nop
    "add %0, %1 \n"
    "add %0, %1 \n"
    "add %0, %1 \n"
    "jmp __Noops1 \n"
    : "=d" (a): "d" (b)
    );
 66e:	ec 03       	fmulsu	r22, r20
 670:	00 00       	nop
 672:	06 00       	.word	0x0006	; ????
 674:	8c 00       	.word	0x008c	; ????
 676:	88 00       	.word	0x0088	; ????
 678:	22 9f       	mul	r18, r18
 67a:	ec 03       	fmulsu	r22, r20
 67c:	00 00       	nop
 67e:	f2 03       	fmuls	r23, r18
 680:	00 00       	nop
 682:	06 00       	.word	0x0006	; ????
 684:	68 93       	.word	0x9368	; ????
 686:	01 69       	ori	r16, 0x91	; 145
    "__Noops2: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main3 \n"
    );
 688:	93 01       	movw	r18, r6
	...
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "jmp __Noops2 \n"
    : "=d" (a): "d" (b)
    );
 692:	bc 03       	fmulsu	r19, r20
 694:	00 00       	nop
 696:	d2 03       	fmuls	r21, r18
 698:	00 00       	nop
 69a:	06 00       	.word	0x0006	; ????
 69c:	68 93       	.word	0x9368	; ????
 69e:	01 69       	ori	r16, 0x91	; 145
 6a0:	93 01       	movw	r18, r6
 6a2:	d2 03       	fmuls	r21, r18
 6a4:	00 00       	nop
 6a6:	d5 03       	fmuls	r21, r21
 6a8:	00 00       	nop
 6aa:	06 00       	.word	0x0006	; ????
    "__Noops3: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main4 \n"
    );
 6ac:	66 93       	lac	Z, r22
 6ae:	01 67       	ori	r16, 0x71	; 113
 6b0:	93 01       	movw	r18, r6
 6b2:	d5 03       	fmuls	r21, r21
 6b4:	00 00       	nop
    "__Mov: \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    "mov %0, %1 \n"
    : "=d" (a): "d" (b)
    );
 6b6:	d8 03       	fmulsu	r21, r16
 6b8:	00 00       	nop
 6ba:	04 00       	.word	0x0004	; ????
 6bc:	f3 01       	movw	r30, r6
 6be:	68 9f       	mul	r22, r24
	...
 6c8:	bc 03       	fmulsu	r19, r20
 6ca:	00 00       	nop
    "__Noops4: \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "jmp __main5 \n"
    );
 6cc:	d2 03       	fmuls	r21, r18
 6ce:	00 00       	nop
 6d0:	06 00       	.word	0x0006	; ????
 6d2:	68 93       	.word	0x9368	; ????
 6d4:	01 69       	ori	r16, 0x91	; 145
    "__LDST: \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    "ldi %0, %1 \n"
    :"=d" (a) : "M" (42): "r26", "r27"
    );
 6d6:	93 01       	movw	r18, r6
 6d8:	d2 03       	fmuls	r21, r18
 6da:	00 00       	nop
 6dc:	d5 03       	fmuls	r21, r21
 6de:	00 00       	nop
 6e0:	06 00       	.word	0x0006	; ????
 6e2:	66 93       	lac	Z, r22
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 6e4:	01 67       	ori	r16, 0x71	; 113
 6e6:	93 01       	movw	r18, r6
}

void loop(){
  int randNumber1, randNumber2;
  Serial.println("top of loop");
 6e8:	d5 03       	fmuls	r21, r21
 6ea:	00 00       	nop
 6ec:	d8 03       	fmulsu	r21, r16
 6ee:	00 00       	nop
  randomSeed(0);
  noInterrupts();
 6f0:	04 00       	.word	0x0004	; ????
  
  digitalWrite(LED_BUILTIN, LOW);   
 6f2:	f3 01       	movw	r30, r6
 6f4:	68 9f       	mul	r22, r24
	...
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Add \n"
    : "=d" (a): "d" (b)
    );
 6fe:	bc 03       	fmulsu	r19, r20
 700:	00 00       	nop
 702:	d2 03       	fmuls	r21, r18
 704:	00 00       	nop
 706:	06 00       	.word	0x0006	; ????
 708:	68 93       	.word	0x9368	; ????
 70a:	01 69       	ori	r16, 0x91	; 145
 70c:	93 01       	movw	r18, r6
 70e:	d2 03       	fmuls	r21, r18
 710:	00 00       	nop
 712:	d5 03       	fmuls	r21, r21
 714:	00 00       	nop
 716:	06 00       	.word	0x0006	; ????
 718:	66 93       	lac	Z, r22
 71a:	01 67       	ori	r16, 0x71	; 113
 71c:	93 01       	movw	r18, r6
 71e:	d5 03       	fmuls	r21, r21
 720:	00 00       	nop
 722:	d8 03       	fmulsu	r21, r16
 724:	00 00       	nop
 726:	04 00       	.word	0x0004	; ????
 728:	f3 01       	movw	r30, r6
 72a:	68 9f       	mul	r22, r24
	...
 734:	f2 03       	fmuls	r23, r18
 736:	00 00       	nop
 738:	f4 03       	fmuls	r23, r20
 73a:	00 00       	nop
 73c:	03 00       	.word	0x0003	; ????
 73e:	92 20       	and	r9, r2
 740:	02 f4       	brpl	.+0      	; 0x742 <__main1+0x3c>
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mult \n"
    : "=d" (a): "d" (b)
    );
 742:	03 00       	.word	0x0003	; ????
 744:	00 f6       	brcc	.-128    	; 0x6c6 <__Mov+0x8>
 746:	03 00       	.word	0x0003	; ????
 748:	00 03       	mulsu	r16, r16
 74a:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x140>
 74e:	f6 03       	fmuls	r23, r22
 750:	00 00       	nop
 752:	fe 03       	fmulsu	r23, r22
 754:	00 00       	nop
 756:	03 00       	.word	0x0003	; ????
 758:	92 20       	and	r9, r2
 75a:	04 fe       	sbrs	r0, 4
 75c:	03 00       	.word	0x0003	; ????
 75e:	00 00       	nop
 760:	04 00       	.word	0x0004	; ????
 762:	00 03       	mulsu	r16, r16
 764:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x340>
 768:	00 04       	cpc	r0, r0
 76a:	00 00       	nop
 76c:	02 04       	cpc	r0, r2
 76e:	00 00       	nop
 770:	03 00       	.word	0x0003	; ????
 772:	92 20       	and	r9, r2
 774:	06 02       	muls	r16, r22
 776:	04 00       	.word	0x0004	; ????
 778:	00 04       	cpc	r0, r0
 77a:	04 00       	.word	0x0004	; ????
 77c:	00 03       	mulsu	r16, r16
 77e:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x540>
 782:	04 04       	cpc	r0, r4
 784:	00 00       	nop
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __Mov \n"
    : "=d" (a): "d" (b)
    );
 786:	06 04       	cpc	r0, r6
 788:	00 00       	nop
 78a:	03 00       	.word	0x0003	; ????
 78c:	92 20       	and	r9, r2
 78e:	08 06       	cpc	r0, r24
 790:	04 00       	.word	0x0004	; ????
 792:	00 08       	sbc	r0, r0
 794:	04 00       	.word	0x0004	; ????
 796:	00 03       	mulsu	r16, r16
 798:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x740>
 79c:	08 04       	cpc	r0, r8
 79e:	00 00       	nop
 7a0:	86 04       	cpc	r8, r6
 7a2:	00 00       	nop
 7a4:	03 00       	.word	0x0003	; ????
 7a6:	92 20       	and	r9, r2
 7a8:	0a 00       	.word	0x000a	; ????
 7aa:	00 00       	nop
 7ac:	00 00       	nop
 7ae:	00 00       	nop
 7b0:	00 18       	sub	r0, r0
 7b2:	04 00       	.word	0x0004	; ????
 7b4:	00 1c       	adc	r0, r0
 7b6:	04 00       	.word	0x0004	; ????
 7b8:	00 0c       	add	r0, r0
 7ba:	00 68       	ori	r16, 0x80	; 128
 7bc:	93 01       	movw	r18, r6
 7be:	69 93       	st	Y+, r22
 7c0:	01 6a       	ori	r16, 0xA1	; 161
 7c2:	93 01       	movw	r18, r6
 7c4:	6b 93       	.word	0x936b	; ????
 7c6:	01 1c       	adc	r0, r1
 7c8:	04 00       	.word	0x0004	; ????
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "muls %0, %1 \n"
    "call __LDST \n"
    : "=d" (a): "d" (b)
    );
 7ca:	00 2a       	or	r0, r16
 7cc:	04 00       	.word	0x0004	; ????
 7ce:	00 03       	mulsu	r16, r16
 7d0:	00 88       	ldd	r0, Z+16	; 0x10
 7d2:	01 9f       	mul	r16, r17
 7d4:	2a 04       	cpc	r2, r10
 7d6:	00 00       	nop
 7d8:	4e 04       	cpc	r4, r14
 7da:	00 00       	nop
 7dc:	0c 00       	.word	0x000c	; ????
 7de:	68 93       	.word	0x9368	; ????
 7e0:	01 69       	ori	r16, 0x91	; 145
 7e2:	93 01       	movw	r18, r6
 7e4:	6a 93       	st	-Y, r22
 7e6:	01 6b       	ori	r16, 0xB1	; 177
 7e8:	93 01       	movw	r18, r6
 7ea:	4e 04       	cpc	r4, r14
 7ec:	00 00       	nop
 7ee:	64 04       	cpc	r6, r4
 7f0:	00 00       	nop
 7f2:	05 00       	.word	0x0005	; ????
 7f4:	03 3f       	cpi	r16, 0xF3	; 243
 7f6:	01 80       	ldd	r0, Z+1	; 0x01
 7f8:	00 7a       	andi	r16, 0xA0	; 160
 7fa:	04 00       	.word	0x0004	; ????
 7fc:	00 84       	ldd	r0, Z+8	; 0x08
 7fe:	04 00       	.word	0x0004	; ????
 800:	00 03       	mulsu	r16, r16
 802:	00 88       	ldd	r0, Z+16	; 0x10
 804:	01 9f       	mul	r16, r17
 806:	84 04       	cpc	r8, r4
 808:	00 00       	nop
 80a:	86 04       	cpc	r8, r6
 80c:	00 00       	nop
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    "nop \n"
    );
 80e:	0c 00       	.word	0x000c	; ????
 810:	68 93       	.word	0x9368	; ????
 812:	01 69       	ori	r16, 0x91	; 145
 814:	93 01       	movw	r18, r6
 816:	6a 93       	st	-Y, r22
 818:	01 6b       	ori	r16, 0xB1	; 177
 81a:	93 01       	movw	r18, r6
	...
 824:	1c 04       	cpc	r1, r12
 826:	00 00       	nop
 828:	20 04       	cpc	r2, r0
 82a:	00 00       	nop
 82c:	01 00       	.word	0x0001	; ????
 82e:	63 20       	and	r6, r3
 830:	04 00       	.word	0x0004	; ????
 832:	00 70       	andi	r16, 0x00	; 0
 834:	04 00       	.word	0x0004	; ????
 836:	00 01       	movw	r0, r0
 838:	00 62       	ori	r16, 0x20	; 32
 83a:	70 04       	cpc	r7, r0
 83c:	00 00       	nop
  Serial.println("End of loop");
 83e:	74 04       	cpc	r7, r4
 840:	00 00       	nop
 842:	05 00       	.word	0x0005	; ????
 844:	03 3e       	cpi	r16, 0xE3	; 227
  interrupts();
 846:	01 80       	ldd	r0, Z+1	; 0x01
 848:	00 7a       	andi	r16, 0xA0	; 160
 84a:	04 00       	.word	0x0004	; ????
 84c:	00 7c       	andi	r16, 0xC0	; 192
 84e:	04 00       	.word	0x0004	; ????
 850:	00 01       	movw	r0, r0
 852:	00 62       	ori	r16, 0x20	; 32
 854:	7c 04       	cpc	r7, r12
 856:	00 00       	nop
 858:	7e 04       	cpc	r7, r14
 85a:	00 00       	nop
 85c:	03 00       	.word	0x0003	; ????
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 85e:	83 03       	fmuls	r16, r19
 860:	9f 7e       	andi	r25, 0xEF	; 239
 862:	04 00       	.word	0x0004	; ????
 864:	00 86       	std	Z+8, r0	; 0x08
 866:	04 00       	.word	0x0004	; ????
 868:	00 01       	movw	r0, r0
 86a:	00 62       	ori	r16, 0x20	; 32
	...
 874:	bc 05       	cpc	r27, r12
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 876:	00 00       	nop
 878:	f2 05       	cpc	r31, r2
 87a:	00 00       	nop
 87c:	02 00       	.word	0x0002	; ????
 87e:	3d 9f       	mul	r19, r29
	...
 888:	bc 05       	cpc	r27, r12
 88a:	00 00       	nop
 88c:	f2 05       	cpc	r31, r2
 88e:	00 00       	nop
 890:	02 00       	.word	0x0002	; ????
 892:	31 9f       	mul	r19, r17
	...
 89c:	c2 05       	cpc	r28, r2
 89e:	00 00       	nop
 8a0:	63 06       	cpc	r6, r19
 8a2:	00 00       	nop
 8a4:	01 00       	.word	0x0001	; ????
 8a6:	62 00       	.word	0x0062	; ????
 8a8:	00 00       	nop
 8aa:	00 00       	nop
 8ac:	00 00       	nop
 8ae:	00 c8       	rjmp	.-4096   	; 0xfffff8b0 <__eeprom_end+0xff7ef8b0>
 8b0:	05 00       	.word	0x0005	; ????
 8b2:	00 d2       	rcall	.+1024   	; 0xcb4 <__data_load_end+0x3b2>
 8b4:	05 00       	.word	0x0005	; ????

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
 8b6:	00 01       	movw	r0, r0
 8b8:	00 68       	ori	r16, 0x80	; 128
	...
 8c2:	dc 05       	cpc	r29, r12
 8c4:	00 00       	nop
 8c6:	f2 05       	cpc	r31, r2
 8c8:	00 00       	nop
 8ca:	06 00       	.word	0x0006	; ????
 8cc:	6a 93       	st	-Y, r22
 8ce:	01 6b       	ori	r16, 0xB1	; 177
 8d0:	93 01       	movw	r18, r6
	...
 8da:	c0 05       	cpc	r28, r0
 8dc:	00 00       	nop
 8de:	c6 05       	cpc	r28, r6
 8e0:	00 00       	nop
 8e2:	06 00       	.word	0x0006	; ????
 8e4:	6e 93       	st	-X, r22
 8e6:	01 6f       	ori	r16, 0xF1	; 241
 8e8:	93 01       	movw	r18, r6
	...
 8f2:	c2 05       	cpc	r28, r2
 8f4:	00 00       	nop
 8f6:	f2 05       	cpc	r31, r2
 8f8:	00 00       	nop
 8fa:	01 00       	.word	0x0001	; ????
 8fc:	62 00       	.word	0x0062	; ????
 8fe:	00 00       	nop
 900:	00 00       	nop
 902:	00 00       	nop
 904:	00 c6       	rjmp	.+3072   	; 0x1506 <__data_load_end+0xc04>
 906:	05 00       	.word	0x0005	; ????
 908:	00 d4       	rcall	.+2048   	; 0x110a <__data_load_end+0x808>
 90a:	05 00       	.word	0x0005	; ????
 90c:	00 06       	cpc	r0, r16
 90e:	00 6e       	ori	r16, 0xE0	; 224
 910:	93 01       	movw	r18, r6
 912:	6f 93       	push	r22
 914:	01 00       	.word	0x0001	; ????
 916:	00 00       	nop
 918:	00 00       	nop
 91a:	00 00       	nop
 91c:	00 d8       	rcall	.-4096   	; 0xfffff91e <__eeprom_end+0xff7ef91e>
 91e:	05 00       	.word	0x0005	; ????
 920:	00 dc       	rcall	.-2048   	; 0x122 <digitalWrite.constprop.4+0x14>
 922:	05 00       	.word	0x0005	; ????
 924:	00 06       	cpc	r0, r16
 926:	00 6e       	ori	r16, 0xE0	; 224
 928:	93 01       	movw	r18, r6
 92a:	6f 93       	push	r22
 92c:	01 00       	.word	0x0001	; ????
 92e:	00 00       	nop
 930:	00 00       	nop
 932:	00 00       	nop
 934:	00 e2       	ldi	r16, 0x20	; 32
 936:	05 00       	.word	0x0005	; ????
 938:	00 e6       	ldi	r16, 0x60	; 96
 93a:	05 00       	.word	0x0005	; ????
 93c:	00 06       	cpc	r0, r16
 93e:	00 6e       	ori	r16, 0xE0	; 224
 940:	93 01       	movw	r18, r6
 942:	6f 93       	push	r22
 944:	01 00       	.word	0x0001	; ????
 946:	00 00       	nop
 948:	00 00       	nop
 94a:	00 00       	nop
 94c:	00 e8       	ldi	r16, 0x80	; 128
 94e:	05 00       	.word	0x0005	; ????
 950:	00 f2       	brcs	.-128    	; 0x8d2 <__data_load_start+0xa>
 952:	05 00       	.word	0x0005	; ????
 954:	00 01       	movw	r0, r0
 956:	00 68       	ori	r16, 0x80	; 128
	...
 960:	f2 05       	cpc	r31, r2
 962:	00 00       	nop
 964:	5c 06       	cpc	r5, r28
 966:	00 00       	nop
 968:	04 00       	.word	0x0004	; ????
 96a:	0a 80       	ldd	r0, Y+2	; 0x02
 96c:	25 9f       	mul	r18, r21
	...
 976:	f2 05       	cpc	r31, r2
 978:	00 00       	nop
 97a:	5c 06       	cpc	r5, r28
 97c:	00 00       	nop
 97e:	02 00       	.word	0x0002	; ????
 980:	36 9f       	mul	r19, r22
	...
 98a:	f2 05       	cpc	r31, r2
 98c:	00 00       	nop
 98e:	5c 06       	cpc	r5, r28
 990:	00 00       	nop
 992:	03 00       	.word	0x0003	; ????
 994:	08 cf       	rjmp	.-496    	; 0x7a6 <__main3+0x18>
 996:	9f 00       	.word	0x009f	; ????
 998:	00 00       	nop
 99a:	00 00       	nop
 99c:	00 00       	nop
 99e:	00 5e       	subi	r16, 0xE0	; 224
 9a0:	08 00       	.word	0x0008	; ????
 9a2:	00 b6       	in	r0, 0x30	; 48
 9a4:	08 00       	.word	0x0008	; ????
 9a6:	00 02       	muls	r16, r16
 9a8:	00 31       	cpi	r16, 0x10	; 16
 9aa:	9f 00       	.word	0x009f	; ????
 9ac:	00 00       	nop
 9ae:	00 00       	nop
 9b0:	00 00       	nop
 9b2:	00 5e       	subi	r16, 0xE0	; 224
 9b4:	08 00       	.word	0x0008	; ????
 9b6:	00 b6       	in	r0, 0x30	; 48
 9b8:	08 00       	.word	0x0008	; ????
 9ba:	00 03       	mulsu	r16, r16
 9bc:	00 09       	sbc	r16, r0
 9be:	ff 9f       	mul	r31, r31
	...
 9c8:	86 04       	cpc	r8, r6
 9ca:	00 00       	nop
 9cc:	88 04       	cpc	r8, r8
 9ce:	00 00       	nop
 9d0:	03 00       	.word	0x0003	; ????
 9d2:	92 20       	and	r9, r2
 9d4:	02 88       	ldd	r0, Z+18	; 0x12
 9d6:	04 00       	.word	0x0004	; ????
 9d8:	00 8a       	std	Z+16, r0	; 0x10
 9da:	04 00       	.word	0x0004	; ????
 9dc:	00 03       	mulsu	r16, r16
 9de:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x140>
 9e2:	8a 04       	cpc	r8, r10
 9e4:	00 00       	nop
 9e6:	92 04       	cpc	r9, r2
 9e8:	00 00       	nop
 9ea:	03 00       	.word	0x0003	; ????
 9ec:	92 20       	and	r9, r2
 9ee:	04 92       	xch	Z, r0
 9f0:	04 00       	.word	0x0004	; ????
 9f2:	00 94       	com	r0
 9f4:	04 00       	.word	0x0004	; ????
 9f6:	00 03       	mulsu	r16, r16
 9f8:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x340>
 9fc:	94 04       	cpc	r9, r4
 9fe:	00 00       	nop
 a00:	96 04       	cpc	r9, r6
 a02:	00 00       	nop
 a04:	03 00       	.word	0x0003	; ????
 a06:	92 20       	and	r9, r2
 a08:	06 96       	adiw	r24, 0x06	; 6
 a0a:	04 00       	.word	0x0004	; ????
 a0c:	00 98       	cbi	0x00, 0	; 0
 a0e:	04 00       	.word	0x0004	; ????
 a10:	00 03       	mulsu	r16, r16
 a12:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x540>
 a16:	98 04       	cpc	r9, r8
 a18:	00 00       	nop
 a1a:	9a 04       	cpc	r9, r10
 a1c:	00 00       	nop
 a1e:	03 00       	.word	0x0003	; ????
 a20:	92 20       	and	r9, r2
 a22:	08 9a       	sbi	0x01, 0	; 1
 a24:	04 00       	.word	0x0004	; ????
 a26:	00 9c       	mul	r0, r0
 a28:	04 00       	.word	0x0004	; ????
 a2a:	00 03       	mulsu	r16, r16
 a2c:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x740>
 a30:	9c 04       	cpc	r9, r12
 a32:	00 00       	nop
 a34:	9e 04       	cpc	r9, r14
 a36:	00 00       	nop
 a38:	03 00       	.word	0x0003	; ????
 a3a:	92 20       	and	r9, r2
 a3c:	0a 9e       	mul	r0, r26
 a3e:	04 00       	.word	0x0004	; ????
 a40:	00 a0       	ldd	r0, Z+32	; 0x20
 a42:	04 00       	.word	0x0004	; ????
 a44:	00 03       	mulsu	r16, r16
 a46:	00 92 20 0b 	sts	0x0B20, r0	; 0x800b20 <__bss_end+0x940>
 a4a:	a0 04       	cpc	r10, r0
 a4c:	00 00       	nop
 a4e:	a2 04       	cpc	r10, r2
 a50:	00 00       	nop
 a52:	03 00       	.word	0x0003	; ????
 a54:	92 20       	and	r9, r2
 a56:	0c a2       	std	Y+36, r0	; 0x24
 a58:	04 00       	.word	0x0004	; ????
 a5a:	00 a4       	ldd	r0, Z+40	; 0x28
 a5c:	04 00       	.word	0x0004	; ????
 a5e:	00 03       	mulsu	r16, r16
 a60:	00 92 20 0d 	sts	0x0D20, r0	; 0x800d20 <__bss_end+0xb40>
 a64:	a4 04       	cpc	r10, r4
 a66:	00 00       	nop
 a68:	a6 04       	cpc	r10, r6
 a6a:	00 00       	nop
 a6c:	03 00       	.word	0x0003	; ????
 a6e:	92 20       	and	r9, r2
 a70:	0e a6       	std	Y+46, r0	; 0x2e
 a72:	04 00       	.word	0x0004	; ????
 a74:	00 a8       	ldd	r0, Z+48	; 0x30
 a76:	04 00       	.word	0x0004	; ????
 a78:	00 03       	mulsu	r16, r16
 a7a:	00 92 20 0f 	sts	0x0F20, r0	; 0x800f20 <__bss_end+0xd40>
 a7e:	a8 04       	cpc	r10, r8
 a80:	00 00       	nop
 a82:	d2 04       	cpc	r13, r2
 a84:	00 00       	nop
 a86:	03 00       	.word	0x0003	; ????
 a88:	92 20       	and	r9, r2
 a8a:	10 00       	.word	0x0010	; ????
 a8c:	00 00       	nop
 a8e:	00 00       	nop
 a90:	00 00       	nop
 a92:	00 d2       	rcall	.+1024   	; 0xe94 <__data_load_end+0x592>
 a94:	04 00       	.word	0x0004	; ????
 a96:	00 d4       	rcall	.+2048   	; 0x1298 <__data_load_end+0x996>
 a98:	04 00       	.word	0x0004	; ????
 a9a:	00 03       	mulsu	r16, r16
 a9c:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x40>
 aa0:	d4 04       	cpc	r13, r4
 aa2:	00 00       	nop
 aa4:	d6 04       	cpc	r13, r6
 aa6:	00 00       	nop
 aa8:	03 00       	.word	0x0003	; ????
 aaa:	92 20       	and	r9, r2
 aac:	03 d6       	rcall	.+3078   	; 0x16b4 <__data_load_end+0xdb2>
 aae:	04 00       	.word	0x0004	; ????
 ab0:	00 de       	rcall	.-1024   	; 0x6b2 <__Noops3+0x6>
 ab2:	04 00       	.word	0x0004	; ????
 ab4:	00 03       	mulsu	r16, r16
 ab6:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x240>
 aba:	de 04       	cpc	r13, r14
 abc:	00 00       	nop
 abe:	e0 04       	cpc	r14, r0
 ac0:	00 00       	nop
 ac2:	03 00       	.word	0x0003	; ????
 ac4:	92 20       	and	r9, r2
 ac6:	05 e0       	ldi	r16, 0x05	; 5
 ac8:	04 00       	.word	0x0004	; ????
 aca:	00 e2       	ldi	r16, 0x20	; 32
 acc:	04 00       	.word	0x0004	; ????
 ace:	00 03       	mulsu	r16, r16
 ad0:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x440>
 ad4:	e2 04       	cpc	r14, r2
 ad6:	00 00       	nop
 ad8:	e4 04       	cpc	r14, r4
 ada:	00 00       	nop
 adc:	03 00       	.word	0x0003	; ????
 ade:	92 20       	and	r9, r2
 ae0:	07 e4       	ldi	r16, 0x47	; 71
 ae2:	04 00       	.word	0x0004	; ????
 ae4:	00 e6       	ldi	r16, 0x60	; 96
 ae6:	04 00       	.word	0x0004	; ????
 ae8:	00 03       	mulsu	r16, r16
 aea:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x640>
 aee:	e6 04       	cpc	r14, r6
 af0:	00 00       	nop
 af2:	36 05       	cpc	r19, r6
 af4:	00 00       	nop
 af6:	03 00       	.word	0x0003	; ????
 af8:	92 20       	and	r9, r2
 afa:	09 00       	.word	0x0009	; ????
 afc:	00 00       	nop
 afe:	00 00       	nop
 b00:	00 00       	nop
 b02:	00 fe       	sbrs	r0, 0
 b04:	04 00       	.word	0x0004	; ????
 b06:	00 1e       	adc	r0, r16
 b08:	05 00       	.word	0x0005	; ????
 b0a:	00 01       	movw	r0, r0
 b0c:	00 69       	ori	r16, 0x90	; 144
	...
 b16:	06 05       	cpc	r16, r6
 b18:	00 00       	nop
 b1a:	1e 05       	cpc	r17, r14
 b1c:	00 00       	nop
 b1e:	01 00       	.word	0x0001	; ????
 b20:	68 00       	.word	0x0068	; ????
 b22:	00 00       	nop
 b24:	00 00       	nop
 b26:	00 00       	nop
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	28 01       	movw	r4, r16
   2:	00 00       	nop
   4:	36 01       	movw	r6, r12
   6:	00 00       	nop
   8:	58 01       	movw	r10, r16
   a:	00 00       	nop
   c:	9a 01       	movw	r18, r20
	...
  16:	00 00       	nop
  18:	16 03       	mulsu	r17, r22
  1a:	00 00       	nop
  1c:	1a 03       	fmul	r17, r18
  1e:	00 00       	nop
  20:	68 03       	fmul	r22, r16
  22:	00 00       	nop
  24:	78 03       	fmul	r23, r16
	...
  2e:	00 00       	nop
  30:	e4 06       	cpc	r14, r20
  32:	00 00       	nop
  34:	e8 06       	cpc	r14, r24
  36:	00 00       	nop
  38:	48 08       	sbc	r4, r8
  3a:	00 00       	nop
  3c:	5e 08       	sbc	r5, r14
	...
  46:	00 00       	nop
  48:	e6 04       	cpc	r14, r6
  4a:	00 00       	nop
  4c:	1e 05       	cpc	r17, r14
  4e:	00 00       	nop
  50:	32 05       	cpc	r19, r2
  52:	00 00       	nop
  54:	36 05       	cpc	r19, r6
	...
  5e:	00 00       	nop
  60:	0e 01       	movw	r0, r28
  62:	00 00       	nop
  64:	36 05       	cpc	r19, r6
  66:	00 00       	nop
  68:	36 05       	cpc	r19, r6
  6a:	00 00       	nop
  6c:	5e 08       	sbc	r5, r14
  6e:	00 00       	nop
  70:	5e 08       	sbc	r5, r14
  72:	00 00       	nop
  74:	b8 08       	sbc	r11, r8
	...
