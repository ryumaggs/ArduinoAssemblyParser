
.\LADS_control_flow_if_false_loop\LADS_control_flow_if_false_loop.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__ctors_end>
   4:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
   8:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
   c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  10:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  14:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  18:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  1c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  20:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  24:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  28:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  2c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  30:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  34:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  38:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  3c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  40:	0c 94 b8 00 	jmp	0x170	; 0x170 <__vector_16>
  44:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  48:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  4c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  50:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  54:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  58:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  5c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  60:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  64:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	24 00       	.word	0x0024	; ????
  6e:	27 00       	.word	0x0027	; ????
  70:	2a 00       	.word	0x002a	; ????

00000072 <port_to_output_PGM>:
  72:	00 00       	nop
  74:	00 00       	nop
  76:	25 00       	.word	0x0025	; ????
  78:	28 00       	.word	0x0028	; ????
  7a:	2b 00       	.word	0x002b	; ????

0000007c <digital_pin_to_port_PGM>:
  7c:	04 04       	cpc	r0, r4
  7e:	04 04       	cpc	r0, r4
  80:	04 04       	cpc	r0, r4
  82:	04 04       	cpc	r0, r4
  84:	02 02       	muls	r16, r18
  86:	02 02       	muls	r16, r18
  88:	02 02       	muls	r16, r18
  8a:	03 03       	mulsu	r16, r19
  8c:	03 03       	mulsu	r16, r19
  8e:	03 03       	mulsu	r16, r19

00000090 <digital_pin_to_bit_mask_PGM>:
  90:	01 02       	muls	r16, r17
  92:	04 08       	sbc	r0, r4
  94:	10 20       	and	r1, r0
  96:	40 80       	ld	r4, Z
  98:	01 02       	muls	r16, r17
  9a:	04 08       	sbc	r0, r4
  9c:	10 20       	and	r1, r0
  9e:	01 02       	muls	r16, r17
  a0:	04 08       	sbc	r0, r4
  a2:	10 20       	and	r1, r0

000000a4 <digital_pin_to_timer_PGM>:
  a4:	00 00       	nop
  a6:	00 08       	sbc	r0, r0
  a8:	00 02       	muls	r16, r16
  aa:	01 00       	.word	0x0001	; ????
  ac:	00 03       	mulsu	r16, r16
  ae:	04 07       	cpc	r16, r20
	...

000000b8 <__ctors_end>:
  b8:	11 24       	eor	r1, r1
  ba:	1f be       	out	0x3f, r1	; 63
  bc:	cf ef       	ldi	r28, 0xFF	; 255
  be:	d8 e0       	ldi	r29, 0x08	; 8
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	cd bf       	out	0x3d, r28	; 61

000000c4 <__do_clear_bss>:
  c4:	21 e0       	ldi	r18, 0x01	; 1
  c6:	a0 e0       	ldi	r26, 0x00	; 0
  c8:	b1 e0       	ldi	r27, 0x01	; 1
  ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
  cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
  ce:	a5 31       	cpi	r26, 0x15	; 21
  d0:	b2 07       	cpc	r27, r18
  d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
  d4:	0e 94 02 01 	call	0x204	; 0x204 <main>
  d8:	0c 94 09 02 	jmp	0x412	; 0x412 <_exit>

000000dc <__bad_interrupt>:
  dc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000e0 <digitalWrite.constprop.0>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	e1 eb       	ldi	r30, 0xB1	; 177
  e2:	f0 e0       	ldi	r31, 0x00	; 0
  e4:	24 91       	lpm	r18, Z
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	ed e9       	ldi	r30, 0x9D	; 157
  e8:	f0 e0       	ldi	r31, 0x00	; 0
  ea:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
  ec:	e9 e8       	ldi	r30, 0x89	; 137
  ee:	f0 e0       	ldi	r31, 0x00	; 0
  f0:	e4 91       	lpm	r30, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	ee 23       	and	r30, r30
  f4:	c9 f0       	breq	.+50     	; 0x128 <digitalWrite.constprop.0+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	22 23       	and	r18, r18
  f8:	39 f0       	breq	.+14     	; 0x108 <digitalWrite.constprop.0+0x28>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	23 30       	cpi	r18, 0x03	; 3
  fc:	01 f1       	breq	.+64     	; 0x13e <digitalWrite.constprop.0+0x5e>
  fe:	a8 f4       	brcc	.+42     	; 0x12a <digitalWrite.constprop.0+0x4a>
 100:	21 30       	cpi	r18, 0x01	; 1
 102:	19 f1       	breq	.+70     	; 0x14a <digitalWrite.constprop.0+0x6a>
 104:	22 30       	cpi	r18, 0x02	; 2
 106:	29 f1       	breq	.+74     	; 0x152 <digitalWrite.constprop.0+0x72>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	ee 0f       	add	r30, r30
 10c:	ff 1f       	adc	r31, r31
 10e:	ee 58       	subi	r30, 0x8E	; 142
 110:	ff 4f       	sbci	r31, 0xFF	; 255
 112:	a5 91       	lpm	r26, Z+
 114:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 116:	2f b7       	in	r18, 0x3f	; 63
	cli();
 118:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
 11a:	ec 91       	ld	r30, X
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	81 11       	cpse	r24, r1
 11e:	26 c0       	rjmp	.+76     	; 0x16c <digitalWrite.constprop.0+0x8c>
		*out &= ~bit;
 120:	90 95       	com	r25
 122:	9e 23       	and	r25, r30
	} else {
		*out |= bit;
 124:	9c 93       	st	X, r25
	}

	SREG = oldSREG;
 126:	2f bf       	out	0x3f, r18	; 63
}
 128:	08 95       	ret
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	27 30       	cpi	r18, 0x07	; 7
 12c:	a9 f0       	breq	.+42     	; 0x158 <digitalWrite.constprop.0+0x78>
 12e:	28 30       	cpi	r18, 0x08	; 8
 130:	c9 f0       	breq	.+50     	; 0x164 <digitalWrite.constprop.0+0x84>
 132:	24 30       	cpi	r18, 0x04	; 4
 134:	49 f7       	brne	.-46     	; 0x108 <digitalWrite.constprop.0+0x28>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 13a:	2f 7d       	andi	r18, 0xDF	; 223
 13c:	03 c0       	rjmp	.+6      	; 0x144 <digitalWrite.constprop.0+0x64>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 142:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 148:	df cf       	rjmp	.-66     	; 0x108 <digitalWrite.constprop.0+0x28>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	24 b5       	in	r18, 0x24	; 36
 14c:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	24 bd       	out	0x24, r18	; 36
 150:	db cf       	rjmp	.-74     	; 0x108 <digitalWrite.constprop.0+0x28>
 152:	24 b5       	in	r18, 0x24	; 36
 154:	2f 7d       	andi	r18, 0xDF	; 223
 156:	fb cf       	rjmp	.-10     	; 0x14e <digitalWrite.constprop.0+0x6e>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 15c:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 162:	d2 cf       	rjmp	.-92     	; 0x108 <digitalWrite.constprop.0+0x28>
 164:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 168:	2f 7d       	andi	r18, 0xDF	; 223
 16a:	f9 cf       	rjmp	.-14     	; 0x15e <digitalWrite.constprop.0+0x7e>
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	9e 2b       	or	r25, r30
 16e:	da cf       	rjmp	.-76     	; 0x124 <digitalWrite.constprop.0+0x44>

00000170 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	1f 92       	push	r1
 172:	0f 92       	push	r0
 174:	0f b6       	in	r0, 0x3f	; 63
 176:	0f 92       	push	r0
 178:	11 24       	eor	r1, r1
 17a:	2f 93       	push	r18
 17c:	3f 93       	push	r19
 17e:	8f 93       	push	r24
 180:	9f 93       	push	r25
 182:	af 93       	push	r26
 184:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <timer0_millis>
 18a:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <timer0_millis+0x1>
 18e:	a0 91 13 01 	lds	r26, 0x0113	; 0x800113 <timer0_millis+0x2>
 192:	b0 91 14 01 	lds	r27, 0x0114	; 0x800114 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 196:	30 91 10 01 	lds	r19, 0x0110	; 0x800110 <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	23 e0       	ldi	r18, 0x03	; 3
 19c:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 19e:	2d 37       	cpi	r18, 0x7D	; 125
 1a0:	58 f5       	brcc	.+86     	; 0x1f8 <__vector_16+0x88>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	01 96       	adiw	r24, 0x01	; 1
 1a4:	a1 1d       	adc	r26, r1
 1a6:	b1 1d       	adc	r27, r1
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	20 93 10 01 	sts	0x0110, r18	; 0x800110 <timer0_fract>
	timer0_millis = m;
 1ac:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <timer0_millis>
 1b0:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <timer0_millis+0x1>
 1b4:	a0 93 13 01 	sts	0x0113, r26	; 0x800113 <timer0_millis+0x2>
 1b8:	b0 93 14 01 	sts	0x0114, r27	; 0x800114 <timer0_millis+0x3>
	timer0_overflow_count++;
 1bc:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <timer0_overflow_count>
 1c0:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <timer0_overflow_count+0x1>
 1c4:	a0 91 0e 01 	lds	r26, 0x010E	; 0x80010e <timer0_overflow_count+0x2>
 1c8:	b0 91 0f 01 	lds	r27, 0x010F	; 0x80010f <timer0_overflow_count+0x3>
 1cc:	01 96       	adiw	r24, 0x01	; 1
 1ce:	a1 1d       	adc	r26, r1
 1d0:	b1 1d       	adc	r27, r1
 1d2:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <timer0_overflow_count>
 1d6:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <timer0_overflow_count+0x1>
 1da:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <timer0_overflow_count+0x2>
 1de:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <timer0_overflow_count+0x3>
}
 1e2:	bf 91       	pop	r27
 1e4:	af 91       	pop	r26
 1e6:	9f 91       	pop	r25
 1e8:	8f 91       	pop	r24
 1ea:	3f 91       	pop	r19
 1ec:	2f 91       	pop	r18
 1ee:	0f 90       	pop	r0
 1f0:	0f be       	out	0x3f, r0	; 63
 1f2:	0f 90       	pop	r0
 1f4:	1f 90       	pop	r1
 1f6:	18 95       	reti
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	26 e8       	ldi	r18, 0x86	; 134
 1fa:	23 0f       	add	r18, r19
		m += 1;
 1fc:	02 96       	adiw	r24, 0x02	; 2
 1fe:	a1 1d       	adc	r26, r1
 200:	b1 1d       	adc	r27, r1
 202:	d2 cf       	rjmp	.-92     	; 0x1a8 <__vector_16+0x38>

00000204 <main>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	84 b5       	in	r24, 0x24	; 36
 208:	82 60       	ori	r24, 0x02	; 2
 20a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 20c:	84 b5       	in	r24, 0x24	; 36
 20e:	81 60       	ori	r24, 0x01	; 1
 210:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	85 b5       	in	r24, 0x25	; 37
 214:	82 60       	ori	r24, 0x02	; 2
 216:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 218:	85 b5       	in	r24, 0x25	; 37
 21a:	81 60       	ori	r24, 0x01	; 1
 21c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 222:	81 60       	ori	r24, 0x01	; 1
 224:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 230:	82 60       	ori	r24, 0x02	; 2
 232:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 23a:	81 60       	ori	r24, 0x01	; 1
 23c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 244:	81 60       	ori	r24, 0x01	; 1
 246:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 24e:	84 60       	ori	r24, 0x04	; 4
 250:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 258:	81 60       	ori	r24, 0x01	; 1
 25a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 262:	84 60       	ori	r24, 0x04	; 4
 264:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS1);
 268:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 26c:	82 60       	ori	r24, 0x02	; 2
 26e:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS0);
 272:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 276:	81 60       	ori	r24, 0x01	; 1
 278:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 280:	80 68       	ori	r24, 0x80	; 128
 282:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	ed e9       	ldi	r30, 0x9D	; 157
 28c:	f0 e0       	ldi	r31, 0x00	; 0
 28e:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 290:	e9 e8       	ldi	r30, 0x89	; 137
 292:	f0 e0       	ldi	r31, 0x00	; 0
 294:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	88 23       	and	r24, r24
 298:	99 f0       	breq	.+38     	; 0x2c0 <main+0xbc>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	88 0f       	add	r24, r24
 29e:	99 1f       	adc	r25, r25
 2a0:	fc 01       	movw	r30, r24
 2a2:	e8 59       	subi	r30, 0x98	; 152
 2a4:	ff 4f       	sbci	r31, 0xFF	; 255
 2a6:	a5 91       	lpm	r26, Z+
 2a8:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
 2aa:	fc 01       	movw	r30, r24
 2ac:	ee 58       	subi	r30, 0x8E	; 142
 2ae:	ff 4f       	sbci	r31, 0xFF	; 255
 2b0:	85 91       	lpm	r24, Z+
 2b2:	94 91       	lpm	r25, Z
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	8f b7       	in	r24, 0x3f	; 63
                cli();
 2b6:	f8 94       	cli
		*reg |= bit;
 2b8:	ec 91       	ld	r30, X
 2ba:	e2 2b       	or	r30, r18
 2bc:	ec 93       	st	X, r30
		SREG = oldSREG;
 2be:	8f bf       	out	0x3f, r24	; 63
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
 2c4:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_edata+0x1>
 2c8:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <_edata+0x2>
 2cc:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <_edata+0x3>
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	cc 24       	eor	r12, r12
 2d2:	ca 94       	dec	r12
 2d4:	dc 2c       	mov	r13, r12
 2d6:	76 01       	movw	r14, r12
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 2d8:	c0 e0       	ldi	r28, 0x00	; 0
 2da:	d0 e0       	ldi	r29, 0x00	; 0

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	f8 94       	cli
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	80 e0       	ldi	r24, 0x00	; 0
 2e0:	0e 94 70 00 	call	0xe0	; 0xe0 <digitalWrite.constprop.0>
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	0e 94 70 00 	call	0xe0	; 0xe0 <digitalWrite.constprop.0>
 2ea:	8f e0       	ldi	r24, 0x0F	; 15
 2ec:	90 e0       	ldi	r25, 0x00	; 0
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <a>
 2f2:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <a+0x1>
 2f6:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <a+0x2>
 2fa:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <a+0x3>
    b = 0xffffffff; 
 2fe:	c0 92 04 01 	sts	0x0104, r12	; 0x800104 <b>
 302:	d0 92 05 01 	sts	0x0105, r13	; 0x800105 <b+0x1>
 306:	e0 92 06 01 	sts	0x0106, r14	; 0x800106 <b+0x2>
 30a:	f0 92 07 01 	sts	0x0107, r15	; 0x800107 <b+0x3>
    a |= b;
 30e:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <b>
 312:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <b+0x1>
 316:	60 91 06 01 	lds	r22, 0x0106	; 0x800106 <b+0x2>
 31a:	70 91 07 01 	lds	r23, 0x0107	; 0x800107 <b+0x3>
 31e:	00 91 08 01 	lds	r16, 0x0108	; 0x800108 <a>
 322:	10 91 09 01 	lds	r17, 0x0109	; 0x800109 <a+0x1>
 326:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <a+0x2>
 32a:	30 91 0b 01 	lds	r19, 0x010B	; 0x80010b <a+0x3>
 32e:	40 2b       	or	r20, r16
 330:	51 2b       	or	r21, r17
 332:	62 2b       	or	r22, r18
 334:	73 2b       	or	r23, r19
 336:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <a>
 33a:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <a+0x1>
 33e:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <a+0x2>
 342:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <a+0x3>
    b = 0x00000000;
 346:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <b>
 34a:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <b+0x1>
 34e:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <b+0x2>
 352:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <b+0x3>
    if(x){
 356:	40 91 00 01 	lds	r20, 0x0100	; 0x800100 <_edata>
 35a:	50 91 01 01 	lds	r21, 0x0101	; 0x800101 <_edata+0x1>
 35e:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <_edata+0x2>
 362:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <_edata+0x3>
 366:	45 2b       	or	r20, r21
 368:	46 2b       	or	r20, r22
 36a:	47 2b       	or	r20, r23
 36c:	41 f0       	breq	.+16     	; 0x37e <main+0x17a>
      //a &= b;
      b = 0xffffffff; 
 36e:	c0 92 04 01 	sts	0x0104, r12	; 0x800104 <b>
 372:	d0 92 05 01 	sts	0x0105, r13	; 0x800105 <b+0x1>
 376:	e0 92 06 01 	sts	0x0106, r14	; 0x800106 <b+0x2>
 37a:	f0 92 07 01 	sts	0x0107, r15	; 0x800107 <b+0x3>
      //a = a^b;
    }
    a &= b;
 37e:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <b>
 382:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <b+0x1>
 386:	60 91 06 01 	lds	r22, 0x0106	; 0x800106 <b+0x2>
 38a:	70 91 07 01 	lds	r23, 0x0107	; 0x800107 <b+0x3>
 38e:	00 91 08 01 	lds	r16, 0x0108	; 0x800108 <a>
 392:	10 91 09 01 	lds	r17, 0x0109	; 0x800109 <a+0x1>
 396:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <a+0x2>
 39a:	30 91 0b 01 	lds	r19, 0x010B	; 0x80010b <a+0x3>
 39e:	40 23       	and	r20, r16
 3a0:	51 23       	and	r21, r17
 3a2:	62 23       	and	r22, r18
 3a4:	73 23       	and	r23, r19
 3a6:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <a>
 3aa:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <a+0x1>
 3ae:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <a+0x2>
 3b2:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <a+0x3>
    b = 0xffffffff; 
 3b6:	c0 92 04 01 	sts	0x0104, r12	; 0x800104 <b>
 3ba:	d0 92 05 01 	sts	0x0105, r13	; 0x800105 <b+0x1>
 3be:	e0 92 06 01 	sts	0x0106, r14	; 0x800106 <b+0x2>
 3c2:	f0 92 07 01 	sts	0x0107, r15	; 0x800107 <b+0x3>
    a = a^b;
 3c6:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <a>
 3ca:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <a+0x1>
 3ce:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <a+0x2>
 3d2:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <a+0x3>
 3d6:	00 91 04 01 	lds	r16, 0x0104	; 0x800104 <b>
 3da:	10 91 05 01 	lds	r17, 0x0105	; 0x800105 <b+0x1>
 3de:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <b+0x2>
 3e2:	30 91 07 01 	lds	r19, 0x0107	; 0x800107 <b+0x3>
 3e6:	40 27       	eor	r20, r16
 3e8:	51 27       	eor	r21, r17
 3ea:	62 27       	eor	r22, r18
 3ec:	73 27       	eor	r23, r19
 3ee:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <a>
 3f2:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <a+0x1>
 3f6:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <a+0x2>
 3fa:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <a+0x3>
 3fe:	01 97       	sbiw	r24, 0x01	; 1
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	09 f0       	breq	.+2      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
 402:	75 cf       	rjmp	.-278    	; 0x2ee <main+0xea>
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	78 94       	sei
 406:	20 97       	sbiw	r28, 0x00	; 0
 408:	09 f4       	brne	.+2      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
 40a:	68 cf       	rjmp	.-304    	; 0x2dc <main+0xd8>
 40c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 410:	65 cf       	rjmp	.-310    	; 0x2dc <main+0xd8>

00000412 <_exit>:
 412:	f8 94       	cli

00000414 <__stop_program>:
 414:	ff cf       	rjmp	.-2      	; 0x414 <__stop_program>

Disassembly of section .bss:

00800100 <__bss_start>:
  800100:	00 00       	nop
	...

00800104 <b>:
  800104:	00 00       	nop
	...

00800108 <a>:
  800108:	00 00       	nop
	...

0080010c <timer0_overflow_count>:
  80010c:	00 00       	nop
	...

00800110 <timer0_fract>:
	...

00800111 <timer0_millis>:
  800111:	00 00       	nop
	...

Disassembly of section .comment:

00000000 <_end-0x800115>:
   0:	47 43       	sbci	r20, 0x37	; 55
   2:	43 3a       	cpi	r20, 0xA3	; 163
   4:	20 28       	or	r2, r0
   6:	47 4e       	sbci	r20, 0xE7	; 231
   8:	55 29       	or	r21, r5
   a:	20 37       	cpi	r18, 0x70	; 112
   c:	2e 33       	cpi	r18, 0x3E	; 62
   e:	2e 30       	cpi	r18, 0x0E	; 14
	...

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 <.note.gnu.avr.deviceinfo>:
   0:	04 00       	.word	0x0004	; ????
   2:	00 00       	nop
   4:	2d 00       	.word	0x002d	; ????
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	00 00       	nop
   c:	41 56       	subi	r20, 0x61	; 97
   e:	52 00       	.word	0x0052	; ????
  10:	00 00       	nop
  12:	00 00       	nop
  14:	00 80       	ld	r0, Z
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	00 00       	nop
  1c:	00 08       	sbc	r0, r0
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 04       	cpc	r0, r0
  26:	00 00       	nop
  28:	08 00       	.word	0x0008	; ????
  2a:	00 00       	nop
  2c:	01 00       	.word	0x0001	; ????
  2e:	00 00       	nop
  30:	00 61       	ori	r16, 0x10	; 16
  32:	74 6d       	ori	r23, 0xD4	; 212
  34:	65 67       	ori	r22, 0x75	; 117
  36:	61 33       	cpi	r22, 0x31	; 49
  38:	32 38       	cpi	r19, 0x82	; 130
  3a:	70 00       	.word	0x0070	; ????
  3c:	00 00       	nop
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	24 00       	.word	0x0024	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	f4 05       	cpc	r31, r4
   8:	00 00       	nop
   a:	04 00       	.word	0x0004	; ????
   c:	00 00       	nop
   e:	00 00       	nop
  10:	e0 00       	.word	0x00e0	; ????
  12:	00 00       	nop
  14:	24 01       	movw	r4, r8
  16:	00 00       	nop
  18:	04 02       	muls	r16, r20
  1a:	00 00       	nop
  1c:	0e 02       	muls	r16, r30
	...
  26:	00 00       	nop
  28:	1c 00       	.word	0x001c	; ????
  2a:	00 00       	nop
  2c:	02 00       	.word	0x0002	; ????
  2e:	3e 0c       	add	r3, r14
  30:	00 00       	nop
  32:	04 00       	.word	0x0004	; ????
  34:	00 00       	nop
  36:	00 00       	nop
  38:	12 04       	cpc	r1, r2
  3a:	00 00       	nop
  3c:	04 00       	.word	0x0004	; ????
	...
  46:	00 00       	nop
  48:	1c 00       	.word	0x001c	; ????
  4a:	00 00       	nop
  4c:	02 00       	.word	0x0002	; ????
  4e:	f9 0c       	add	r15, r9
  50:	00 00       	nop
  52:	04 00       	.word	0x0004	; ????
  54:	00 00       	nop
  56:	00 00       	nop
  58:	c4 00       	.word	0x00c4	; ????
  5a:	00 00       	nop
  5c:	10 00       	.word	0x0010	; ????
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
   0:	f0 05       	cpc	r31, r0
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	00 00       	nop
   8:	00 00       	nop
   a:	04 01       	movw	r0, r8
	...
  14:	02 0f       	add	r16, r18
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	08 03       	fmul	r16, r16
  1c:	17 00       	.word	0x0017	; ????
  1e:	00 00       	nop
  20:	02 07       	cpc	r16, r18
  22:	04 14       	cp	r0, r4
  24:	00 00       	nop
  26:	00 05       	cpc	r16, r0
  28:	1b 00       	.word	0x001b	; ????
  2a:	00 00       	nop
  2c:	ff 03       	fmulsu	r23, r23
  2e:	00 06       	cpc	r0, r16
  30:	20 00       	.word	0x0020	; ????
  32:	00 00       	nop
  34:	00 00       	nop
  36:	22 00       	.word	0x0022	; ????
  38:	00 00       	nop
  3a:	01 05       	cpc	r16, r1
  3c:	03 00       	.word	0x0003	; ????
  3e:	00 81       	ld	r16, Z
  40:	00 07       	cpc	r16, r16
  42:	29 00       	.word	0x0029	; ????
  44:	00 00       	nop
  46:	00 00       	nop
  48:	14 00       	.word	0x0014	; ????
  4a:	00 00       	nop
  4c:	01 05       	cpc	r16, r1
  4e:	03 c6       	rjmp	.+3078   	; 0xc56 <__stack+0x357>
  50:	00 80       	ld	r0, Z
  52:	00 08       	sbc	r0, r0
  54:	2e 00       	.word	0x002e	; ????
  56:	00 00       	nop
  58:	00 00       	nop
  5a:	14 00       	.word	0x0014	; ????
  5c:	00 00       	nop
  5e:	01 05       	cpc	r16, r1
  60:	03 c0       	rjmp	.+6      	; 0x68 <__trampolines_end>
  62:	00 80       	ld	r0, Z
  64:	00 09       	sbc	r16, r0
  66:	35 00       	.word	0x0035	; ????
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	14 00       	.word	0x0014	; ????
  6e:	00 00       	nop
  70:	01 05       	cpc	r16, r1
  72:	03 c1       	rjmp	.+518    	; 0x27a <main+0x76>
  74:	00 80       	ld	r0, Z
  76:	00 0a       	sbc	r0, r16
  78:	3c 00       	.word	0x003c	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	14 00       	.word	0x0014	; ????
  80:	00 00       	nop
  82:	01 05       	cpc	r16, r1
  84:	03 c2       	rjmp	.+1030   	; 0x48c <__data_load_end+0x76>
  86:	00 80       	ld	r0, Z
  88:	00 0b       	sbc	r16, r16
  8a:	43 00       	.word	0x0043	; ????
  8c:	00 00       	nop
  8e:	00 00       	nop
  90:	1b 00       	.word	0x001b	; ????
  92:	00 00       	nop
  94:	01 05       	cpc	r16, r1
  96:	03 c4       	rjmp	.+2054   	; 0x89e <__data_load_end+0x488>
  98:	00 80       	ld	r0, Z
  9a:	00 0c       	add	r0, r0
  9c:	49 00       	.word	0x0049	; ????
  9e:	00 00       	nop
  a0:	00 00       	nop
  a2:	14 00       	.word	0x0014	; ????
  a4:	00 00       	nop
  a6:	01 05       	cpc	r16, r1
  a8:	03 bd       	out	0x23, r16	; 35
  aa:	00 80       	ld	r0, Z
  ac:	00 0d       	add	r16, r0
  ae:	4f 00       	.word	0x004f	; ????
  b0:	00 00       	nop
  b2:	00 00       	nop
  b4:	14 00       	.word	0x0014	; ????
  b6:	00 00       	nop
  b8:	01 05       	cpc	r16, r1
  ba:	03 b8       	out	0x03, r0	; 3
  bc:	00 80       	ld	r0, Z
  be:	00 0e       	add	r0, r16
  c0:	54 00       	.word	0x0054	; ????
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	14 00       	.word	0x0014	; ????
  c8:	00 00       	nop
  ca:	01 05       	cpc	r16, r1
  cc:	03 bc       	out	0x23, r0	; 35
  ce:	00 80       	ld	r0, Z
  d0:	00 0f       	add	r16, r16
  d2:	59 00       	.word	0x0059	; ????
  d4:	00 00       	nop
  d6:	00 00       	nop
  d8:	14 00       	.word	0x0014	; ????
  da:	00 00       	nop
  dc:	01 05       	cpc	r16, r1
  de:	03 b9       	out	0x03, r16	; 3
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	00 80       	ld	r0, Z
  e2:	00 10       	cpse	r0, r0
  e4:	5e 00       	.word	0x005e	; ????
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	00 00       	nop
  e8:	00 00       	nop
  ea:	14 00       	.word	0x0014	; ????
	uint8_t port = digitalPinToPort(pin);
  ec:	00 00       	nop
  ee:	01 05       	cpc	r16, r1
  f0:	03 bb       	out	0x13, r16	; 19
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	00 80       	ld	r0, Z
  f4:	00 11       	cpse	r16, r0

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	63 00       	.word	0x0063	; ????
  f8:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 00       	nop
  fc:	14 00       	.word	0x0014	; ????
  fe:	00 00       	nop
 100:	01 05       	cpc	r16, r1
 102:	03 ba       	out	0x13, r0	; 19
 104:	00 80       	ld	r0, Z
 106:	00 12       	cpse	r0, r16

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	68 00       	.word	0x0068	; ????
 10a:	00 00       	nop
 10c:	00 00       	nop
 10e:	14 00       	.word	0x0014	; ????
 110:	00 00       	nop
 112:	01 05       	cpc	r16, r1
 114:	03 6f       	ori	r16, 0xF3	; 243

	uint8_t oldSREG = SREG;
 116:	00 80       	ld	r0, Z
	cli();
 118:	00 13       	cpse	r16, r16

	if (val == LOW) {
		*out &= ~bit;
 11a:	6f 00       	.word	0x006f	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 00       	nop
 11e:	00 00       	nop
		*out &= ~bit;
 120:	14 00       	.word	0x0014	; ????
 122:	00 00       	nop
	} else {
		*out |= bit;
 124:	01 05       	cpc	r16, r1
	}

	SREG = oldSREG;
 126:	03 36       	cpi	r16, 0x63	; 99
}
 128:	00 80       	ld	r0, Z
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	00 14       	cp	r0, r0
 12c:	75 00       	.word	0x0075	; ????
 12e:	00 00       	nop
 130:	00 00       	nop
 132:	14 00       	.word	0x0014	; ????
 134:	00 00       	nop
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	01 05       	cpc	r16, r1
 138:	03 80       	ldd	r0, Z+3	; 0x03
 13a:	00 80       	ld	r0, Z
 13c:	00 15       	cp	r16, r0
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	7c 00       	.word	0x007c	; ????
 140:	00 00       	nop
 142:	00 00       	nop
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	14 00       	.word	0x0014	; ????
 146:	00 00       	nop
 148:	01 05       	cpc	r16, r1
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	03 81       	ldd	r16, Z+3	; 0x03
 14c:	00 80       	ld	r0, Z
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	00 16       	cp	r0, r16
 150:	83 00       	.word	0x0083	; ????
 152:	00 00       	nop
 154:	00 00       	nop
 156:	14 00       	.word	0x0014	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	00 00       	nop
 15a:	01 05       	cpc	r16, r1
 15c:	03 82       	std	Z+3, r0	; 0x03
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	00 80       	ld	r0, Z
 160:	00 17       	cp	r16, r16
 162:	8a 00       	.word	0x008a	; ????
 164:	00 00       	nop
 166:	00 00       	nop
 168:	1b 00       	.word	0x001b	; ????
 16a:	00 00       	nop
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	01 05       	cpc	r16, r1
 16e:	03 84       	ldd	r0, Z+11	; 0x0b
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 80       	ld	r0, Z
 172:	00 18       	sub	r0, r0
 174:	90 00       	.word	0x0090	; ????
 176:	00 00       	nop
 178:	00 00       	nop
 17a:	1b 00       	.word	0x001b	; ????
 17c:	00 00       	nop
 17e:	01 05       	cpc	r16, r1
 180:	03 88       	ldd	r0, Z+19	; 0x13
 182:	00 80       	ld	r0, Z
 184:	00 19       	sub	r16, r0
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	96 00       	.word	0x0096	; ????
 188:	00 00       	nop
 18a:	00 00       	nop
 18c:	1b 00       	.word	0x001b	; ????
 18e:	00 00       	nop
 190:	01 05       	cpc	r16, r1
 192:	03 8a       	std	Z+19, r0	; 0x13
 194:	00 80       	ld	r0, Z
	unsigned char f = timer0_fract;
 196:	00 1a       	sub	r0, r16
 198:	9c 00       	.word	0x009c	; ????

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	00 00       	nop
 19c:	00 00       	nop
	if (f >= FRACT_MAX) {
 19e:	1b 00       	.word	0x001b	; ????
 1a0:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	01 05       	cpc	r16, r1
 1a4:	03 86       	std	Z+11, r0	; 0x0b
 1a6:	00 80       	ld	r0, Z
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	00 1b       	sub	r16, r16
 1aa:	a1 00       	.word	0x00a1	; ????
	timer0_millis = m;
 1ac:	00 00       	nop
 1ae:	00 00       	nop
 1b0:	14 00       	.word	0x0014	; ????
 1b2:	00 00       	nop
 1b4:	01 05       	cpc	r16, r1
 1b6:	03 43       	sbci	r16, 0x33	; 51
 1b8:	00 80       	ld	r0, Z
 1ba:	00 1c       	adc	r0, r0
	timer0_overflow_count++;
 1bc:	a7 00       	.word	0x00a7	; ????
 1be:	00 00       	nop
 1c0:	00 00       	nop
 1c2:	14 00       	.word	0x0014	; ????
 1c4:	00 00       	nop
 1c6:	01 05       	cpc	r16, r1
 1c8:	03 70       	andi	r16, 0x03	; 3
 1ca:	00 80       	ld	r0, Z
 1cc:	00 1d       	adc	r16, r0
 1ce:	ae 00       	.word	0x00ae	; ????
 1d0:	00 00       	nop
 1d2:	00 00       	nop
 1d4:	14 00       	.word	0x0014	; ????
 1d6:	00 00       	nop
 1d8:	01 05       	cpc	r16, r1
 1da:	03 37       	cpi	r16, 0x73	; 115
 1dc:	00 80       	ld	r0, Z
 1de:	00 1e       	adc	r0, r16
 1e0:	b4 00       	.word	0x00b4	; ????
}
 1e2:	00 00       	nop
 1e4:	00 00       	nop
 1e6:	14 00       	.word	0x0014	; ????
 1e8:	00 00       	nop
 1ea:	01 05       	cpc	r16, r1
 1ec:	03 b0       	in	r0, 0x03	; 3
 1ee:	00 80       	ld	r0, Z
 1f0:	00 1f       	adc	r16, r16
 1f2:	bb 00       	.word	0x00bb	; ????
 1f4:	00 00       	nop
 1f6:	00 00       	nop
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	14 00       	.word	0x0014	; ????
 1fa:	00 00       	nop
		m += 1;
 1fc:	01 05       	cpc	r16, r1
 1fe:	03 b1       	in	r16, 0x03	; 3
 200:	00 80       	ld	r0, Z
 202:	00 20       	and	r0, r0

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	c2 00       	.word	0x00c2	; ????
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	00 00       	nop
 208:	00 00       	nop
 20a:	14 00       	.word	0x0014	; ????
	sbi(TCCR0A, WGM00);
 20c:	00 00       	nop
 20e:	01 05       	cpc	r16, r1
 210:	03 b2       	in	r0, 0x13	; 19
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	00 80       	ld	r0, Z
 214:	00 21       	and	r16, r0
 216:	c8 00       	.word	0x00c8	; ????
	sbi(TCCR0B, CS00);
 218:	00 00       	nop
 21a:	00 00       	nop
 21c:	14 00       	.word	0x0014	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 00       	nop
 220:	01 05       	cpc	r16, r1
 222:	03 b4       	in	r0, 0x23	; 35
 224:	00 80       	ld	r0, Z
 226:	00 22       	and	r0, r16
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	ce 00       	.word	0x00ce	; ????
 22a:	00 00       	nop

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	00 00       	nop
 22e:	14 00       	.word	0x0014	; ????
 230:	00 00       	nop
 232:	01 05       	cpc	r16, r1
 234:	03 b3       	in	r16, 0x13	; 19
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 80       	ld	r0, Z
 238:	00 23       	and	r16, r16
 23a:	d4 00       	.word	0x00d4	; ????
 23c:	00 00       	nop
 23e:	00 00       	nop
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	14 00       	.word	0x0014	; ????
 242:	00 00       	nop
 244:	01 05       	cpc	r16, r1
 246:	03 b6       	in	r0, 0x33	; 51
 248:	00 80       	ld	r0, Z

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	00 24       	eor	r0, r0
 24c:	d9 00       	.word	0x00d9	; ????
 24e:	00 00       	nop
 250:	00 00       	nop
 252:	14 00       	.word	0x0014	; ????

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	00 00       	nop
 256:	01 05       	cpc	r16, r1
 258:	03 43       	sbci	r16, 0x33	; 51
 25a:	00 80       	ld	r0, Z
 25c:	00 25       	eor	r16, r0
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	df 00       	.word	0x00df	; ????
 260:	00 00       	nop
 262:	00 00       	nop
 264:	14 00       	.word	0x0014	; ????
 266:	00 00       	nop
		sbi(ADCSRA, ADPS1);
 268:	01 05       	cpc	r16, r1
 26a:	03 7c       	andi	r16, 0xC3	; 195
 26c:	00 80       	ld	r0, Z
 26e:	00 26       	eor	r0, r16
 270:	e5 00       	.word	0x00e5	; ????
		sbi(ADCSRA, ADPS0);
 272:	00 00       	nop
 274:	00 00       	nop
 276:	1b 00       	.word	0x001b	; ????
 278:	00 00       	nop
 27a:	01 05       	cpc	r16, r1
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	03 78       	andi	r16, 0x83	; 131
 27e:	00 80       	ld	r0, Z
 280:	00 27       	eor	r16, r16
 282:	e9 00       	.word	0x00e9	; ????
 284:	00 00       	nop
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	00 00       	nop
 288:	14 00       	.word	0x0014	; ????
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	00 00       	nop
 28c:	01 05       	cpc	r16, r1
 28e:	03 7a       	andi	r16, 0xA3	; 163
	uint8_t port = digitalPinToPort(pin);
 290:	00 80       	ld	r0, Z
 292:	00 28       	or	r0, r0
 294:	f0 00       	.word	0x00f0	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	00 00       	nop
 298:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	14 00       	.word	0x0014	; ????
 29c:	00 00       	nop
 29e:	01 05       	cpc	r16, r1
 2a0:	03 7b       	andi	r16, 0xB3	; 179
 2a2:	00 80       	ld	r0, Z
 2a4:	00 29       	or	r16, r0
 2a6:	f7 00       	.word	0x00f7	; ????
 2a8:	00 00       	nop
	out = portOutputRegister(port);
 2aa:	00 00       	nop
 2ac:	14 00       	.word	0x0014	; ????
 2ae:	00 00       	nop
 2b0:	01 05       	cpc	r16, r1
 2b2:	03 7e       	andi	r16, 0xE3	; 227
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	00 80       	ld	r0, Z
                cli();
 2b6:	00 2a       	or	r0, r16
		*reg |= bit;
 2b8:	fd 00       	.word	0x00fd	; ????
 2ba:	00 00       	nop
 2bc:	00 00       	nop
		SREG = oldSREG;
 2be:	14 00       	.word	0x0014	; ????
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	00 00       	nop
 2c2:	01 05       	cpc	r16, r1
 2c4:	03 50       	subi	r16, 0x03	; 3
 2c6:	00 80       	ld	r0, Z
 2c8:	00 2b       	or	r16, r16
 2ca:	02 01       	movw	r0, r4
 2cc:	00 00       	nop
 2ce:	00 00       	nop
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	14 00       	.word	0x0014	; ????
 2d2:	00 00       	nop
 2d4:	01 05       	cpc	r16, r1
 2d6:	03 7f       	andi	r16, 0xF3	; 243
 2d8:	00 80       	ld	r0, Z
 2da:	00 2c       	mov	r0, r0

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	08 01       	movw	r0, r16
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	00 00       	nop
 2e0:	00 00       	nop
 2e2:	14 00       	.word	0x0014	; ????
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	00 00       	nop
 2e6:	01 05       	cpc	r16, r1
 2e8:	03 25       	eor	r16, r3
 2ea:	00 80       	ld	r0, Z
 2ec:	00 2d       	mov	r16, r0
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	0e 01       	movw	r0, r28
 2f0:	00 00       	nop
 2f2:	00 00       	nop
 2f4:	14 00       	.word	0x0014	; ????
 2f6:	00 00       	nop
 2f8:	01 05       	cpc	r16, r1
 2fa:	03 24       	eor	r0, r3
 2fc:	00 80       	ld	r0, Z
    b = 0xffffffff; 
 2fe:	00 2e       	mov	r0, r16
 300:	13 01       	movw	r2, r6
 302:	00 00       	nop
 304:	00 00       	nop
 306:	14 00       	.word	0x0014	; ????
 308:	00 00       	nop
 30a:	01 05       	cpc	r16, r1
 30c:	03 23       	and	r16, r19
    a |= b;
 30e:	00 80       	ld	r0, Z
 310:	00 2f       	mov	r16, r16
 312:	18 01       	movw	r2, r16
 314:	00 00       	nop
 316:	00 00       	nop
 318:	14 00       	.word	0x0014	; ????
 31a:	00 00       	nop
 31c:	01 05       	cpc	r16, r1
 31e:	03 28       	or	r0, r3
 320:	00 80       	ld	r0, Z
 322:	00 30       	cpi	r16, 0x00	; 0
 324:	1e 01       	movw	r2, r28
 326:	00 00       	nop
 328:	00 00       	nop
 32a:	14 00       	.word	0x0014	; ????
 32c:	00 00       	nop
 32e:	01 05       	cpc	r16, r1
 330:	03 27       	eor	r16, r19
 332:	00 80       	ld	r0, Z
 334:	00 31       	cpi	r16, 0x10	; 16
 336:	23 01       	movw	r4, r6
 338:	00 00       	nop
 33a:	00 00       	nop
 33c:	14 00       	.word	0x0014	; ????
 33e:	00 00       	nop
 340:	01 05       	cpc	r16, r1
 342:	03 26       	eor	r0, r19
 344:	00 80       	ld	r0, Z
    b = 0x00000000;
 346:	00 32       	cpi	r16, 0x20	; 32
 348:	28 01       	movw	r4, r16
 34a:	00 00       	nop
 34c:	00 00       	nop
 34e:	14 00       	.word	0x0014	; ????
 350:	00 00       	nop
 352:	01 05       	cpc	r16, r1
 354:	03 2b       	or	r16, r19
    if(x){
 356:	00 80       	ld	r0, Z
 358:	00 33       	cpi	r16, 0x30	; 48
 35a:	2e 01       	movw	r4, r28
 35c:	00 00       	nop
 35e:	00 00       	nop
 360:	14 00       	.word	0x0014	; ????
 362:	00 00       	nop
 364:	01 05       	cpc	r16, r1
 366:	03 2a       	or	r0, r19
 368:	00 80       	ld	r0, Z
 36a:	00 34       	cpi	r16, 0x40	; 64
 36c:	33 01       	movw	r6, r6
      //a &= b;
      b = 0xffffffff; 
 36e:	00 00       	nop
 370:	00 00       	nop
 372:	14 00       	.word	0x0014	; ????
 374:	00 00       	nop
 376:	01 05       	cpc	r16, r1
 378:	03 29       	or	r16, r3
 37a:	00 80       	ld	r0, Z
 37c:	00 35       	cpi	r16, 0x50	; 80
      //a = a^b;
    }
    a &= b;
 37e:	38 01       	movw	r6, r16
 380:	00 00       	nop
 382:	00 00       	nop
 384:	14 00       	.word	0x0014	; ????
 386:	00 00       	nop
 388:	01 05       	cpc	r16, r1
 38a:	03 48       	sbci	r16, 0x83	; 131
 38c:	00 80       	ld	r0, Z
 38e:	00 36       	cpi	r16, 0x60	; 96
 390:	3e 01       	movw	r6, r28
 392:	00 00       	nop
 394:	00 00       	nop
 396:	14 00       	.word	0x0014	; ????
 398:	00 00       	nop
 39a:	01 05       	cpc	r16, r1
 39c:	03 47       	sbci	r16, 0x73	; 115
 39e:	00 80       	ld	r0, Z
 3a0:	00 37       	cpi	r16, 0x70	; 112
 3a2:	44 01       	movw	r8, r8
 3a4:	00 00       	nop
 3a6:	00 00       	nop
 3a8:	14 00       	.word	0x0014	; ????
 3aa:	00 00       	nop
 3ac:	01 05       	cpc	r16, r1
 3ae:	03 46       	sbci	r16, 0x63	; 99
 3b0:	00 80       	ld	r0, Z
 3b2:	00 38       	cpi	r16, 0x80	; 128
 3b4:	4a 01       	movw	r8, r20
    b = 0xffffffff; 
 3b6:	00 00       	nop
 3b8:	00 00       	nop
 3ba:	14 00       	.word	0x0014	; ????
 3bc:	00 00       	nop
 3be:	01 05       	cpc	r16, r1
 3c0:	03 45       	sbci	r16, 0x53	; 83
 3c2:	00 80       	ld	r0, Z
 3c4:	00 39       	cpi	r16, 0x90	; 144
    a = a^b;
 3c6:	51 01       	movw	r10, r2
 3c8:	00 00       	nop
 3ca:	00 00       	nop
 3cc:	14 00       	.word	0x0014	; ????
 3ce:	00 00       	nop
 3d0:	01 05       	cpc	r16, r1
 3d2:	03 44       	sbci	r16, 0x43	; 67
 3d4:	00 80       	ld	r0, Z
 3d6:	00 3a       	cpi	r16, 0xA0	; 160
 3d8:	58 01       	movw	r10, r16
 3da:	00 00       	nop
 3dc:	00 00       	nop
 3de:	14 00       	.word	0x0014	; ????
 3e0:	00 00       	nop
 3e2:	01 05       	cpc	r16, r1
 3e4:	03 6e       	ori	r16, 0xE3	; 227
 3e6:	00 80       	ld	r0, Z
 3e8:	00 3b       	cpi	r16, 0xB0	; 176
 3ea:	5f 01       	movw	r10, r30
 3ec:	00 00       	nop
 3ee:	00 00       	nop
 3f0:	14 00       	.word	0x0014	; ????
 3f2:	00 00       	nop
 3f4:	01 05       	cpc	r16, r1
 3f6:	03 35       	cpi	r16, 0x53	; 83
 3f8:	00 80       	ld	r0, Z
 3fa:	00 3c       	cpi	r16, 0xC0	; 192
 3fc:	65 01       	movw	r12, r10
 3fe:	00 00       	nop
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	00 00       	nop
 402:	14 00       	.word	0x0014	; ????
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	00 00       	nop
 406:	01 05       	cpc	r16, r1
 408:	03 43       	sbci	r16, 0x33	; 51
 40a:	00 80       	ld	r0, Z
 40c:	00 3d       	cpi	r16, 0xD0	; 208
 40e:	6b 01       	movw	r12, r22
 410:	00 00       	nop
 412:	00 00       	nop
 414:	14 00       	.word	0x0014	; ????
 416:	00 00       	nop
 418:	01 05       	cpc	r16, r1
 41a:	03 69       	ori	r16, 0x93	; 147
 41c:	00 80       	ld	r0, Z
 41e:	00 3e       	cpi	r16, 0xE0	; 224
 420:	71 01       	movw	r14, r2
 422:	00 00       	nop
 424:	00 00       	nop
 426:	14 00       	.word	0x0014	; ????
 428:	00 00       	nop
 42a:	01 05       	cpc	r16, r1
 42c:	03 3d       	cpi	r16, 0xD3	; 211
 42e:	00 80       	ld	r0, Z
 430:	00 3f       	cpi	r16, 0xF0	; 240
 432:	77 01       	movw	r14, r14
 434:	00 00       	nop
 436:	00 00       	nop
 438:	14 00       	.word	0x0014	; ????
 43a:	00 00       	nop
 43c:	01 05       	cpc	r16, r1
 43e:	03 3c       	cpi	r16, 0xC3	; 195
 440:	00 80       	ld	r0, Z
 442:	00 40       	sbci	r16, 0x00	; 0
 444:	7c 01       	movw	r14, r24
 446:	00 00       	nop
 448:	00 00       	nop
 44a:	14 00       	.word	0x0014	; ????
 44c:	00 00       	nop
 44e:	01 05       	cpc	r16, r1
 450:	03 68       	ori	r16, 0x83	; 131
 452:	00 80       	ld	r0, Z
 454:	00 41       	sbci	r16, 0x10	; 16
 456:	82 01       	movw	r16, r4
 458:	00 00       	nop
 45a:	00 00       	nop
 45c:	14 00       	.word	0x0014	; ????
 45e:	00 00       	nop
 460:	01 05       	cpc	r16, r1
 462:	03 6d       	ori	r16, 0xD3	; 211
 464:	00 80       	ld	r0, Z
 466:	00 42       	sbci	r16, 0x20	; 32
 468:	89 01       	movw	r16, r18
 46a:	00 00       	nop
 46c:	00 00       	nop
 46e:	14 00       	.word	0x0014	; ????
 470:	00 00       	nop
 472:	01 05       	cpc	r16, r1
 474:	03 6c       	ori	r16, 0xC3	; 195
 476:	00 80       	ld	r0, Z
 478:	00 43       	sbci	r16, 0x30	; 48
 47a:	90 01       	movw	r18, r0
 47c:	00 00       	nop
 47e:	00 00       	nop
 480:	14 00       	.word	0x0014	; ????
 482:	00 00       	nop
 484:	01 05       	cpc	r16, r1
 486:	03 6b       	ori	r16, 0xB3	; 179
 488:	00 80       	ld	r0, Z
 48a:	00 44       	sbci	r16, 0x40	; 64
 48c:	97 01       	movw	r18, r14
 48e:	00 00       	nop
 490:	00 00       	nop
 492:	14 00       	.word	0x0014	; ????
 494:	00 00       	nop
 496:	01 05       	cpc	r16, r1
 498:	03 3b       	cpi	r16, 0xB3	; 179
 49a:	00 80       	ld	r0, Z
 49c:	00 45       	sbci	r16, 0x50	; 80
 49e:	9d 01       	movw	r18, r26
 4a0:	00 00       	nop
 4a2:	00 00       	nop
 4a4:	14 00       	.word	0x0014	; ????
 4a6:	00 00       	nop
 4a8:	01 05       	cpc	r16, r1
 4aa:	03 4e       	sbci	r16, 0xE3	; 227
 4ac:	00 80       	ld	r0, Z
 4ae:	00 46       	sbci	r16, 0x60	; 96
 4b0:	a2 01       	movw	r20, r4
 4b2:	00 00       	nop
 4b4:	00 00       	nop
 4b6:	14 00       	.word	0x0014	; ????
 4b8:	00 00       	nop
 4ba:	01 05       	cpc	r16, r1
 4bc:	03 4d       	sbci	r16, 0xD3	; 211
 4be:	00 80       	ld	r0, Z
 4c0:	00 47       	sbci	r16, 0x70	; 112
 4c2:	a7 01       	movw	r20, r14
 4c4:	00 00       	nop
 4c6:	00 00       	nop
 4c8:	14 00       	.word	0x0014	; ????
 4ca:	00 00       	nop
 4cc:	01 05       	cpc	r16, r1
 4ce:	03 4c       	sbci	r16, 0xC3	; 195
 4d0:	00 80       	ld	r0, Z
 4d2:	00 48       	sbci	r16, 0x80	; 128
 4d4:	ac 01       	movw	r20, r24
 4d6:	00 00       	nop
 4d8:	00 00       	nop
 4da:	14 00       	.word	0x0014	; ????
 4dc:	00 00       	nop
 4de:	01 05       	cpc	r16, r1
 4e0:	03 60       	ori	r16, 0x03	; 3
 4e2:	00 80       	ld	r0, Z
 4e4:	00 49       	sbci	r16, 0x90	; 144
 4e6:	b3 01       	movw	r22, r6
 4e8:	00 00       	nop
 4ea:	00 00       	nop
 4ec:	14 00       	.word	0x0014	; ????
 4ee:	00 00       	nop
 4f0:	01 05       	cpc	r16, r1
 4f2:	03 64       	ori	r16, 0x43	; 67
 4f4:	00 80       	ld	r0, Z
 4f6:	00 4a       	sbci	r16, 0xA0	; 160
 4f8:	b7 01       	movw	r22, r14
 4fa:	00 00       	nop
 4fc:	00 00       	nop
 4fe:	14 00       	.word	0x0014	; ????
 500:	00 00       	nop
 502:	01 05       	cpc	r16, r1
 504:	03 66       	ori	r16, 0x63	; 99
 506:	00 80       	ld	r0, Z
 508:	00 4b       	sbci	r16, 0xB0	; 176
 50a:	be 01       	movw	r22, r28
 50c:	00 00       	nop
 50e:	00 00       	nop
 510:	14 00       	.word	0x0014	; ????
 512:	00 00       	nop
 514:	01 05       	cpc	r16, r1
 516:	03 61       	ori	r16, 0x13	; 19
 518:	00 80       	ld	r0, Z
 51a:	00 4c       	sbci	r16, 0xC0	; 192
 51c:	c4 01       	movw	r24, r8
 51e:	00 00       	nop
 520:	00 00       	nop
 522:	14 00       	.word	0x0014	; ????
 524:	00 00       	nop
 526:	01 05       	cpc	r16, r1
 528:	03 5f       	subi	r16, 0xF3	; 243
 52a:	00 80       	ld	r0, Z
 52c:	00 4d       	sbci	r16, 0xD0	; 208
 52e:	c9 01       	movw	r24, r18
 530:	00 00       	nop
 532:	00 00       	nop
 534:	1b 00       	.word	0x001b	; ????
 536:	00 00       	nop
 538:	01 05       	cpc	r16, r1
 53a:	03 5d       	subi	r16, 0xD3	; 211
 53c:	00 80       	ld	r0, Z
 53e:	00 4e       	sbci	r16, 0xE0	; 224
 540:	cc 01       	movw	r24, r24
 542:	00 00       	nop
 544:	00 00       	nop
 546:	14 00       	.word	0x0014	; ????
 548:	00 00       	nop
 54a:	01 05       	cpc	r16, r1
 54c:	03 57       	subi	r16, 0x73	; 115
 54e:	00 80       	ld	r0, Z
 550:	00 4f       	sbci	r16, 0xF0	; 240
 552:	d3 01       	movw	r26, r6
 554:	00 00       	nop
 556:	00 00       	nop
 558:	14 00       	.word	0x0014	; ????
 55a:	00 00       	nop
 55c:	01 05       	cpc	r16, r1
 55e:	03 55       	subi	r16, 0x53	; 83
 560:	00 80       	ld	r0, Z
 562:	00 50       	subi	r16, 0x00	; 0
 564:	d9 01       	movw	r26, r18
 566:	00 00       	nop
 568:	00 00       	nop
 56a:	14 00       	.word	0x0014	; ????
 56c:	00 00       	nop
 56e:	01 05       	cpc	r16, r1
 570:	03 54       	subi	r16, 0x43	; 67
 572:	00 80       	ld	r0, Z
 574:	00 51       	subi	r16, 0x10	; 16
 576:	df 01       	movw	r26, r30
 578:	00 00       	nop
 57a:	00 00       	nop
 57c:	14 00       	.word	0x0014	; ????
 57e:	00 00       	nop
 580:	01 05       	cpc	r16, r1
 582:	03 53       	subi	r16, 0x33	; 51
 584:	00 80       	ld	r0, Z
 586:	00 52       	subi	r16, 0x20	; 32
 588:	e4 01       	movw	r28, r8
 58a:	00 00       	nop
 58c:	00 00       	nop
 58e:	14 00       	.word	0x0014	; ????
 590:	00 00       	nop
 592:	01 05       	cpc	r16, r1
 594:	03 4b       	sbci	r16, 0xB3	; 179
 596:	00 80       	ld	r0, Z
 598:	00 53       	subi	r16, 0x30	; 48
 59a:	eb 01       	movw	r28, r22
 59c:	00 00       	nop
 59e:	00 00       	nop
 5a0:	14 00       	.word	0x0014	; ????
 5a2:	00 00       	nop
 5a4:	01 05       	cpc	r16, r1
 5a6:	03 4a       	sbci	r16, 0xA3	; 163
 5a8:	00 80       	ld	r0, Z
 5aa:	00 54       	subi	r16, 0x40	; 64
 5ac:	f2 01       	movw	r30, r4
 5ae:	00 00       	nop
 5b0:	00 00       	nop
 5b2:	14 00       	.word	0x0014	; ????
 5b4:	00 00       	nop
 5b6:	01 05       	cpc	r16, r1
 5b8:	03 3e       	cpi	r16, 0xE3	; 227
 5ba:	00 80       	ld	r0, Z
 5bc:	00 55       	subi	r16, 0x50	; 80
 5be:	f9 01       	movw	r30, r18
 5c0:	00 00       	nop
 5c2:	00 00       	nop
 5c4:	1b 00       	.word	0x001b	; ????
 5c6:	00 00       	nop
 5c8:	01 05       	cpc	r16, r1
 5ca:	03 41       	sbci	r16, 0x13	; 19
 5cc:	00 80       	ld	r0, Z
 5ce:	00 56       	subi	r16, 0x60	; 96
 5d0:	fe 01       	movw	r30, r28
 5d2:	00 00       	nop
 5d4:	00 00       	nop
 5d6:	14 00       	.word	0x0014	; ????
 5d8:	00 00       	nop
 5da:	01 05       	cpc	r16, r1
 5dc:	03 40       	sbci	r16, 0x03	; 3
 5de:	00 80       	ld	r0, Z
 5e0:	00 57       	subi	r16, 0x70	; 112
 5e2:	03 02       	muls	r16, r19
 5e4:	00 00       	nop
 5e6:	00 00       	nop
 5e8:	14 00       	.word	0x0014	; ????
 5ea:	00 00       	nop
 5ec:	01 05       	cpc	r16, r1
 5ee:	03 3f       	cpi	r16, 0xF3	; 243
 5f0:	00 80       	ld	r0, Z
 5f2:	00 00       	nop
 5f4:	46 06       	cpc	r4, r22
 5f6:	00 00       	nop
 5f8:	02 00       	.word	0x0002	; ????
 5fa:	a2 05       	cpc	r26, r2
 5fc:	00 00       	nop
 5fe:	04 01       	movw	r0, r8
 600:	d3 02       	muls	r29, r19
 602:	00 00       	nop
 604:	04 72       	andi	r16, 0x24	; 36
 606:	02 00       	.word	0x0002	; ????
 608:	00 39       	cpi	r16, 0x90	; 144
 60a:	04 00       	.word	0x0004	; ????
 60c:	00 48       	sbci	r16, 0x80	; 128
	...
 616:	00 00       	nop
 618:	00 1a       	sub	r0, r16
 61a:	00 00       	nop
 61c:	00 02       	muls	r16, r16
 61e:	ac 02       	muls	r26, r28
 620:	00 00       	nop
 622:	05 7e       	andi	r16, 0xE5	; 229
 624:	34 00       	.word	0x0034	; ????
 626:	00 00       	nop
 628:	03 01       	movw	r0, r6
 62a:	08 b4       	in	r0, 0x28	; 40
 62c:	02 00       	.word	0x0002	; ????
 62e:	00 02       	muls	r16, r16
 630:	11 04       	cpc	r1, r1
 632:	00 00       	nop
 634:	05 80       	ldd	r0, Z+5	; 0x05
 636:	4b 00       	.word	0x004b	; ????
 638:	00 00       	nop
 63a:	04 3b       	cpi	r16, 0xB4	; 180
 63c:	00 00       	nop
 63e:	00 03       	mulsu	r16, r16
 640:	02 07       	cpc	r16, r18
 642:	d7 03       	fmuls	r21, r23
 644:	00 00       	nop
 646:	05 31       	cpi	r16, 0x15	; 21
 648:	04 00       	.word	0x0004	; ????
 64a:	00 01       	movw	r0, r0
 64c:	1d 01       	movw	r2, r26
 64e:	40 01       	movw	r8, r0
 650:	00 00       	nop
 652:	06 70       	andi	r16, 0x06	; 6
 654:	69 6e       	ori	r22, 0xE9	; 233
 656:	00 01       	movw	r0, r0
 658:	1d 29       	or	r17, r13
 65a:	00 00       	nop
 65c:	00 07       	cpc	r16, r16
 65e:	1a 02       	muls	r17, r26
 660:	00 00       	nop
 662:	01 1d       	adc	r16, r1
 664:	29 00       	.word	0x0029	; ????
 666:	00 00       	nop
 668:	08 62       	ori	r16, 0x28	; 40
 66a:	69 74       	andi	r22, 0x49	; 73
 66c:	00 01       	movw	r0, r0
 66e:	1f 29       	or	r17, r15
 670:	00 00       	nop
 672:	00 09       	sbc	r16, r0
 674:	88 02       	muls	r24, r24
 676:	00 00       	nop
 678:	01 20       	and	r0, r1
 67a:	29 00       	.word	0x0029	; ????
 67c:	00 00       	nop
 67e:	08 72       	andi	r16, 0x28	; 40
 680:	65 67       	ori	r22, 0x75	; 117
 682:	00 01       	movw	r0, r0
 684:	21 40       	sbci	r18, 0x01	; 1
 686:	01 00       	.word	0x0001	; ????
 688:	00 08       	sbc	r0, r0
 68a:	6f 75       	andi	r22, 0x5F	; 95
 68c:	74 00       	.word	0x0074	; ????
 68e:	01 21       	and	r16, r1
 690:	40 01       	movw	r8, r0
 692:	00 00       	nop
 694:	0a b1       	in	r16, 0x0a	; 10
 696:	00 00       	nop
 698:	00 09       	sbc	r16, r0
 69a:	be 04       	cpc	r11, r14
 69c:	00 00       	nop
 69e:	01 36       	cpi	r16, 0x61	; 97
 6a0:	29 00       	.word	0x0029	; ????
 6a2:	00 00       	nop
 6a4:	00 0a       	sbc	r0, r16
 6a6:	c2 00       	.word	0x00c2	; ????
 6a8:	00 00       	nop
 6aa:	09 be       	out	0x39, r0	; 57
 6ac:	04 00       	.word	0x0004	; ????
 6ae:	00 01       	movw	r0, r0
 6b0:	30 29       	or	r19, r0
 6b2:	00 00       	nop
 6b4:	00 00       	nop
 6b6:	0a d3       	rcall	.+1556   	; 0xccc <__stack+0x3cd>
 6b8:	00 00       	nop
 6ba:	00 09       	sbc	r16, r0
 6bc:	be 04       	cpc	r11, r14
 6be:	00 00       	nop
 6c0:	01 2a       	or	r0, r17
 6c2:	29 00       	.word	0x0029	; ????
 6c4:	00 00       	nop
 6c6:	00 0a       	sbc	r0, r16
 6c8:	ef 00       	.word	0x00ef	; ????
 6ca:	00 00       	nop
 6cc:	09 7f       	andi	r16, 0xF9	; 249
 6ce:	02 00       	.word	0x0002	; ????
 6d0:	00 01       	movw	r0, r0
 6d2:	27 3b       	cpi	r18, 0xB7	; 183
 6d4:	00 00       	nop
 6d6:	00 09       	sbc	r16, r0
 6d8:	ef 03       	fmulsu	r22, r23
 6da:	00 00       	nop
 6dc:	01 27       	eor	r16, r17
 6de:	3b 00       	.word	0x003b	; ????
 6e0:	00 00       	nop
 6e2:	00 0a       	sbc	r0, r16
 6e4:	0b 01       	movw	r0, r22
 6e6:	00 00       	nop
 6e8:	09 7f       	andi	r16, 0xF9	; 249
 6ea:	02 00       	.word	0x0002	; ????
 6ec:	00 01       	movw	r0, r0
 6ee:	26 3b       	cpi	r18, 0xB6	; 182
 6f0:	00 00       	nop
 6f2:	00 09       	sbc	r16, r0
 6f4:	ef 03       	fmulsu	r22, r23
 6f6:	00 00       	nop
 6f8:	01 26       	eor	r0, r17
 6fa:	3b 00       	.word	0x003b	; ????
 6fc:	00 00       	nop
 6fe:	00 0a       	sbc	r0, r16
 700:	27 01       	movw	r4, r14
 702:	00 00       	nop
 704:	09 7f       	andi	r16, 0xF9	; 249
 706:	02 00       	.word	0x0002	; ????
 708:	00 01       	movw	r0, r0
 70a:	20 3b       	cpi	r18, 0xB0	; 176
 70c:	00 00       	nop
 70e:	00 09       	sbc	r16, r0
 710:	ef 03       	fmulsu	r22, r23
 712:	00 00       	nop
 714:	01 20       	and	r0, r1
 716:	29 00       	.word	0x0029	; ????
 718:	00 00       	nop
 71a:	00 0b       	sbc	r16, r16
 71c:	09 7f       	andi	r16, 0xF9	; 249
 71e:	02 00       	.word	0x0002	; ????
 720:	00 01       	movw	r0, r0
 722:	1f 3b       	cpi	r17, 0xBF	; 191
 724:	00 00       	nop
 726:	00 09       	sbc	r16, r0
 728:	ef 03       	fmulsu	r22, r23
 72a:	00 00       	nop
 72c:	01 1f       	adc	r16, r17
 72e:	29 00       	.word	0x0029	; ????
 730:	00 00       	nop
 732:	00 00       	nop
 734:	0c 02       	muls	r16, r28
 736:	4d 01       	movw	r8, r26
 738:	00 00       	nop
 73a:	03 01       	movw	r0, r6
 73c:	08 ac       	ldd	r0, Y+56	; 0x38
 73e:	02 00       	.word	0x0002	; ????
 740:	00 0d       	add	r16, r0
 742:	46 01       	movw	r8, r12
 744:	00 00       	nop
 746:	05 08       	sbc	r0, r5
 748:	02 00       	.word	0x0002	; ????
 74a:	00 01       	movw	r0, r0
 74c:	8a 01       	movw	r16, r20
 74e:	18 02       	muls	r17, r24
 750:	00 00       	nop
 752:	06 70       	andi	r16, 0x06	; 6
 754:	69 6e       	ori	r22, 0xE9	; 233
 756:	00 01       	movw	r0, r0
 758:	8a 29       	or	r24, r10
 75a:	00 00       	nop
 75c:	00 06       	cpc	r0, r16
 75e:	76 61       	ori	r23, 0x16	; 22
 760:	6c 00       	.word	0x006c	; ????
 762:	01 8a       	std	Z+17, r0	; 0x11
 764:	29 00       	.word	0x0029	; ????
 766:	00 00       	nop
 768:	09 2b       	or	r16, r25
 76a:	04 00       	.word	0x0004	; ????
 76c:	00 01       	movw	r0, r0
 76e:	8c 29       	or	r24, r12
 770:	00 00       	nop
 772:	00 08       	sbc	r0, r0
 774:	62 69       	ori	r22, 0x92	; 146
 776:	74 00       	.word	0x0074	; ????
 778:	01 8d       	ldd	r16, Z+25	; 0x19
 77a:	29 00       	.word	0x0029	; ????
 77c:	00 00       	nop
 77e:	09 88       	ldd	r0, Y+17	; 0x11
 780:	02 00       	.word	0x0002	; ????
 782:	00 01       	movw	r0, r0
 784:	8e 29       	or	r24, r14
 786:	00 00       	nop
 788:	00 08       	sbc	r0, r0
 78a:	6f 75       	andi	r22, 0x5F	; 95
 78c:	74 00       	.word	0x0074	; ????
 78e:	01 8f       	std	Z+25, r16	; 0x19
 790:	40 01       	movw	r8, r0
 792:	00 00       	nop
 794:	09 be       	out	0x39, r0	; 57
 796:	04 00       	.word	0x0004	; ????
 798:	00 01       	movw	r0, r0
 79a:	99 29       	or	r25, r9
 79c:	00 00       	nop
 79e:	00 0a       	sbc	r0, r16
 7a0:	c7 01       	movw	r24, r14
 7a2:	00 00       	nop
 7a4:	09 7f       	andi	r16, 0xF9	; 249
 7a6:	02 00       	.word	0x0002	; ????
 7a8:	00 01       	movw	r0, r0
 7aa:	97 3b       	cpi	r25, 0xB7	; 183
 7ac:	00 00       	nop
 7ae:	00 09       	sbc	r16, r0
 7b0:	ef 03       	fmulsu	r22, r23
 7b2:	00 00       	nop
 7b4:	01 97       	sbiw	r24, 0x01	; 1
 7b6:	3b 00       	.word	0x003b	; ????
 7b8:	00 00       	nop
 7ba:	00 0a       	sbc	r0, r16
 7bc:	e3 01       	movw	r28, r6
 7be:	00 00       	nop
 7c0:	09 7f       	andi	r16, 0xF9	; 249
 7c2:	02 00       	.word	0x0002	; ????
 7c4:	00 01       	movw	r0, r0
 7c6:	8e 3b       	cpi	r24, 0xBE	; 190
 7c8:	00 00       	nop
 7ca:	00 09       	sbc	r16, r0
 7cc:	ef 03       	fmulsu	r22, r23
 7ce:	00 00       	nop
 7d0:	01 8e       	std	Z+25, r0	; 0x19
 7d2:	29 00       	.word	0x0029	; ????
 7d4:	00 00       	nop
 7d6:	00 0a       	sbc	r0, r16
 7d8:	ff 01       	movw	r30, r30
 7da:	00 00       	nop
 7dc:	09 7f       	andi	r16, 0xF9	; 249
 7de:	02 00       	.word	0x0002	; ????
 7e0:	00 01       	movw	r0, r0
 7e2:	8d 3b       	cpi	r24, 0xBD	; 189
 7e4:	00 00       	nop
 7e6:	00 09       	sbc	r16, r0
 7e8:	ef 03       	fmulsu	r22, r23
 7ea:	00 00       	nop
 7ec:	01 8d       	ldd	r16, Z+25	; 0x19
 7ee:	29 00       	.word	0x0029	; ????
 7f0:	00 00       	nop
 7f2:	00 0b       	sbc	r16, r16
 7f4:	09 7f       	andi	r16, 0xF9	; 249
 7f6:	02 00       	.word	0x0002	; ????
 7f8:	00 01       	movw	r0, r0
 7fa:	8c 3b       	cpi	r24, 0xBC	; 188
 7fc:	00 00       	nop
 7fe:	00 09       	sbc	r16, r0
 800:	ef 03       	fmulsu	r22, r23
 802:	00 00       	nop
 804:	01 8c       	ldd	r0, Z+25	; 0x19
 806:	29 00       	.word	0x0029	; ????
 808:	00 00       	nop
 80a:	00 00       	nop
 80c:	05 e4       	ldi	r16, 0x45	; 69
 80e:	03 00       	.word	0x0003	; ????
 810:	00 01       	movw	r0, r0
 812:	4b 01       	movw	r8, r22
 814:	30 02       	muls	r19, r16
 816:	00 00       	nop
 818:	07 2b       	or	r16, r23
 81a:	04 00       	.word	0x0004	; ????
 81c:	00 01       	movw	r0, r0
 81e:	4b 29       	or	r20, r11
 820:	00 00       	nop
 822:	00 00       	nop
 824:	0e 8d       	ldd	r16, Y+30	; 0x1e
 826:	02 00       	.word	0x0002	; ????
 828:	00 01       	movw	r0, r0
 82a:	01 47       	sbci	r16, 0x71	; 113
 82c:	02 00       	.word	0x0002	; ????
 82e:	00 09       	sbc	r16, r0
 830:	2b 04       	cpc	r2, r11
 832:	00 00       	nop
 834:	01 4b       	sbci	r16, 0xB1	; 177
 836:	29 00       	.word	0x0029	; ????
 838:	00 00       	nop
 83a:	00 0f       	add	r16, r16
 83c:	52 01       	movw	r10, r4
 83e:	00 00       	nop
 840:	e0 00       	.word	0x00e0	; ????
 842:	00 00       	nop
 844:	70 01       	movw	r14, r0
 846:	00 00       	nop
 848:	03 92       	.word	0x9203	; ????
 84a:	20 02       	muls	r18, r16
 84c:	01 50       	subi	r16, 0x01	; 1
 84e:	03 00       	.word	0x0003	; ????
 850:	00 10       	cpse	r0, r0
 852:	69 01       	movw	r12, r18
 854:	00 00       	nop
 856:	01 68       	ori	r16, 0x81	; 129
 858:	11 74       	andi	r17, 0x41	; 65
 85a:	01 00       	.word	0x0001	; ????
 85c:	00 00       	nop
 85e:	00 00       	nop
 860:	00 11       	cpse	r16, r0
 862:	7f 01       	movw	r14, r30
 864:	00 00       	nop
 866:	55 00       	.word	0x0055	; ????
 868:	00 00       	nop
 86a:	11 8a       	std	Z+17, r1	; 0x11
 86c:	01 00       	.word	0x0001	; ????
 86e:	00 81       	ld	r16, Z
 870:	00 00       	nop
 872:	00 11       	cpse	r16, r0
 874:	95 01       	movw	r18, r10
 876:	00 00       	nop
 878:	9f 00       	.word	0x009f	; ????
 87a:	00 00       	nop
 87c:	11 a0       	ldd	r1, Z+33	; 0x21
 87e:	01 00       	.word	0x0001	; ????
 880:	00 c7       	rjmp	.+3584   	; 0x1682 <__stack+0xd83>
 882:	00 00       	nop
 884:	00 12       	cpse	r0, r16
 886:	5e 01       	movw	r10, r28
 888:	00 00       	nop
 88a:	0d 13       	cpse	r16, r29
 88c:	ff 01       	movw	r30, r30
 88e:	00 00       	nop
 890:	e0 00       	.word	0x00e0	; ????
 892:	00 00       	nop
 894:	e6 00       	.word	0x00e6	; ????
 896:	00 00       	nop
 898:	bb 02       	muls	r27, r27
 89a:	00 00       	nop
 89c:	11 00       	.word	0x0011	; ????
 89e:	02 00       	.word	0x0002	; ????
 8a0:	00 e5       	ldi	r16, 0x50	; 80
 8a2:	00 00       	nop
 8a4:	00 11       	cpse	r16, r0
 8a6:	0b 02       	muls	r16, r27
 8a8:	00 00       	nop
 8aa:	00 00       	nop
 8ac:	00 00       	nop
 8ae:	00 13       	cpse	r16, r16
 8b0:	e3 01       	movw	r28, r6
 8b2:	00 00       	nop
 8b4:	e6 00       	.word	0x00e6	; ????
 8b6:	00 00       	nop
 8b8:	ec 00       	.word	0x00ec	; ????
 8ba:	00 00       	nop
 8bc:	df 02       	muls	r29, r31
 8be:	00 00       	nop
 8c0:	11 e8       	ldi	r17, 0x81	; 129
 8c2:	01 00       	.word	0x0001	; ????
 8c4:	00 fd       	sbrc	r16, 0
 8c6:	00 00       	nop
 8c8:	00 11       	cpse	r16, r0
 8ca:	f3 01       	movw	r30, r6
 8cc:	00 00       	nop
 8ce:	55 00       	.word	0x0055	; ????
 8d0:	00 00       	nop
 8d2:	00 13       	cpse	r16, r16
 8d4:	c7 01       	movw	r24, r14
 8d6:	00 00       	nop
 8d8:	ec 00       	.word	0x00ec	; ????
 8da:	00 00       	nop
 8dc:	f2 00       	.word	0x00f2	; ????
 8de:	00 00       	nop
 8e0:	03 03       	mulsu	r16, r19
 8e2:	00 00       	nop
 8e4:	11 cc       	rjmp	.-2014   	; 0x108 <digitalWrite.constprop.0+0x28>
 8e6:	01 00       	.word	0x0001	; ????
 8e8:	00 15       	cp	r16, r0
 8ea:	01 00       	.word	0x0001	; ????
 8ec:	00 11       	cpse	r16, r0
 8ee:	d7 01       	movw	r26, r14
 8f0:	00 00       	nop
 8f2:	81 00       	.word	0x0081	; ????
 8f4:	00 00       	nop
 8f6:	00 14       	cp	r0, r0
 8f8:	18 02       	muls	r17, r24
 8fa:	00 00       	nop
 8fc:	fa 00       	.word	0x00fa	; ????
 8fe:	00 00       	nop
 900:	00 00       	nop
 902:	00 00       	nop
 904:	01 95       	neg	r16
 906:	2f 03       	fmul	r18, r23
 908:	00 00       	nop
 90a:	15 24       	eor	r1, r5
 90c:	02 00       	.word	0x0002	; ????
 90e:	00 2d       	mov	r16, r0
 910:	01 00       	.word	0x0001	; ????
 912:	00 16       	cp	r0, r16
 914:	4a 01       	movw	r8, r20
 916:	00 00       	nop
 918:	4e 01       	movw	r8, r28
 91a:	00 00       	nop
 91c:	17 3b       	cpi	r17, 0xB7	; 183
 91e:	02 00       	.word	0x0002	; ????
 920:	00 00       	nop
 922:	00 18       	sub	r0, r0
 924:	ab 01       	movw	r20, r22
 926:	00 00       	nop
 928:	08 01       	movw	r0, r16
 92a:	00 00       	nop
 92c:	16 01       	movw	r2, r12
 92e:	00 00       	nop
 930:	11 b0       	in	r1, 0x01	; 1
 932:	01 00       	.word	0x0001	; ????
 934:	00 82       	st	Z, r0
 936:	01 00       	.word	0x0001	; ????
 938:	00 11       	cpse	r16, r0
 93a:	bb 01       	movw	r22, r22
 93c:	00 00       	nop
 93e:	9f 00       	.word	0x009f	; ????
 940:	00 00       	nop
 942:	00 00       	nop
 944:	19 01       	movw	r2, r18
 946:	c7 02       	muls	r28, r23
 948:	00 00       	nop
 94a:	02 2d       	mov	r16, r2
 94c:	70 01       	movw	r14, r0
 94e:	00 00       	nop
 950:	04 02       	muls	r16, r20
 952:	00 00       	nop
 954:	9a 01       	movw	r18, r20
 956:	00 00       	nop
 958:	01 84       	ldd	r0, Z+9	; 0x09
 95a:	03 00       	.word	0x0003	; ????
 95c:	00 1a       	sub	r0, r16
 95e:	6d 00       	.word	0x006d	; ????
 960:	02 32       	cpi	r16, 0x22	; 34
 962:	84 03       	fmuls	r16, r20
 964:	00 00       	nop
 966:	17 02       	muls	r17, r23
 968:	00 00       	nop
 96a:	1a 66       	ori	r17, 0x6A	; 106
 96c:	00 02       	muls	r16, r16
 96e:	33 34       	cpi	r19, 0x43	; 67
 970:	00 00       	nop
 972:	00 8a       	std	Z+16, r0	; 0x10
 974:	02 00       	.word	0x0002	; ????
 976:	00 00       	nop
 978:	03 04       	cpc	r0, r3
 97a:	07 d2       	rcall	.+1038   	; 0xd8a <__stack+0x48b>
 97c:	03 00       	.word	0x0003	; ????
 97e:	00 1b       	sub	r16, r16
 980:	37 02       	muls	r19, r23
 982:	00 00       	nop
 984:	04 04       	cpc	r0, r4
 986:	01 1b       	sub	r16, r17
 988:	3d 02       	muls	r19, r29
 98a:	00 00       	nop
 98c:	03 1c       	adc	r0, r3
 98e:	01 1b       	sub	r16, r17
 990:	15 02       	muls	r17, r21
 992:	00 00       	nop
 994:	02 f1       	brmi	.+64     	; 0x9d6 <__stack+0xd7>
 996:	01 05       	cpc	r16, r1
 998:	b9 04       	cpc	r11, r9
 99a:	00 00       	nop
 99c:	04 0c       	add	r0, r4
 99e:	01 bc       	out	0x21, r0	; 33
 9a0:	03 00       	.word	0x0003	; ????
 9a2:	00 0b       	sbc	r16, r16
 9a4:	08 69       	ori	r16, 0x98	; 152
 9a6:	69 00       	.word	0x0069	; ????
 9a8:	04 14       	cp	r0, r4
 9aa:	4b 00       	.word	0x004b	; ????
 9ac:	00 00       	nop
 9ae:	00 00       	nop
 9b0:	1c 01       	movw	r2, r24
 9b2:	c2 02       	muls	r28, r18
 9b4:	00 00       	nop
 9b6:	03 21       	and	r16, r3
 9b8:	3f 05       	cpc	r19, r15
 9ba:	00 00       	nop
 9bc:	01 04       	cpc	r0, r1
 9be:	02 00       	.word	0x0002	; ????
 9c0:	00 12       	cpse	r0, r16
 9c2:	04 00       	.word	0x0004	; ????
 9c4:	00 03       	mulsu	r16, r16
 9c6:	92 20       	and	r9, r2
 9c8:	02 01       	movw	r0, r4
 9ca:	3f 05       	cpc	r19, r15
 9cc:	00 00       	nop
 9ce:	1d 9b       	sbis	0x03, 5	; 3
 9d0:	03 00       	.word	0x0003	; ????
 9d2:	00 04       	cpc	r0, r0
 9d4:	02 00       	.word	0x0002	; ????
 9d6:	00 8a       	std	Z+16, r0	; 0x10
 9d8:	02 00       	.word	0x0002	; ????
 9da:	00 03       	mulsu	r16, r16
 9dc:	23 1e       	adc	r2, r19
 9de:	8b 03       	fmulsu	r16, r19
 9e0:	00 00       	nop
 9e2:	8a 02       	muls	r24, r26
 9e4:	00 00       	nop
 9e6:	d0 02       	muls	r29, r16
 9e8:	00 00       	nop
 9ea:	03 2b       	or	r16, r19
 9ec:	ec 04       	cpc	r14, r12
 9ee:	00 00       	nop
 9f0:	1f 52       	subi	r17, 0x2F	; 47
 9f2:	00 00       	nop
 9f4:	00 8a       	std	Z+16, r0	; 0x10
 9f6:	02 00       	.word	0x0002	; ????
 9f8:	00 c0       	rjmp	.+0      	; 0x9fa <__stack+0xfb>
 9fa:	02 00       	.word	0x0002	; ????
 9fc:	00 04       	cpc	r0, r0
 9fe:	08 15       	cp	r16, r8
 a00:	5e 00       	.word	0x005e	; ????
 a02:	00 00       	nop
 a04:	da 02       	muls	r29, r26
 a06:	00 00       	nop
 a08:	15 69       	ori	r17, 0x95	; 149
 a0a:	00 00       	nop
 a0c:	00 ee       	ldi	r16, 0xE0	; 224
 a0e:	02 00       	.word	0x0002	; ????
 a10:	00 16       	cp	r0, r16
 a12:	8a 02       	muls	r24, r26
 a14:	00 00       	nop
 a16:	c0 02       	muls	r28, r16
 a18:	00 00       	nop
 a1a:	11 74       	andi	r17, 0x41	; 65
 a1c:	00 00       	nop
 a1e:	00 02       	muls	r16, r16
 a20:	03 00       	.word	0x0003	; ????
 a22:	00 11       	cpse	r16, r0
 a24:	7f 00       	.word	0x007f	; ????
 a26:	00 00       	nop
 a28:	15 03       	mulsu	r17, r21
 a2a:	00 00       	nop
 a2c:	11 8a       	std	Z+17, r1	; 0x11
 a2e:	00 00       	nop
 a30:	00 28       	or	r0, r0
 a32:	03 00       	.word	0x0003	; ????
 a34:	00 17       	cp	r16, r16
 a36:	95 00       	.word	0x0095	; ????
 a38:	00 00       	nop
 a3a:	13 27       	eor	r17, r19
 a3c:	01 00       	.word	0x0001	; ????
 a3e:	00 8a       	std	Z+16, r0	; 0x10
 a40:	02 00       	.word	0x0002	; ????
 a42:	00 90 02 00 	lds	r0, 0x0002	; 0x800002 <__TEXT_REGION_LENGTH__+0x7e0002>
 a46:	00 6a       	ori	r16, 0xA0	; 160
 a48:	04 00       	.word	0x0004	; ????
 a4a:	00 11       	cpse	r16, r0
 a4c:	28 01       	movw	r4, r16
 a4e:	00 00       	nop
 a50:	40 03       	mulsu	r20, r16
 a52:	00 00       	nop
 a54:	11 33       	cpi	r17, 0x31	; 49
 a56:	01 00       	.word	0x0001	; ????
 a58:	00 58       	subi	r16, 0x80	; 128
 a5a:	03 00       	.word	0x0003	; ????
 a5c:	00 00       	nop
 a5e:	13 0b       	sbc	r17, r19
 a60:	01 00       	.word	0x0001	; ????
 a62:	00 90 02 00 	lds	r0, 0x0002	; 0x800002 <__TEXT_REGION_LENGTH__+0x7e0002>
 a66:	00 96       	adiw	r24, 0x00	; 0
 a68:	02 00       	.word	0x0002	; ????
 a6a:	00 8e       	std	Z+24, r0	; 0x18
 a6c:	04 00       	.word	0x0004	; ????
 a6e:	00 11       	cpse	r16, r0
 a70:	10 01       	movw	r2, r0
 a72:	00 00       	nop
 a74:	6b 03       	fmul	r22, r19
 a76:	00 00       	nop
 a78:	11 1b       	sub	r17, r17
 a7a:	01 00       	.word	0x0001	; ????
 a7c:	00 15       	cp	r16, r0
 a7e:	03 00       	.word	0x0003	; ????
 a80:	00 00       	nop
 a82:	13 ef       	ldi	r17, 0xF3	; 243
 a84:	00 00       	nop
 a86:	00 9a       	sbi	0x00, 0	; 0
 a88:	02 00       	.word	0x0002	; ????
 a8a:	00 aa       	std	Z+48, r0	; 0x30
 a8c:	02 00       	.word	0x0002	; ????
 a8e:	00 b2       	in	r0, 0x10	; 16
 a90:	04 00       	.word	0x0004	; ????
 a92:	00 11       	cpse	r16, r0
 a94:	f4 00       	.word	0x00f4	; ????
 a96:	00 00       	nop
 a98:	83 03       	fmuls	r16, r19
 a9a:	00 00       	nop
 a9c:	11 ff       	sbrs	r17, 1
 a9e:	00 00       	nop
 aa0:	00 28       	or	r0, r0
 aa2:	03 00       	.word	0x0003	; ????
 aa4:	00 00       	nop
 aa6:	13 d3       	rcall	.+1574   	; 0x10ce <__stack+0x7cf>
 aa8:	00 00       	nop
 aaa:	00 aa       	std	Z+48, r0	; 0x30
 aac:	02 00       	.word	0x0002	; ????
 aae:	00 b4       	in	r0, 0x20	; 32
 ab0:	02 00       	.word	0x0002	; ????
 ab2:	00 d2       	rcall	.+1024   	; 0xeb4 <__stack+0x5b5>
 ab4:	04 00       	.word	0x0004	; ????
 ab6:	00 11       	cpse	r16, r0
 ab8:	d8 00       	.word	0x00d8	; ????
 aba:	00 00       	nop
 abc:	9b 03       	fmulsu	r17, r19
 abe:	00 00       	nop
 ac0:	17 e3       	ldi	r17, 0x37	; 55
 ac2:	00 00       	nop
 ac4:	00 00       	nop
 ac6:	18 a0       	ldd	r1, Y+32	; 0x20
 ac8:	00 00       	nop
 aca:	00 b4       	in	r0, 0x20	; 32
 acc:	02 00       	.word	0x0002	; ????
 ace:	00 c0       	rjmp	.+0      	; 0xad0 <__stack+0x1d1>
 ad0:	02 00       	.word	0x0002	; ????
 ad2:	00 11       	cpse	r16, r0
 ad4:	a5 00       	.word	0x00a5	; ????
 ad6:	00 00       	nop
 ad8:	b3 03       	fmuls	r19, r19
 ada:	00 00       	nop
 adc:	00 00       	nop
 ade:	00 00       	nop
 ae0:	14 a3       	std	Z+36, r17	; 0x24
 ae2:	03 00       	.word	0x0003	; ????
 ae4:	00 d0       	rcall	.+0      	; 0xae6 <__stack+0x1e7>
 ae6:	02 00       	.word	0x0002	; ????
 ae8:	00 18       	sub	r0, r0
 aea:	00 00       	nop
 aec:	00 03       	mulsu	r16, r16
 aee:	2e 39       	cpi	r18, 0x9E	; 158
 af0:	05 00       	.word	0x0005	; ????
 af2:	00 20       	and	r0, r0
 af4:	af 03       	fmulsu	r18, r23
 af6:	00 00       	nop
 af8:	30 00       	.word	0x0030	; ????
 afa:	00 00       	nop
 afc:	16 05       	cpc	r17, r6
 afe:	00 00       	nop
 b00:	11 b0       	in	r1, 0x01	; 1
 b02:	03 00       	.word	0x0003	; ????
 b04:	00 c6       	rjmp	.+3072   	; 0x1706 <__stack+0xe07>
 b06:	03 00       	.word	0x0003	; ????
 b08:	00 00       	nop
 b0a:	21 e4       	ldi	r18, 0x41	; 65
 b0c:	02 00       	.word	0x0002	; ????
 b0e:	00 47       	sbci	r16, 0x70	; 112
 b10:	02 00       	.word	0x0002	; ????
 b12:	00 29       	or	r16, r0
 b14:	05 00       	.word	0x0005	; ????
 b16:	00 22       	and	r0, r16
 b18:	01 68       	ori	r16, 0x81	; 129
 b1a:	01 30       	cpi	r16, 0x01	; 1
 b1c:	00 23       	and	r16, r16
 b1e:	ea 02       	muls	r30, r26
 b20:	00 00       	nop
 b22:	47 02       	muls	r20, r23
 b24:	00 00       	nop
 b26:	22 01       	movw	r4, r4
 b28:	68 01       	movw	r12, r16
 b2a:	31 00       	.word	0x0031	; ????
 b2c:	00 24       	eor	r0, r0
 b2e:	10 04       	cpc	r1, r0
 b30:	00 00       	nop
 b32:	00 25       	eor	r16, r0
 b34:	02 05       	cpc	r16, r2
 b36:	69 6e       	ori	r22, 0xE9	; 233
 b38:	74 00       	.word	0x0074	; ????
 b3a:	26 46       	sbci	r18, 0x66	; 102
 b3c:	00 00       	nop
 b3e:	00 56       	subi	r16, 0x60	; 96
 b40:	05 00       	.word	0x0005	; ????
 b42:	00 27       	eor	r16, r16
 b44:	4b 00       	.word	0x004b	; ????
 b46:	00 00       	nop
 b48:	04 00       	.word	0x0004	; ????
 b4a:	04 46       	sbci	r16, 0x64	; 100
 b4c:	05 00       	.word	0x0005	; ????
 b4e:	00 28       	or	r0, r0
 b50:	1a 04       	cpc	r1, r10
 b52:	00 00       	nop
 b54:	06 7e       	andi	r16, 0xE6	; 230
 b56:	56 05       	cpc	r21, r6
 b58:	00 00       	nop
 b5a:	05 03       	mulsu	r16, r21
 b5c:	68 00       	.word	0x0068	; ????
 b5e:	00 00       	nop
 b60:	29 78       	andi	r18, 0x89	; 137
 b62:	00 04       	cpc	r0, r0
 b64:	02 82       	std	Z+2, r0	; 0x02
 b66:	05 00       	.word	0x0005	; ????
 b68:	00 05       	cpc	r16, r0
 b6a:	03 00       	.word	0x0003	; ????
 b6c:	01 80       	ldd	r0, Z+1	; 0x01
 b6e:	00 03       	mulsu	r16, r16
 b70:	04 07       	cpc	r16, r20
 b72:	d2 03       	fmuls	r21, r18
 b74:	00 00       	nop
 b76:	0d 7b       	andi	r16, 0xBD	; 189
 b78:	05 00       	.word	0x0005	; ????
 b7a:	00 29       	or	r16, r0
 b7c:	62 00       	.word	0x0062	; ????
 b7e:	04 02       	muls	r16, r20
 b80:	82 05       	cpc	r24, r2
 b82:	00 00       	nop
 b84:	05 03       	mulsu	r16, r21
 b86:	04 01       	movw	r0, r8
 b88:	80 00       	.word	0x0080	; ????
 b8a:	29 61       	ori	r18, 0x19	; 25
 b8c:	00 04       	cpc	r0, r0
 b8e:	02 82       	std	Z+2, r0	; 0x02
 b90:	05 00       	.word	0x0005	; ????
 b92:	00 05       	cpc	r16, r0
 b94:	03 08       	sbc	r0, r3
 b96:	01 80       	ldd	r0, Z+1	; 0x01
 b98:	00 28       	or	r0, r0
 b9a:	49 02       	muls	r20, r25
 b9c:	00 00       	nop
 b9e:	02 26       	eor	r0, r18
 ba0:	bd 05       	cpc	r27, r13
 ba2:	00 00       	nop
 ba4:	05 03       	mulsu	r16, r21
 ba6:	0c 01       	movw	r0, r24
 ba8:	80 00       	.word	0x0080	; ????
 baa:	03 04       	cpc	r0, r3
 bac:	07 d2       	rcall	.+1038   	; 0xfbc <__stack+0x6bd>
 bae:	03 00       	.word	0x0003	; ????
 bb0:	00 0d       	add	r16, r0
 bb2:	b6 05       	cpc	r27, r6
 bb4:	00 00       	nop
 bb6:	28 9f       	mul	r18, r24
 bb8:	02 00       	.word	0x0002	; ????
 bba:	00 02       	muls	r16, r16
 bbc:	28 34       	cpi	r18, 0x48	; 72
 bbe:	00 00       	nop
 bc0:	00 05       	cpc	r16, r0
 bc2:	03 10       	cpse	r0, r3
 bc4:	01 80       	ldd	r0, Z+1	; 0x01
 bc6:	00 28       	or	r0, r0
 bc8:	c4 03       	fmuls	r20, r20
 bca:	00 00       	nop
 bcc:	02 27       	eor	r16, r18
 bce:	bd 05       	cpc	r27, r13
 bd0:	00 00       	nop
 bd2:	05 03       	mulsu	r16, r21
 bd4:	11 01       	movw	r2, r2
 bd6:	80 00       	.word	0x0080	; ????
 bd8:	28 5f       	subi	r18, 0xF8	; 248
 bda:	02 00       	.word	0x0002	; ????
 bdc:	00 06       	cpc	r0, r16
 bde:	86 56       	subi	r24, 0x66	; 102
 be0:	05 00       	.word	0x0005	; ????
 be2:	00 05       	cpc	r16, r0
 be4:	03 72       	andi	r16, 0x23	; 35
 be6:	00 00       	nop
 be8:	00 26       	eor	r0, r16
 bea:	11 06       	cpc	r1, r17
 bec:	00 00       	nop
 bee:	05 06       	cpc	r0, r21
 bf0:	00 00       	nop
 bf2:	27 4b       	sbci	r18, 0xB7	; 183
 bf4:	00 00       	nop
 bf6:	00 13       	cpse	r16, r16
 bf8:	00 04       	cpc	r0, r0
 bfa:	f5 05       	cpc	r31, r5
 bfc:	00 00       	nop
 bfe:	03 01       	movw	r0, r6
 c00:	08 ac       	ldd	r0, Y+56	; 0x38
 c02:	02 00       	.word	0x0002	; ????
 c04:	00 04       	cpc	r0, r0
 c06:	0a 06       	cpc	r0, r26
 c08:	00 00       	nop
 c0a:	28 1f       	adc	r18, r24
 c0c:	02 00       	.word	0x0002	; ????
 c0e:	00 06       	cpc	r0, r16
 c10:	96 05       	cpc	r25, r6
 c12:	06 00       	.word	0x0006	; ????
 c14:	00 05       	cpc	r16, r0
 c16:	03 7c       	andi	r16, 0xC3	; 195
 c18:	00 00       	nop
 c1a:	00 28       	or	r0, r0
 c1c:	a8 03       	fmulsu	r18, r16
 c1e:	00 00       	nop
 c20:	06 ad       	ldd	r16, Z+62	; 0x3e
 c22:	05 06       	cpc	r0, r21
 c24:	00 00       	nop
 c26:	05 03       	mulsu	r16, r21
 c28:	90 00       	.word	0x0090	; ????
 c2a:	00 00       	nop
 c2c:	28 f8       	.word	0xf828	; ????
 c2e:	03 00       	.word	0x0003	; ????
 c30:	00 06       	cpc	r0, r16
 c32:	c4 05       	cpc	r28, r4
 c34:	06 00       	.word	0x0006	; ????
 c36:	00 05       	cpc	r16, r0
 c38:	03 a4       	ldd	r0, Z+43	; 0x2b
 c3a:	00 00       	nop
 c3c:	00 00       	nop
 c3e:	b7 00       	.word	0x00b7	; ????
 c40:	00 00       	nop
 c42:	02 00       	.word	0x0002	; ????
 c44:	a5 07       	cpc	r26, r21
 c46:	00 00       	nop
 c48:	04 01       	movw	r0, r8
 c4a:	07 04       	cpc	r0, r7
 c4c:	00 00       	nop
 c4e:	12 04       	cpc	r1, r2
 c50:	00 00       	nop
 c52:	16 04       	cpc	r1, r6
 c54:	00 00       	nop
 c56:	2e 2e       	mov	r2, r30
 c58:	2f 2e       	mov	r2, r31
 c5a:	2e 2f       	mov	r18, r30
 c5c:	2e 2e       	mov	r2, r30
 c5e:	2f 2e       	mov	r2, r31
 c60:	2e 2f       	mov	r18, r30
 c62:	67 63       	ori	r22, 0x37	; 55
 c64:	63 2f       	mov	r22, r19
 c66:	6c 69       	ori	r22, 0x9C	; 156
 c68:	62 67       	ori	r22, 0x72	; 114
 c6a:	63 63       	ori	r22, 0x33	; 51
 c6c:	2f 63       	ori	r18, 0x3F	; 63
 c6e:	6f 6e       	ori	r22, 0xEF	; 239
 c70:	66 69       	ori	r22, 0x96	; 150
 c72:	67 2f       	mov	r22, r23
 c74:	61 76       	andi	r22, 0x61	; 97
 c76:	72 2f       	mov	r23, r18
 c78:	6c 69       	ori	r22, 0x9C	; 156
 c7a:	62 31       	cpi	r22, 0x12	; 18
 c7c:	66 75       	andi	r22, 0x56	; 86
 c7e:	6e 63       	ori	r22, 0x3E	; 62
 c80:	73 2e       	mov	r7, r19
 c82:	53 00       	.word	0x0053	; ????
 c84:	2f 68       	ori	r18, 0x8F	; 143
 c86:	6f 6d       	ori	r22, 0xDF	; 223
 c88:	65 2f       	mov	r22, r21
 c8a:	6a 65       	ori	r22, 0x5A	; 90
 c8c:	6e 6b       	ori	r22, 0xBE	; 190
 c8e:	69 6e       	ori	r22, 0xE9	; 233
 c90:	73 2d       	mov	r23, r3
 c92:	6d 69       	ori	r22, 0x9D	; 157
 c94:	6e 67       	ori	r22, 0x7E	; 126
 c96:	77 33       	cpi	r23, 0x37	; 55
 c98:	32 2f       	mov	r19, r18
 c9a:	77 6f       	ori	r23, 0xF7	; 247
 c9c:	72 6b       	ori	r23, 0xB2	; 178
 c9e:	73 70       	andi	r23, 0x03	; 3
 ca0:	61 63       	ori	r22, 0x31	; 49
 ca2:	65 2f       	mov	r22, r21
 ca4:	61 76       	andi	r22, 0x61	; 97
 ca6:	72 2d       	mov	r23, r2
 ca8:	67 63       	ori	r22, 0x37	; 55
 caa:	63 2d       	mov	r22, r3
 cac:	73 74       	andi	r23, 0x43	; 67
 cae:	61 67       	ori	r22, 0x71	; 113
 cb0:	69 6e       	ori	r22, 0xE9	; 233
 cb2:	67 2f       	mov	r22, r23
 cb4:	6c 61       	ori	r22, 0x1C	; 28
 cb6:	62 65       	ori	r22, 0x52	; 82
 cb8:	6c 2f       	mov	r22, r28
 cba:	55 62       	ori	r21, 0x25	; 37
 cbc:	75 6e       	ori	r23, 0xE5	; 229
 cbe:	74 75       	andi	r23, 0x54	; 84
 cc0:	31 34       	cpi	r19, 0x41	; 65
 cc2:	2e 30       	cpi	r18, 0x0E	; 14
 cc4:	34 78       	andi	r19, 0x84	; 132
 cc6:	36 34       	cpi	r19, 0x46	; 70
 cc8:	2d 6d       	ori	r18, 0xDD	; 221
 cca:	69 6e       	ori	r22, 0xE9	; 233
 ccc:	67 77       	andi	r22, 0x77	; 119
 cce:	33 32       	cpi	r19, 0x23	; 35
 cd0:	2f 67       	ori	r18, 0x7F	; 127
 cd2:	63 63       	ori	r22, 0x33	; 51
 cd4:	2d 62       	ori	r18, 0x2D	; 45
 cd6:	75 69       	ori	r23, 0x95	; 149
 cd8:	6c 64       	ori	r22, 0x4C	; 76
 cda:	2f 61       	ori	r18, 0x1F	; 31
 cdc:	76 72       	andi	r23, 0x26	; 38
 cde:	2f 61       	ori	r18, 0x1F	; 31
 ce0:	76 72       	andi	r23, 0x26	; 38
 ce2:	35 2f       	mov	r19, r21
 ce4:	6c 69       	ori	r22, 0x9C	; 156
 ce6:	62 67       	ori	r22, 0x72	; 114
 ce8:	63 63       	ori	r22, 0x33	; 51
 cea:	00 47       	sbci	r16, 0x70	; 112
 cec:	4e 55       	subi	r20, 0x5E	; 94
 cee:	20 41       	sbci	r18, 0x10	; 16
 cf0:	53 20       	and	r5, r3
 cf2:	32 2e       	mov	r3, r18
 cf4:	32 36       	cpi	r19, 0x62	; 98
 cf6:	00 01       	movw	r0, r0
 cf8:	80 b7       	in	r24, 0x30	; 48
 cfa:	00 00       	nop
 cfc:	00 02       	muls	r16, r16
 cfe:	00 b9       	out	0x00, r16	; 0
 d00:	07 00       	.word	0x0007	; ????
 d02:	00 04       	cpc	r0, r0
 d04:	01 69       	ori	r16, 0x91	; 145
 d06:	04 00       	.word	0x0004	; ????
 d08:	00 c4       	rjmp	.+2048   	; 0x150a <__stack+0xc0b>
 d0a:	00 00       	nop
 d0c:	00 d4       	rcall	.+2048   	; 0x150e <__stack+0xc0f>
 d0e:	00 00       	nop
 d10:	00 2e       	mov	r0, r16
 d12:	2e 2f       	mov	r18, r30
 d14:	2e 2e       	mov	r2, r30
 d16:	2f 2e       	mov	r2, r31
 d18:	2e 2f       	mov	r18, r30
 d1a:	2e 2e       	mov	r2, r30
 d1c:	2f 67       	ori	r18, 0x7F	; 127
 d1e:	63 63       	ori	r22, 0x33	; 51
 d20:	2f 6c       	ori	r18, 0xCF	; 207
 d22:	69 62       	ori	r22, 0x29	; 41
 d24:	67 63       	ori	r22, 0x37	; 55
 d26:	63 2f       	mov	r22, r19
 d28:	63 6f       	ori	r22, 0xF3	; 243
 d2a:	6e 66       	ori	r22, 0x6E	; 110
 d2c:	69 67       	ori	r22, 0x79	; 121
 d2e:	2f 61       	ori	r18, 0x1F	; 31
 d30:	76 72       	andi	r23, 0x26	; 38
 d32:	2f 6c       	ori	r18, 0xCF	; 207
 d34:	69 62       	ori	r22, 0x29	; 41
 d36:	31 66       	ori	r19, 0x61	; 97
 d38:	75 6e       	ori	r23, 0xE5	; 229
 d3a:	63 73       	andi	r22, 0x33	; 51
 d3c:	2e 53       	subi	r18, 0x3E	; 62
 d3e:	00 2f       	mov	r16, r16
 d40:	68 6f       	ori	r22, 0xF8	; 248
 d42:	6d 65       	ori	r22, 0x5D	; 93
 d44:	2f 6a       	ori	r18, 0xAF	; 175
 d46:	65 6e       	ori	r22, 0xE5	; 229
 d48:	6b 69       	ori	r22, 0x9B	; 155
 d4a:	6e 73       	andi	r22, 0x3E	; 62
 d4c:	2d 6d       	ori	r18, 0xDD	; 221
 d4e:	69 6e       	ori	r22, 0xE9	; 233
 d50:	67 77       	andi	r22, 0x77	; 119
 d52:	33 32       	cpi	r19, 0x23	; 35
 d54:	2f 77       	andi	r18, 0x7F	; 127
 d56:	6f 72       	andi	r22, 0x2F	; 47
 d58:	6b 73       	andi	r22, 0x3B	; 59
 d5a:	70 61       	ori	r23, 0x10	; 16
 d5c:	63 65       	ori	r22, 0x53	; 83
 d5e:	2f 61       	ori	r18, 0x1F	; 31
 d60:	76 72       	andi	r23, 0x26	; 38
 d62:	2d 67       	ori	r18, 0x7D	; 125
 d64:	63 63       	ori	r22, 0x33	; 51
 d66:	2d 73       	andi	r18, 0x3D	; 61
 d68:	74 61       	ori	r23, 0x14	; 20
 d6a:	67 69       	ori	r22, 0x97	; 151
 d6c:	6e 67       	ori	r22, 0x7E	; 126
 d6e:	2f 6c       	ori	r18, 0xCF	; 207
 d70:	61 62       	ori	r22, 0x21	; 33
 d72:	65 6c       	ori	r22, 0xC5	; 197
 d74:	2f 55       	subi	r18, 0x5F	; 95
 d76:	62 75       	andi	r22, 0x52	; 82
 d78:	6e 74       	andi	r22, 0x4E	; 78
 d7a:	75 31       	cpi	r23, 0x15	; 21
 d7c:	34 2e       	mov	r3, r20
 d7e:	30 34       	cpi	r19, 0x40	; 64
 d80:	78 36       	cpi	r23, 0x68	; 104
 d82:	34 2d       	mov	r19, r4
 d84:	6d 69       	ori	r22, 0x9D	; 157
 d86:	6e 67       	ori	r22, 0x7E	; 126
 d88:	77 33       	cpi	r23, 0x37	; 55
 d8a:	32 2f       	mov	r19, r18
 d8c:	67 63       	ori	r22, 0x37	; 55
 d8e:	63 2d       	mov	r22, r3
 d90:	62 75       	andi	r22, 0x52	; 82
 d92:	69 6c       	ori	r22, 0xC9	; 201
 d94:	64 2f       	mov	r22, r20
 d96:	61 76       	andi	r22, 0x61	; 97
 d98:	72 2f       	mov	r23, r18
 d9a:	61 76       	andi	r22, 0x61	; 97
 d9c:	72 35       	cpi	r23, 0x52	; 82
 d9e:	2f 6c       	ori	r18, 0xCF	; 207
 da0:	69 62       	ori	r22, 0x29	; 41
 da2:	67 63       	ori	r22, 0x37	; 55
 da4:	63 00       	.word	0x0063	; ????
 da6:	47 4e       	sbci	r20, 0xE7	; 231
 da8:	55 20       	and	r5, r5
 daa:	41 53       	subi	r20, 0x31	; 49
 dac:	20 32       	cpi	r18, 0x20	; 32
 dae:	2e 32       	cpi	r18, 0x2E	; 46
 db0:	36 00       	.word	0x0036	; ????
 db2:	01 80       	ldd	r0, Z+1	; 0x01

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	01 11       	cpse	r16, r1
   2:	01 25       	eor	r16, r1
   4:	0e 10       	cpse	r0, r14
   6:	06 00       	.word	0x0006	; ????
   8:	00 02       	muls	r16, r16
   a:	24 00       	.word	0x0024	; ????
   c:	03 0e       	add	r0, r19
   e:	0b 0b       	sbc	r16, r27
  10:	3e 0b       	sbc	r19, r30
  12:	00 00       	nop
  14:	03 24       	eor	r0, r3
  16:	00 03       	mulsu	r16, r16
  18:	0e 0b       	sbc	r16, r30
  1a:	0b 3e       	cpi	r16, 0xEB	; 235
  1c:	0b 00       	.word	0x000b	; ????
  1e:	00 04       	cpc	r0, r0
  20:	01 01       	movw	r0, r2
  22:	49 13       	cpse	r20, r25
  24:	00 00       	nop
  26:	05 21       	and	r16, r5
  28:	00 49       	sbci	r16, 0x90	; 144
  2a:	13 2f       	mov	r17, r19
  2c:	05 00       	.word	0x0005	; ????
  2e:	00 06       	cpc	r0, r16
  30:	34 00       	.word	0x0034	; ????
  32:	03 0e       	add	r0, r19
  34:	3a 0b       	sbc	r19, r26
  36:	3b 0b       	sbc	r19, r27
  38:	49 13       	cpse	r20, r25
  3a:	3f 0c       	add	r3, r15
  3c:	02 0a       	sbc	r0, r18
  3e:	00 00       	nop
  40:	07 34       	cpi	r16, 0x47	; 71
  42:	00 03       	mulsu	r16, r16
  44:	0e 3a       	cpi	r16, 0xAE	; 174
  46:	0b 3b       	cpi	r16, 0xBB	; 187
  48:	0b 49       	sbci	r16, 0x9B	; 155
  4a:	13 3f       	cpi	r17, 0xF3	; 243
  4c:	0c 02       	muls	r16, r28
  4e:	0a 00       	.word	0x000a	; ????
  50:	00 08       	sbc	r0, r0
  52:	34 00       	.word	0x0034	; ????
  54:	03 0e       	add	r0, r19
  56:	3a 0b       	sbc	r19, r26
  58:	3b 0b       	sbc	r19, r27
  5a:	49 13       	cpse	r20, r25
  5c:	3f 0c       	add	r3, r15
  5e:	02 0a       	sbc	r0, r18
  60:	00 00       	nop
  62:	09 34       	cpi	r16, 0x49	; 73
  64:	00 03       	mulsu	r16, r16
  66:	0e 3a       	cpi	r16, 0xAE	; 174
  68:	0b 3b       	cpi	r16, 0xBB	; 187
  6a:	0b 49       	sbci	r16, 0x9B	; 155
  6c:	13 3f       	cpi	r17, 0xF3	; 243
  6e:	0c 02       	muls	r16, r28
  70:	0a 00       	.word	0x000a	; ????
  72:	00 0a       	sbc	r0, r16
  74:	34 00       	.word	0x0034	; ????
  76:	03 0e       	add	r0, r19
  78:	3a 0b       	sbc	r19, r26
  7a:	3b 0b       	sbc	r19, r27
  7c:	49 13       	cpse	r20, r25
  7e:	3f 0c       	add	r3, r15
  80:	02 0a       	sbc	r0, r18
  82:	00 00       	nop
  84:	0b 34       	cpi	r16, 0x4B	; 75
  86:	00 03       	mulsu	r16, r16
  88:	0e 3a       	cpi	r16, 0xAE	; 174
  8a:	0b 3b       	cpi	r16, 0xBB	; 187
  8c:	0b 49       	sbci	r16, 0x9B	; 155
  8e:	13 3f       	cpi	r17, 0xF3	; 243
  90:	0c 02       	muls	r16, r28
  92:	0a 00       	.word	0x000a	; ????
  94:	00 0c       	add	r0, r0
  96:	34 00       	.word	0x0034	; ????
  98:	03 0e       	add	r0, r19
  9a:	3a 0b       	sbc	r19, r26
  9c:	3b 0b       	sbc	r19, r27
  9e:	49 13       	cpse	r20, r25
  a0:	3f 0c       	add	r3, r15
  a2:	02 0a       	sbc	r0, r18
  a4:	00 00       	nop
  a6:	0d 34       	cpi	r16, 0x4D	; 77
  a8:	00 03       	mulsu	r16, r16
  aa:	0e 3a       	cpi	r16, 0xAE	; 174
  ac:	0b 3b       	cpi	r16, 0xBB	; 187
  ae:	0b 49       	sbci	r16, 0x9B	; 155
  b0:	13 3f       	cpi	r17, 0xF3	; 243
  b2:	0c 02       	muls	r16, r28
  b4:	0a 00       	.word	0x000a	; ????
  b6:	00 0e       	add	r0, r16
  b8:	34 00       	.word	0x0034	; ????
  ba:	03 0e       	add	r0, r19
  bc:	3a 0b       	sbc	r19, r26
  be:	3b 0b       	sbc	r19, r27
  c0:	49 13       	cpse	r20, r25
  c2:	3f 0c       	add	r3, r15
  c4:	02 0a       	sbc	r0, r18
  c6:	00 00       	nop
  c8:	0f 34       	cpi	r16, 0x4F	; 79
  ca:	00 03       	mulsu	r16, r16
  cc:	0e 3a       	cpi	r16, 0xAE	; 174
  ce:	0b 3b       	cpi	r16, 0xBB	; 187
  d0:	0b 49       	sbci	r16, 0x9B	; 155
  d2:	13 3f       	cpi	r17, 0xF3	; 243
  d4:	0c 02       	muls	r16, r28
  d6:	0a 00       	.word	0x000a	; ????
  d8:	00 10       	cpse	r0, r0
  da:	34 00       	.word	0x0034	; ????
  dc:	03 0e       	add	r0, r19
  de:	3a 0b       	sbc	r19, r26
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	3b 0b       	sbc	r19, r27
  e2:	49 13       	cpse	r20, r25
  e4:	3f 0c       	add	r3, r15
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	02 0a       	sbc	r0, r18
  e8:	00 00       	nop
  ea:	11 34       	cpi	r17, 0x41	; 65
	uint8_t port = digitalPinToPort(pin);
  ec:	00 03       	mulsu	r16, r16
  ee:	0e 3a       	cpi	r16, 0xAE	; 174
  f0:	0b 3b       	cpi	r16, 0xBB	; 187
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	0b 49       	sbci	r16, 0x9B	; 155
  f4:	13 3f       	cpi	r17, 0xF3	; 243

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	0c 02       	muls	r16, r28
  f8:	0a 00       	.word	0x000a	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 12       	cpse	r0, r16
  fc:	34 00       	.word	0x0034	; ????
  fe:	03 0e       	add	r0, r19
 100:	3a 0b       	sbc	r19, r26
 102:	3b 0b       	sbc	r19, r27
 104:	49 13       	cpse	r20, r25
 106:	3f 0c       	add	r3, r15

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	02 0a       	sbc	r0, r18
 10a:	00 00       	nop
 10c:	13 34       	cpi	r17, 0x43	; 67
 10e:	00 03       	mulsu	r16, r16
 110:	0e 3a       	cpi	r16, 0xAE	; 174
 112:	0b 3b       	cpi	r16, 0xBB	; 187
 114:	0b 49       	sbci	r16, 0x9B	; 155

	uint8_t oldSREG = SREG;
 116:	13 3f       	cpi	r17, 0xF3	; 243
	cli();
 118:	0c 02       	muls	r16, r28

	if (val == LOW) {
		*out &= ~bit;
 11a:	0a 00       	.word	0x000a	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 14       	cp	r0, r0
 11e:	34 00       	.word	0x0034	; ????
		*out &= ~bit;
 120:	03 0e       	add	r0, r19
 122:	3a 0b       	sbc	r19, r26
	} else {
		*out |= bit;
 124:	3b 0b       	sbc	r19, r27
	}

	SREG = oldSREG;
 126:	49 13       	cpse	r20, r25
}
 128:	3f 0c       	add	r3, r15
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	02 0a       	sbc	r0, r18
 12c:	00 00       	nop
 12e:	15 34       	cpi	r17, 0x45	; 69
 130:	00 03       	mulsu	r16, r16
 132:	0e 3a       	cpi	r16, 0xAE	; 174
 134:	0b 3b       	cpi	r16, 0xBB	; 187
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	0b 49       	sbci	r16, 0x9B	; 155
 138:	13 3f       	cpi	r17, 0xF3	; 243
 13a:	0c 02       	muls	r16, r28
 13c:	0a 00       	.word	0x000a	; ????
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	00 16       	cp	r0, r16
 140:	34 00       	.word	0x0034	; ????
 142:	03 0e       	add	r0, r19
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	3a 0b       	sbc	r19, r26
 146:	3b 0b       	sbc	r19, r27
 148:	49 13       	cpse	r20, r25
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	3f 0c       	add	r3, r15
 14c:	02 0a       	sbc	r0, r18
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	00 00       	nop
 150:	17 34       	cpi	r17, 0x47	; 71
 152:	00 03       	mulsu	r16, r16
 154:	0e 3a       	cpi	r16, 0xAE	; 174
 156:	0b 3b       	cpi	r16, 0xBB	; 187
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	0b 49       	sbci	r16, 0x9B	; 155
 15a:	13 3f       	cpi	r17, 0xF3	; 243
 15c:	0c 02       	muls	r16, r28
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	0a 00       	.word	0x000a	; ????
 160:	00 18       	sub	r0, r0
 162:	34 00       	.word	0x0034	; ????
 164:	03 0e       	add	r0, r19
 166:	3a 0b       	sbc	r19, r26
 168:	3b 0b       	sbc	r19, r27
 16a:	49 13       	cpse	r20, r25
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	3f 0c       	add	r3, r15
 16e:	02 0a       	sbc	r0, r18
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 00       	nop
 172:	19 34       	cpi	r17, 0x49	; 73
 174:	00 03       	mulsu	r16, r16
 176:	0e 3a       	cpi	r16, 0xAE	; 174
 178:	0b 3b       	cpi	r16, 0xBB	; 187
 17a:	0b 49       	sbci	r16, 0x9B	; 155
 17c:	13 3f       	cpi	r17, 0xF3	; 243
 17e:	0c 02       	muls	r16, r28
 180:	0a 00       	.word	0x000a	; ????
 182:	00 1a       	sub	r0, r16
 184:	34 00       	.word	0x0034	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	03 0e       	add	r0, r19
 188:	3a 0b       	sbc	r19, r26
 18a:	3b 0b       	sbc	r19, r27
 18c:	49 13       	cpse	r20, r25
 18e:	3f 0c       	add	r3, r15
 190:	02 0a       	sbc	r0, r18
 192:	00 00       	nop
 194:	1b 34       	cpi	r17, 0x4B	; 75
	unsigned char f = timer0_fract;
 196:	00 03       	mulsu	r16, r16
 198:	0e 3a       	cpi	r16, 0xAE	; 174

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	0b 3b       	cpi	r16, 0xBB	; 187
 19c:	0b 49       	sbci	r16, 0x9B	; 155
	if (f >= FRACT_MAX) {
 19e:	13 3f       	cpi	r17, 0xF3	; 243
 1a0:	0c 02       	muls	r16, r28
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	0a 00       	.word	0x000a	; ????
 1a4:	00 1c       	adc	r0, r0
 1a6:	34 00       	.word	0x0034	; ????
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	03 0e       	add	r0, r19
 1aa:	3a 0b       	sbc	r19, r26
	timer0_millis = m;
 1ac:	3b 0b       	sbc	r19, r27
 1ae:	49 13       	cpse	r20, r25
 1b0:	3f 0c       	add	r3, r15
 1b2:	02 0a       	sbc	r0, r18
 1b4:	00 00       	nop
 1b6:	1d 34       	cpi	r17, 0x4D	; 77
 1b8:	00 03       	mulsu	r16, r16
 1ba:	0e 3a       	cpi	r16, 0xAE	; 174
	timer0_overflow_count++;
 1bc:	0b 3b       	cpi	r16, 0xBB	; 187
 1be:	0b 49       	sbci	r16, 0x9B	; 155
 1c0:	13 3f       	cpi	r17, 0xF3	; 243
 1c2:	0c 02       	muls	r16, r28
 1c4:	0a 00       	.word	0x000a	; ????
 1c6:	00 1e       	adc	r0, r16
 1c8:	34 00       	.word	0x0034	; ????
 1ca:	03 0e       	add	r0, r19
 1cc:	3a 0b       	sbc	r19, r26
 1ce:	3b 0b       	sbc	r19, r27
 1d0:	49 13       	cpse	r20, r25
 1d2:	3f 0c       	add	r3, r15
 1d4:	02 0a       	sbc	r0, r18
 1d6:	00 00       	nop
 1d8:	1f 34       	cpi	r17, 0x4F	; 79
 1da:	00 03       	mulsu	r16, r16
 1dc:	0e 3a       	cpi	r16, 0xAE	; 174
 1de:	0b 3b       	cpi	r16, 0xBB	; 187
 1e0:	0b 49       	sbci	r16, 0x9B	; 155
}
 1e2:	13 3f       	cpi	r17, 0xF3	; 243
 1e4:	0c 02       	muls	r16, r28
 1e6:	0a 00       	.word	0x000a	; ????
 1e8:	00 20       	and	r0, r0
 1ea:	34 00       	.word	0x0034	; ????
 1ec:	03 0e       	add	r0, r19
 1ee:	3a 0b       	sbc	r19, r26
 1f0:	3b 0b       	sbc	r19, r27
 1f2:	49 13       	cpse	r20, r25
 1f4:	3f 0c       	add	r3, r15
 1f6:	02 0a       	sbc	r0, r18
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 00       	nop
 1fa:	21 34       	cpi	r18, 0x41	; 65
		m += 1;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	0e 3a       	cpi	r16, 0xAE	; 174
 200:	0b 3b       	cpi	r16, 0xBB	; 187
 202:	0b 49       	sbci	r16, 0x9B	; 155

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	13 3f       	cpi	r17, 0xF3	; 243
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	0c 02       	muls	r16, r28
 208:	0a 00       	.word	0x000a	; ????
 20a:	00 22       	and	r0, r16
	sbi(TCCR0A, WGM00);
 20c:	34 00       	.word	0x0034	; ????
 20e:	03 0e       	add	r0, r19
 210:	3a 0b       	sbc	r19, r26
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	3b 0b       	sbc	r19, r27
 214:	49 13       	cpse	r20, r25
 216:	3f 0c       	add	r3, r15
	sbi(TCCR0B, CS00);
 218:	02 0a       	sbc	r0, r18
 21a:	00 00       	nop
 21c:	23 34       	cpi	r18, 0x43	; 67

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 03       	mulsu	r16, r16
 220:	0e 3a       	cpi	r16, 0xAE	; 174
 222:	0b 3b       	cpi	r16, 0xBB	; 187
 224:	0b 49       	sbci	r16, 0x9B	; 155
 226:	13 3f       	cpi	r17, 0xF3	; 243
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	0c 02       	muls	r16, r28
 22a:	0a 00       	.word	0x000a	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	00 24       	eor	r0, r0
 22e:	34 00       	.word	0x0034	; ????
 230:	03 0e       	add	r0, r19
 232:	3a 0b       	sbc	r19, r26
 234:	3b 0b       	sbc	r19, r27
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	49 13       	cpse	r20, r25
 238:	3f 0c       	add	r3, r15
 23a:	02 0a       	sbc	r0, r18
 23c:	00 00       	nop
 23e:	25 34       	cpi	r18, 0x45	; 69
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	00 03       	mulsu	r16, r16
 242:	0e 3a       	cpi	r16, 0xAE	; 174
 244:	0b 3b       	cpi	r16, 0xBB	; 187
 246:	0b 49       	sbci	r16, 0x9B	; 155
 248:	13 3f       	cpi	r17, 0xF3	; 243

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	0c 02       	muls	r16, r28
 24c:	0a 00       	.word	0x000a	; ????
 24e:	00 26       	eor	r0, r16
 250:	34 00       	.word	0x0034	; ????
 252:	03 0e       	add	r0, r19

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	3a 0b       	sbc	r19, r26
 256:	3b 0b       	sbc	r19, r27
 258:	49 13       	cpse	r20, r25
 25a:	3f 0c       	add	r3, r15
 25c:	02 0a       	sbc	r0, r18
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 00       	nop
 260:	27 34       	cpi	r18, 0x47	; 71
 262:	00 03       	mulsu	r16, r16
 264:	0e 3a       	cpi	r16, 0xAE	; 174
 266:	0b 3b       	cpi	r16, 0xBB	; 187
		sbi(ADCSRA, ADPS1);
 268:	0b 49       	sbci	r16, 0x9B	; 155
 26a:	13 3f       	cpi	r17, 0xF3	; 243
 26c:	0c 02       	muls	r16, r28
 26e:	0a 00       	.word	0x000a	; ????
 270:	00 28       	or	r0, r0
		sbi(ADCSRA, ADPS0);
 272:	34 00       	.word	0x0034	; ????
 274:	03 0e       	add	r0, r19
 276:	3a 0b       	sbc	r19, r26
 278:	3b 0b       	sbc	r19, r27
 27a:	49 13       	cpse	r20, r25
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	3f 0c       	add	r3, r15
 27e:	02 0a       	sbc	r0, r18
 280:	00 00       	nop
 282:	29 34       	cpi	r18, 0x49	; 73
 284:	00 03       	mulsu	r16, r16
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	0e 3a       	cpi	r16, 0xAE	; 174
 288:	0b 3b       	cpi	r16, 0xBB	; 187
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	0b 49       	sbci	r16, 0x9B	; 155
 28c:	13 3f       	cpi	r17, 0xF3	; 243
 28e:	0c 02       	muls	r16, r28
	uint8_t port = digitalPinToPort(pin);
 290:	0a 00       	.word	0x000a	; ????
 292:	00 2a       	or	r0, r16
 294:	34 00       	.word	0x0034	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	03 0e       	add	r0, r19
 298:	3a 0b       	sbc	r19, r26

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	3b 0b       	sbc	r19, r27
 29c:	49 13       	cpse	r20, r25
 29e:	3f 0c       	add	r3, r15
 2a0:	02 0a       	sbc	r0, r18
 2a2:	00 00       	nop
 2a4:	2b 34       	cpi	r18, 0x4B	; 75
 2a6:	00 03       	mulsu	r16, r16
 2a8:	0e 3a       	cpi	r16, 0xAE	; 174
	out = portOutputRegister(port);
 2aa:	0b 3b       	cpi	r16, 0xBB	; 187
 2ac:	0b 49       	sbci	r16, 0x9B	; 155
 2ae:	13 3f       	cpi	r17, 0xF3	; 243
 2b0:	0c 02       	muls	r16, r28
 2b2:	0a 00       	.word	0x000a	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	00 2c       	mov	r0, r0
                cli();
 2b6:	34 00       	.word	0x0034	; ????
		*reg |= bit;
 2b8:	03 0e       	add	r0, r19
 2ba:	3a 0b       	sbc	r19, r26
 2bc:	3b 0b       	sbc	r19, r27
		SREG = oldSREG;
 2be:	49 13       	cpse	r20, r25
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	3f 0c       	add	r3, r15
 2c2:	02 0a       	sbc	r0, r18
 2c4:	00 00       	nop
 2c6:	2d 34       	cpi	r18, 0x4D	; 77
 2c8:	00 03       	mulsu	r16, r16
 2ca:	0e 3a       	cpi	r16, 0xAE	; 174
 2cc:	0b 3b       	cpi	r16, 0xBB	; 187
 2ce:	0b 49       	sbci	r16, 0x9B	; 155
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	13 3f       	cpi	r17, 0xF3	; 243
 2d2:	0c 02       	muls	r16, r28
 2d4:	0a 00       	.word	0x000a	; ????
 2d6:	00 2e       	mov	r0, r16
 2d8:	34 00       	.word	0x0034	; ????
 2da:	03 0e       	add	r0, r19

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	3a 0b       	sbc	r19, r26
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	3b 0b       	sbc	r19, r27
 2e0:	49 13       	cpse	r20, r25
 2e2:	3f 0c       	add	r3, r15
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	02 0a       	sbc	r0, r18
 2e6:	00 00       	nop
 2e8:	2f 34       	cpi	r18, 0x4F	; 79
 2ea:	00 03       	mulsu	r16, r16
 2ec:	0e 3a       	cpi	r16, 0xAE	; 174
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	0b 3b       	cpi	r16, 0xBB	; 187
 2f0:	0b 49       	sbci	r16, 0x9B	; 155
 2f2:	13 3f       	cpi	r17, 0xF3	; 243
 2f4:	0c 02       	muls	r16, r28
 2f6:	0a 00       	.word	0x000a	; ????
 2f8:	00 30       	cpi	r16, 0x00	; 0
 2fa:	34 00       	.word	0x0034	; ????
 2fc:	03 0e       	add	r0, r19
    b = 0xffffffff; 
 2fe:	3a 0b       	sbc	r19, r26
 300:	3b 0b       	sbc	r19, r27
 302:	49 13       	cpse	r20, r25
 304:	3f 0c       	add	r3, r15
 306:	02 0a       	sbc	r0, r18
 308:	00 00       	nop
 30a:	31 34       	cpi	r19, 0x41	; 65
 30c:	00 03       	mulsu	r16, r16
    a |= b;
 30e:	0e 3a       	cpi	r16, 0xAE	; 174
 310:	0b 3b       	cpi	r16, 0xBB	; 187
 312:	0b 49       	sbci	r16, 0x9B	; 155
 314:	13 3f       	cpi	r17, 0xF3	; 243
 316:	0c 02       	muls	r16, r28
 318:	0a 00       	.word	0x000a	; ????
 31a:	00 32       	cpi	r16, 0x20	; 32
 31c:	34 00       	.word	0x0034	; ????
 31e:	03 0e       	add	r0, r19
 320:	3a 0b       	sbc	r19, r26
 322:	3b 0b       	sbc	r19, r27
 324:	49 13       	cpse	r20, r25
 326:	3f 0c       	add	r3, r15
 328:	02 0a       	sbc	r0, r18
 32a:	00 00       	nop
 32c:	33 34       	cpi	r19, 0x43	; 67
 32e:	00 03       	mulsu	r16, r16
 330:	0e 3a       	cpi	r16, 0xAE	; 174
 332:	0b 3b       	cpi	r16, 0xBB	; 187
 334:	0b 49       	sbci	r16, 0x9B	; 155
 336:	13 3f       	cpi	r17, 0xF3	; 243
 338:	0c 02       	muls	r16, r28
 33a:	0a 00       	.word	0x000a	; ????
 33c:	00 34       	cpi	r16, 0x40	; 64
 33e:	34 00       	.word	0x0034	; ????
 340:	03 0e       	add	r0, r19
 342:	3a 0b       	sbc	r19, r26
 344:	3b 0b       	sbc	r19, r27
    b = 0x00000000;
 346:	49 13       	cpse	r20, r25
 348:	3f 0c       	add	r3, r15
 34a:	02 0a       	sbc	r0, r18
 34c:	00 00       	nop
 34e:	35 34       	cpi	r19, 0x45	; 69
 350:	00 03       	mulsu	r16, r16
 352:	0e 3a       	cpi	r16, 0xAE	; 174
 354:	0b 3b       	cpi	r16, 0xBB	; 187
    if(x){
 356:	0b 49       	sbci	r16, 0x9B	; 155
 358:	13 3f       	cpi	r17, 0xF3	; 243
 35a:	0c 02       	muls	r16, r28
 35c:	0a 00       	.word	0x000a	; ????
 35e:	00 36       	cpi	r16, 0x60	; 96
 360:	34 00       	.word	0x0034	; ????
 362:	03 0e       	add	r0, r19
 364:	3a 0b       	sbc	r19, r26
 366:	3b 0b       	sbc	r19, r27
 368:	49 13       	cpse	r20, r25
 36a:	3f 0c       	add	r3, r15
 36c:	02 0a       	sbc	r0, r18
      //a &= b;
      b = 0xffffffff; 
 36e:	00 00       	nop
 370:	37 34       	cpi	r19, 0x47	; 71
 372:	00 03       	mulsu	r16, r16
 374:	0e 3a       	cpi	r16, 0xAE	; 174
 376:	0b 3b       	cpi	r16, 0xBB	; 187
 378:	0b 49       	sbci	r16, 0x9B	; 155
 37a:	13 3f       	cpi	r17, 0xF3	; 243
 37c:	0c 02       	muls	r16, r28
      //a = a^b;
    }
    a &= b;
 37e:	0a 00       	.word	0x000a	; ????
 380:	00 38       	cpi	r16, 0x80	; 128
 382:	34 00       	.word	0x0034	; ????
 384:	03 0e       	add	r0, r19
 386:	3a 0b       	sbc	r19, r26
 388:	3b 0b       	sbc	r19, r27
 38a:	49 13       	cpse	r20, r25
 38c:	3f 0c       	add	r3, r15
 38e:	02 0a       	sbc	r0, r18
 390:	00 00       	nop
 392:	39 34       	cpi	r19, 0x49	; 73
 394:	00 03       	mulsu	r16, r16
 396:	0e 3a       	cpi	r16, 0xAE	; 174
 398:	0b 3b       	cpi	r16, 0xBB	; 187
 39a:	0b 49       	sbci	r16, 0x9B	; 155
 39c:	13 3f       	cpi	r17, 0xF3	; 243
 39e:	0c 02       	muls	r16, r28
 3a0:	0a 00       	.word	0x000a	; ????
 3a2:	00 3a       	cpi	r16, 0xA0	; 160
 3a4:	34 00       	.word	0x0034	; ????
 3a6:	03 0e       	add	r0, r19
 3a8:	3a 0b       	sbc	r19, r26
 3aa:	3b 0b       	sbc	r19, r27
 3ac:	49 13       	cpse	r20, r25
 3ae:	3f 0c       	add	r3, r15
 3b0:	02 0a       	sbc	r0, r18
 3b2:	00 00       	nop
 3b4:	3b 34       	cpi	r19, 0x4B	; 75
    b = 0xffffffff; 
 3b6:	00 03       	mulsu	r16, r16
 3b8:	0e 3a       	cpi	r16, 0xAE	; 174
 3ba:	0b 3b       	cpi	r16, 0xBB	; 187
 3bc:	0b 49       	sbci	r16, 0x9B	; 155
 3be:	13 3f       	cpi	r17, 0xF3	; 243
 3c0:	0c 02       	muls	r16, r28
 3c2:	0a 00       	.word	0x000a	; ????
 3c4:	00 3c       	cpi	r16, 0xC0	; 192
    a = a^b;
 3c6:	34 00       	.word	0x0034	; ????
 3c8:	03 0e       	add	r0, r19
 3ca:	3a 0b       	sbc	r19, r26
 3cc:	3b 0b       	sbc	r19, r27
 3ce:	49 13       	cpse	r20, r25
 3d0:	3f 0c       	add	r3, r15
 3d2:	02 0a       	sbc	r0, r18
 3d4:	00 00       	nop
 3d6:	3d 34       	cpi	r19, 0x4D	; 77
 3d8:	00 03       	mulsu	r16, r16
 3da:	0e 3a       	cpi	r16, 0xAE	; 174
 3dc:	0b 3b       	cpi	r16, 0xBB	; 187
 3de:	0b 49       	sbci	r16, 0x9B	; 155
 3e0:	13 3f       	cpi	r17, 0xF3	; 243
 3e2:	0c 02       	muls	r16, r28
 3e4:	0a 00       	.word	0x000a	; ????
 3e6:	00 3e       	cpi	r16, 0xE0	; 224
 3e8:	34 00       	.word	0x0034	; ????
 3ea:	03 0e       	add	r0, r19
 3ec:	3a 0b       	sbc	r19, r26
 3ee:	3b 0b       	sbc	r19, r27
 3f0:	49 13       	cpse	r20, r25
 3f2:	3f 0c       	add	r3, r15
 3f4:	02 0a       	sbc	r0, r18
 3f6:	00 00       	nop
 3f8:	3f 34       	cpi	r19, 0x4F	; 79
 3fa:	00 03       	mulsu	r16, r16
 3fc:	0e 3a       	cpi	r16, 0xAE	; 174
 3fe:	0b 3b       	cpi	r16, 0xBB	; 187
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	0b 49       	sbci	r16, 0x9B	; 155
 402:	13 3f       	cpi	r17, 0xF3	; 243
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	0c 02       	muls	r16, r28
 406:	0a 00       	.word	0x000a	; ????
 408:	00 40       	sbci	r16, 0x00	; 0
 40a:	34 00       	.word	0x0034	; ????
 40c:	03 0e       	add	r0, r19
 40e:	3a 0b       	sbc	r19, r26
 410:	3b 0b       	sbc	r19, r27
 412:	49 13       	cpse	r20, r25
 414:	3f 0c       	add	r3, r15
 416:	02 0a       	sbc	r0, r18
 418:	00 00       	nop
 41a:	41 34       	cpi	r20, 0x41	; 65
 41c:	00 03       	mulsu	r16, r16
 41e:	0e 3a       	cpi	r16, 0xAE	; 174
 420:	0b 3b       	cpi	r16, 0xBB	; 187
 422:	0b 49       	sbci	r16, 0x9B	; 155
 424:	13 3f       	cpi	r17, 0xF3	; 243
 426:	0c 02       	muls	r16, r28
 428:	0a 00       	.word	0x000a	; ????
 42a:	00 42       	sbci	r16, 0x20	; 32
 42c:	34 00       	.word	0x0034	; ????
 42e:	03 0e       	add	r0, r19
 430:	3a 0b       	sbc	r19, r26
 432:	3b 0b       	sbc	r19, r27
 434:	49 13       	cpse	r20, r25
 436:	3f 0c       	add	r3, r15
 438:	02 0a       	sbc	r0, r18
 43a:	00 00       	nop
 43c:	43 34       	cpi	r20, 0x43	; 67
 43e:	00 03       	mulsu	r16, r16
 440:	0e 3a       	cpi	r16, 0xAE	; 174
 442:	0b 3b       	cpi	r16, 0xBB	; 187
 444:	0b 49       	sbci	r16, 0x9B	; 155
 446:	13 3f       	cpi	r17, 0xF3	; 243
 448:	0c 02       	muls	r16, r28
 44a:	0a 00       	.word	0x000a	; ????
 44c:	00 44       	sbci	r16, 0x40	; 64
 44e:	34 00       	.word	0x0034	; ????
 450:	03 0e       	add	r0, r19
 452:	3a 0b       	sbc	r19, r26
 454:	3b 0b       	sbc	r19, r27
 456:	49 13       	cpse	r20, r25
 458:	3f 0c       	add	r3, r15
 45a:	02 0a       	sbc	r0, r18
 45c:	00 00       	nop
 45e:	45 34       	cpi	r20, 0x45	; 69
 460:	00 03       	mulsu	r16, r16
 462:	0e 3a       	cpi	r16, 0xAE	; 174
 464:	0b 3b       	cpi	r16, 0xBB	; 187
 466:	0b 49       	sbci	r16, 0x9B	; 155
 468:	13 3f       	cpi	r17, 0xF3	; 243
 46a:	0c 02       	muls	r16, r28
 46c:	0a 00       	.word	0x000a	; ????
 46e:	00 46       	sbci	r16, 0x60	; 96
 470:	34 00       	.word	0x0034	; ????
 472:	03 0e       	add	r0, r19
 474:	3a 0b       	sbc	r19, r26
 476:	3b 0b       	sbc	r19, r27
 478:	49 13       	cpse	r20, r25
 47a:	3f 0c       	add	r3, r15
 47c:	02 0a       	sbc	r0, r18
 47e:	00 00       	nop
 480:	47 34       	cpi	r20, 0x47	; 71
 482:	00 03       	mulsu	r16, r16
 484:	0e 3a       	cpi	r16, 0xAE	; 174
 486:	0b 3b       	cpi	r16, 0xBB	; 187
 488:	0b 49       	sbci	r16, 0x9B	; 155
 48a:	13 3f       	cpi	r17, 0xF3	; 243
 48c:	0c 02       	muls	r16, r28
 48e:	0a 00       	.word	0x000a	; ????
 490:	00 48       	sbci	r16, 0x80	; 128
 492:	34 00       	.word	0x0034	; ????
 494:	03 0e       	add	r0, r19
 496:	3a 0b       	sbc	r19, r26
 498:	3b 0b       	sbc	r19, r27
 49a:	49 13       	cpse	r20, r25
 49c:	3f 0c       	add	r3, r15
 49e:	02 0a       	sbc	r0, r18
 4a0:	00 00       	nop
 4a2:	49 34       	cpi	r20, 0x49	; 73
 4a4:	00 03       	mulsu	r16, r16
 4a6:	0e 3a       	cpi	r16, 0xAE	; 174
 4a8:	0b 3b       	cpi	r16, 0xBB	; 187
 4aa:	0b 49       	sbci	r16, 0x9B	; 155
 4ac:	13 3f       	cpi	r17, 0xF3	; 243
 4ae:	0c 02       	muls	r16, r28
 4b0:	0a 00       	.word	0x000a	; ????
 4b2:	00 4a       	sbci	r16, 0xA0	; 160
 4b4:	34 00       	.word	0x0034	; ????
 4b6:	03 0e       	add	r0, r19
 4b8:	3a 0b       	sbc	r19, r26
 4ba:	3b 0b       	sbc	r19, r27
 4bc:	49 13       	cpse	r20, r25
 4be:	3f 0c       	add	r3, r15
 4c0:	02 0a       	sbc	r0, r18
 4c2:	00 00       	nop
 4c4:	4b 34       	cpi	r20, 0x4B	; 75
 4c6:	00 03       	mulsu	r16, r16
 4c8:	0e 3a       	cpi	r16, 0xAE	; 174
 4ca:	0b 3b       	cpi	r16, 0xBB	; 187
 4cc:	0b 49       	sbci	r16, 0x9B	; 155
 4ce:	13 3f       	cpi	r17, 0xF3	; 243
 4d0:	0c 02       	muls	r16, r28
 4d2:	0a 00       	.word	0x000a	; ????
 4d4:	00 4c       	sbci	r16, 0xC0	; 192
 4d6:	34 00       	.word	0x0034	; ????
 4d8:	03 0e       	add	r0, r19
 4da:	3a 0b       	sbc	r19, r26
 4dc:	3b 0b       	sbc	r19, r27
 4de:	49 13       	cpse	r20, r25
 4e0:	3f 0c       	add	r3, r15
 4e2:	02 0a       	sbc	r0, r18
 4e4:	00 00       	nop
 4e6:	4d 34       	cpi	r20, 0x4D	; 77
 4e8:	00 03       	mulsu	r16, r16
 4ea:	0e 3a       	cpi	r16, 0xAE	; 174
 4ec:	0b 3b       	cpi	r16, 0xBB	; 187
 4ee:	0b 49       	sbci	r16, 0x9B	; 155
 4f0:	13 3f       	cpi	r17, 0xF3	; 243
 4f2:	0c 02       	muls	r16, r28
 4f4:	0a 00       	.word	0x000a	; ????
 4f6:	00 4e       	sbci	r16, 0xE0	; 224
 4f8:	34 00       	.word	0x0034	; ????
 4fa:	03 0e       	add	r0, r19
 4fc:	3a 0b       	sbc	r19, r26
 4fe:	3b 0b       	sbc	r19, r27
 500:	49 13       	cpse	r20, r25
 502:	3f 0c       	add	r3, r15
 504:	02 0a       	sbc	r0, r18
 506:	00 00       	nop
 508:	4f 34       	cpi	r20, 0x4F	; 79
 50a:	00 03       	mulsu	r16, r16
 50c:	0e 3a       	cpi	r16, 0xAE	; 174
 50e:	0b 3b       	cpi	r16, 0xBB	; 187
 510:	0b 49       	sbci	r16, 0x9B	; 155
 512:	13 3f       	cpi	r17, 0xF3	; 243
 514:	0c 02       	muls	r16, r28
 516:	0a 00       	.word	0x000a	; ????
 518:	00 50       	subi	r16, 0x00	; 0
 51a:	34 00       	.word	0x0034	; ????
 51c:	03 0e       	add	r0, r19
 51e:	3a 0b       	sbc	r19, r26
 520:	3b 0b       	sbc	r19, r27
 522:	49 13       	cpse	r20, r25
 524:	3f 0c       	add	r3, r15
 526:	02 0a       	sbc	r0, r18
 528:	00 00       	nop
 52a:	51 34       	cpi	r21, 0x41	; 65
 52c:	00 03       	mulsu	r16, r16
 52e:	0e 3a       	cpi	r16, 0xAE	; 174
 530:	0b 3b       	cpi	r16, 0xBB	; 187
 532:	0b 49       	sbci	r16, 0x9B	; 155
 534:	13 3f       	cpi	r17, 0xF3	; 243
 536:	0c 02       	muls	r16, r28
 538:	0a 00       	.word	0x000a	; ????
 53a:	00 52       	subi	r16, 0x20	; 32
 53c:	34 00       	.word	0x0034	; ????
 53e:	03 0e       	add	r0, r19
 540:	3a 0b       	sbc	r19, r26
 542:	3b 0b       	sbc	r19, r27
 544:	49 13       	cpse	r20, r25
 546:	3f 0c       	add	r3, r15
 548:	02 0a       	sbc	r0, r18
 54a:	00 00       	nop
 54c:	53 34       	cpi	r21, 0x43	; 67
 54e:	00 03       	mulsu	r16, r16
 550:	0e 3a       	cpi	r16, 0xAE	; 174
 552:	0b 3b       	cpi	r16, 0xBB	; 187
 554:	0b 49       	sbci	r16, 0x9B	; 155
 556:	13 3f       	cpi	r17, 0xF3	; 243
 558:	0c 02       	muls	r16, r28
 55a:	0a 00       	.word	0x000a	; ????
 55c:	00 54       	subi	r16, 0x40	; 64
 55e:	34 00       	.word	0x0034	; ????
 560:	03 0e       	add	r0, r19
 562:	3a 0b       	sbc	r19, r26
 564:	3b 0b       	sbc	r19, r27
 566:	49 13       	cpse	r20, r25
 568:	3f 0c       	add	r3, r15
 56a:	02 0a       	sbc	r0, r18
 56c:	00 00       	nop
 56e:	55 34       	cpi	r21, 0x45	; 69
 570:	00 03       	mulsu	r16, r16
 572:	0e 3a       	cpi	r16, 0xAE	; 174
 574:	0b 3b       	cpi	r16, 0xBB	; 187
 576:	0b 49       	sbci	r16, 0x9B	; 155
 578:	13 3f       	cpi	r17, 0xF3	; 243
 57a:	0c 02       	muls	r16, r28
 57c:	0a 00       	.word	0x000a	; ????
 57e:	00 56       	subi	r16, 0x60	; 96
 580:	34 00       	.word	0x0034	; ????
 582:	03 0e       	add	r0, r19
 584:	3a 0b       	sbc	r19, r26
 586:	3b 0b       	sbc	r19, r27
 588:	49 13       	cpse	r20, r25
 58a:	3f 0c       	add	r3, r15
 58c:	02 0a       	sbc	r0, r18
 58e:	00 00       	nop
 590:	57 34       	cpi	r21, 0x47	; 71
 592:	00 03       	mulsu	r16, r16
 594:	0e 3a       	cpi	r16, 0xAE	; 174
 596:	0b 3b       	cpi	r16, 0xBB	; 187
 598:	0b 49       	sbci	r16, 0x9B	; 155
 59a:	13 3f       	cpi	r17, 0xF3	; 243
 59c:	0c 02       	muls	r16, r28
 59e:	0a 00       	.word	0x000a	; ????
 5a0:	00 00       	nop
 5a2:	01 11       	cpse	r16, r1
 5a4:	01 25       	eor	r16, r1
 5a6:	0e 13       	cpse	r16, r30
 5a8:	0b 03       	fmul	r16, r19
 5aa:	0e 1b       	sub	r16, r30
 5ac:	0e 55       	subi	r16, 0x5E	; 94
 5ae:	06 11       	cpse	r16, r6
 5b0:	01 52       	subi	r16, 0x21	; 33
 5b2:	01 10       	cpse	r0, r1
 5b4:	06 00       	.word	0x0006	; ????
 5b6:	00 02       	muls	r16, r16
 5b8:	16 00       	.word	0x0016	; ????
 5ba:	03 0e       	add	r0, r19
 5bc:	3a 0b       	sbc	r19, r26
 5be:	3b 0b       	sbc	r19, r27
 5c0:	49 13       	cpse	r20, r25
 5c2:	00 00       	nop
 5c4:	03 24       	eor	r0, r3
 5c6:	00 0b       	sbc	r16, r16
 5c8:	0b 3e       	cpi	r16, 0xEB	; 235
 5ca:	0b 03       	fmul	r16, r19
 5cc:	0e 00       	.word	0x000e	; ????
 5ce:	00 04       	cpc	r0, r0
 5d0:	26 00       	.word	0x0026	; ????
 5d2:	49 13       	cpse	r20, r25
 5d4:	00 00       	nop
 5d6:	05 2e       	mov	r0, r21
 5d8:	01 03       	mulsu	r16, r17
 5da:	0e 3a       	cpi	r16, 0xAE	; 174
 5dc:	0b 3b       	cpi	r16, 0xBB	; 187
 5de:	0b 20       	and	r0, r11
 5e0:	0b 01       	movw	r0, r22
 5e2:	13 00       	.word	0x0013	; ????
 5e4:	00 06       	cpc	r0, r16
 5e6:	05 00       	.word	0x0005	; ????
 5e8:	03 08       	sbc	r0, r3
 5ea:	3a 0b       	sbc	r19, r26
 5ec:	3b 0b       	sbc	r19, r27
 5ee:	49 13       	cpse	r20, r25
 5f0:	00 00       	nop
 5f2:	07 05       	cpc	r16, r7
 5f4:	00 03       	mulsu	r16, r16
 5f6:	0e 3a       	cpi	r16, 0xAE	; 174
 5f8:	0b 3b       	cpi	r16, 0xBB	; 187
 5fa:	0b 49       	sbci	r16, 0x9B	; 155
 5fc:	13 00       	.word	0x0013	; ????
 5fe:	00 08       	sbc	r0, r0
 600:	34 00       	.word	0x0034	; ????
 602:	03 08       	sbc	r0, r3
 604:	3a 0b       	sbc	r19, r26
 606:	3b 0b       	sbc	r19, r27
 608:	49 13       	cpse	r20, r25
 60a:	00 00       	nop
 60c:	09 34       	cpi	r16, 0x49	; 73
 60e:	00 03       	mulsu	r16, r16
 610:	0e 3a       	cpi	r16, 0xAE	; 174
 612:	0b 3b       	cpi	r16, 0xBB	; 187
 614:	0b 49       	sbci	r16, 0x9B	; 155
 616:	13 00       	.word	0x0013	; ????
 618:	00 0a       	sbc	r0, r16
 61a:	0b 01       	movw	r0, r22
 61c:	01 13       	cpse	r16, r17
 61e:	00 00       	nop
 620:	0b 0b       	sbc	r16, r27
 622:	01 00       	.word	0x0001	; ????
 624:	00 0c       	add	r0, r0
 626:	0f 00       	.word	0x000f	; ????
 628:	0b 0b       	sbc	r16, r27
 62a:	49 13       	cpse	r20, r25
 62c:	00 00       	nop
 62e:	0d 35       	cpi	r16, 0x5D	; 93
 630:	00 49       	sbci	r16, 0x90	; 144
 632:	13 00       	.word	0x0013	; ????
 634:	00 0e       	add	r0, r16
 636:	2e 01       	movw	r4, r28
 638:	03 0e       	add	r0, r19
 63a:	34 0c       	add	r3, r4
 63c:	20 0b       	sbc	r18, r16
 63e:	01 13       	cpse	r16, r17
 640:	00 00       	nop
 642:	0f 2e       	mov	r0, r31
 644:	01 31       	cpi	r16, 0x11	; 17
 646:	13 11       	cpse	r17, r3
 648:	01 12       	cpse	r0, r17
 64a:	01 40       	sbci	r16, 0x01	; 1
 64c:	0a 97       	sbiw	r24, 0x0a	; 10
 64e:	42 0c       	add	r4, r2
 650:	01 13       	cpse	r16, r17
 652:	00 00       	nop
 654:	10 05       	cpc	r17, r0
 656:	00 31       	cpi	r16, 0x10	; 16
 658:	13 02       	muls	r17, r19
 65a:	0a 00       	.word	0x000a	; ????
 65c:	00 11       	cpse	r16, r0
 65e:	34 00       	.word	0x0034	; ????
 660:	31 13       	cpse	r19, r17
 662:	02 06       	cpc	r0, r18
 664:	00 00       	nop
 666:	12 05       	cpc	r17, r2
 668:	00 31       	cpi	r16, 0x10	; 16
 66a:	13 1c       	adc	r1, r3
 66c:	0b 00       	.word	0x000b	; ????
 66e:	00 13       	cpse	r16, r16
 670:	0b 01       	movw	r0, r22
 672:	31 13       	cpse	r19, r17
 674:	11 01       	movw	r2, r2
 676:	12 01       	movw	r2, r4
 678:	01 13       	cpse	r16, r17
 67a:	00 00       	nop
 67c:	14 1d       	adc	r17, r4
 67e:	01 31       	cpi	r16, 0x11	; 17
 680:	13 52       	subi	r17, 0x23	; 35
 682:	01 55       	subi	r16, 0x51	; 81
 684:	06 58       	subi	r16, 0x86	; 134
 686:	0b 59       	subi	r16, 0x9B	; 155
 688:	0b 01       	movw	r0, r22
 68a:	13 00       	.word	0x0013	; ????
 68c:	00 15       	cp	r16, r0
 68e:	05 00       	.word	0x0005	; ????
 690:	31 13       	cpse	r19, r17
 692:	02 06       	cpc	r0, r18
 694:	00 00       	nop
 696:	16 0b       	sbc	r17, r22
 698:	01 11       	cpse	r16, r1
 69a:	01 12       	cpse	r0, r17
 69c:	01 00       	.word	0x0001	; ????
 69e:	00 17       	cp	r16, r16
 6a0:	34 00       	.word	0x0034	; ????
 6a2:	31 13       	cpse	r19, r17
 6a4:	00 00       	nop
 6a6:	18 0b       	sbc	r17, r24
 6a8:	01 31       	cpi	r16, 0x11	; 17
 6aa:	13 11       	cpse	r17, r3
 6ac:	01 12       	cpse	r0, r17
 6ae:	01 00       	.word	0x0001	; ????
 6b0:	00 19       	sub	r16, r0
 6b2:	2e 01       	movw	r4, r28
 6b4:	3f 0c       	add	r3, r15
 6b6:	03 0e       	add	r0, r19
 6b8:	3a 0b       	sbc	r19, r26
 6ba:	3b 0b       	sbc	r19, r27
 6bc:	11 01       	movw	r2, r2
 6be:	12 01       	movw	r2, r4
 6c0:	40 06       	cpc	r4, r16
 6c2:	97 42       	sbci	r25, 0x27	; 39
 6c4:	0c 01       	movw	r0, r24
 6c6:	13 00       	.word	0x0013	; ????
 6c8:	00 1a       	sub	r0, r16
 6ca:	34 00       	.word	0x0034	; ????
 6cc:	03 08       	sbc	r0, r3
 6ce:	3a 0b       	sbc	r19, r26
 6d0:	3b 0b       	sbc	r19, r27
 6d2:	49 13       	cpse	r20, r25
 6d4:	02 06       	cpc	r0, r18
 6d6:	00 00       	nop
 6d8:	1b 2e       	mov	r1, r27
 6da:	00 03       	mulsu	r16, r16
 6dc:	0e 3a       	cpi	r16, 0xAE	; 174
 6de:	0b 3b       	cpi	r16, 0xBB	; 187
 6e0:	0b 20       	and	r0, r11
 6e2:	0b 00       	.word	0x000b	; ????
 6e4:	00 1c       	adc	r0, r0
 6e6:	2e 01       	movw	r4, r28
 6e8:	3f 0c       	add	r3, r15
 6ea:	03 0e       	add	r0, r19
 6ec:	3a 0b       	sbc	r19, r26
 6ee:	3b 0b       	sbc	r19, r27
 6f0:	49 13       	cpse	r20, r25
 6f2:	87 01       	movw	r16, r14
 6f4:	0c 11       	cpse	r16, r12
 6f6:	01 12       	cpse	r0, r17
 6f8:	01 40       	sbci	r16, 0x01	; 1
 6fa:	0a 97       	sbiw	r24, 0x0a	; 10
 6fc:	42 0c       	add	r4, r2
 6fe:	01 13       	cpse	r16, r17
 700:	00 00       	nop
 702:	1d 1d       	adc	r17, r13
 704:	00 31       	cpi	r16, 0x10	; 16
 706:	13 11       	cpse	r17, r3
 708:	01 12       	cpse	r0, r17
 70a:	01 58       	subi	r16, 0x81	; 129
 70c:	0b 59       	subi	r16, 0x9B	; 155
 70e:	0b 00       	.word	0x000b	; ????
 710:	00 1e       	adc	r0, r16
 712:	1d 01       	movw	r2, r26
 714:	31 13       	cpse	r19, r17
 716:	11 01       	movw	r2, r2
 718:	12 01       	movw	r2, r4
 71a:	58 0b       	sbc	r21, r24
 71c:	59 0b       	sbc	r21, r25
 71e:	01 13       	cpse	r16, r17
 720:	00 00       	nop
 722:	1f 1d       	adc	r17, r15
 724:	01 31       	cpi	r16, 0x11	; 17
 726:	13 11       	cpse	r17, r3
 728:	01 12       	cpse	r0, r17
 72a:	01 58       	subi	r16, 0x81	; 129
 72c:	0b 59       	subi	r16, 0x9B	; 155
 72e:	0b 00       	.word	0x000b	; ????
 730:	00 20       	and	r0, r0
 732:	0b 01       	movw	r0, r22
 734:	31 13       	cpse	r19, r17
 736:	55 06       	cpc	r5, r21
 738:	01 13       	cpse	r16, r17
 73a:	00 00       	nop
 73c:	21 89       	ldd	r18, Z+17	; 0x11
 73e:	82 01       	movw	r16, r4
 740:	01 11       	cpse	r16, r1
 742:	01 31       	cpi	r16, 0x11	; 17
 744:	13 01       	movw	r2, r6
 746:	13 00       	.word	0x0013	; ????
 748:	00 22       	and	r0, r16
 74a:	8a 82       	std	Y+2, r8	; 0x02
 74c:	01 00       	.word	0x0001	; ????
 74e:	02 0a       	sbc	r0, r18
 750:	91 42       	sbci	r25, 0x21	; 33
 752:	0a 00       	.word	0x000a	; ????
 754:	00 23       	and	r16, r16
 756:	89 82       	std	Y+1, r8	; 0x01
 758:	01 01       	movw	r0, r2
 75a:	11 01       	movw	r2, r2
 75c:	31 13       	cpse	r19, r17
 75e:	00 00       	nop
 760:	24 89       	ldd	r18, Z+20	; 0x14
 762:	82 01       	movw	r16, r4
 764:	00 11       	cpse	r16, r0
 766:	01 00       	.word	0x0001	; ????
 768:	00 25       	eor	r16, r0
 76a:	24 00       	.word	0x0024	; ????
 76c:	0b 0b       	sbc	r16, r27
 76e:	3e 0b       	sbc	r19, r30
 770:	03 08       	sbc	r0, r3
 772:	00 00       	nop
 774:	26 01       	movw	r4, r12
 776:	01 49       	sbci	r16, 0x91	; 145
 778:	13 01       	movw	r2, r6
 77a:	13 00       	.word	0x0013	; ????
 77c:	00 27       	eor	r16, r16
 77e:	21 00       	.word	0x0021	; ????
 780:	49 13       	cpse	r20, r25
 782:	2f 0b       	sbc	r18, r31
 784:	00 00       	nop
 786:	28 34       	cpi	r18, 0x48	; 72
 788:	00 03       	mulsu	r16, r16
 78a:	0e 3a       	cpi	r16, 0xAE	; 174
 78c:	0b 3b       	cpi	r16, 0xBB	; 187
 78e:	0b 49       	sbci	r16, 0x9B	; 155
 790:	13 02       	muls	r17, r19
 792:	0a 00       	.word	0x000a	; ????
 794:	00 29       	or	r16, r0
 796:	34 00       	.word	0x0034	; ????
 798:	03 08       	sbc	r0, r3
 79a:	3a 0b       	sbc	r19, r26
 79c:	3b 0b       	sbc	r19, r27
 79e:	49 13       	cpse	r20, r25
 7a0:	02 0a       	sbc	r0, r18
 7a2:	00 00       	nop
 7a4:	00 01       	movw	r0, r0
 7a6:	11 00       	.word	0x0011	; ????
 7a8:	10 06       	cpc	r1, r16
 7aa:	11 01       	movw	r2, r2
 7ac:	12 01       	movw	r2, r4
 7ae:	03 08       	sbc	r0, r3
 7b0:	1b 08       	sbc	r1, r11
 7b2:	25 08       	sbc	r2, r5
 7b4:	13 05       	cpc	r17, r3
 7b6:	00 00       	nop
 7b8:	00 01       	movw	r0, r0
 7ba:	11 00       	.word	0x0011	; ????
 7bc:	10 06       	cpc	r1, r16
 7be:	11 01       	movw	r2, r2
 7c0:	12 01       	movw	r2, r4
 7c2:	03 08       	sbc	r0, r3
 7c4:	1b 08       	sbc	r1, r11
 7c6:	25 08       	sbc	r2, r5
 7c8:	13 05       	cpc	r17, r3
 7ca:	00 00       	nop
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
   0:	16 00       	.word	0x0016	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	10 00       	.word	0x0010	; ????
   8:	00 00       	nop
   a:	02 01       	movw	r0, r4
   c:	fb 0e       	add	r15, r27
   e:	0a 00       	.word	0x000a	; ????
  10:	01 01       	movw	r0, r2
  12:	01 01       	movw	r0, r2
  14:	00 00       	nop
  16:	00 01       	movw	r0, r0
  18:	00 00       	nop
  1a:	e9 03       	fmulsu	r22, r17
  1c:	00 00       	nop
  1e:	02 00       	.word	0x0002	; ????
  20:	cc 01       	movw	r24, r24
  22:	00 00       	nop
  24:	02 01       	movw	r0, r4
  26:	fb 0e       	add	r15, r27
  28:	0a 00       	.word	0x000a	; ????
  2a:	01 01       	movw	r0, r2
  2c:	01 01       	movw	r0, r2
  2e:	00 00       	nop
  30:	00 01       	movw	r0, r0
  32:	43 3a       	cpi	r20, 0xA3	; 163
  34:	5c 50       	subi	r21, 0x0C	; 12
  36:	72 6f       	ori	r23, 0xF2	; 242
  38:	67 72       	andi	r22, 0x27	; 39
  3a:	61 6d       	ori	r22, 0xD1	; 209
  3c:	20 46       	sbci	r18, 0x60	; 96
  3e:	69 6c       	ori	r22, 0xC9	; 201
  40:	65 73       	andi	r22, 0x35	; 53
  42:	20 28       	or	r2, r0
  44:	78 38       	cpi	r23, 0x88	; 136
  46:	36 29       	or	r19, r6
  48:	5c 41       	sbci	r21, 0x1C	; 28
  4a:	72 64       	ori	r23, 0x42	; 66
  4c:	75 69       	ori	r23, 0x95	; 149
  4e:	6e 6f       	ori	r22, 0xFE	; 254
  50:	5c 68       	ori	r21, 0x8C	; 140
  52:	61 72       	andi	r22, 0x21	; 33
  54:	64 77       	andi	r22, 0x74	; 116
  56:	61 72       	andi	r22, 0x21	; 33
  58:	65 5c       	subi	r22, 0xC5	; 197
  5a:	61 72       	andi	r22, 0x21	; 33
  5c:	64 75       	andi	r22, 0x54	; 84
  5e:	69 6e       	ori	r22, 0xE9	; 233
  60:	6f 5c       	subi	r22, 0xCF	; 207
  62:	61 76       	andi	r22, 0x61	; 97
  64:	72 5c       	subi	r23, 0xC2	; 194
  66:	63 6f       	ori	r22, 0xF3	; 243
  68:	72 65       	ori	r23, 0x52	; 82
  6a:	73 5c       	subi	r23, 0xC3	; 195
  6c:	61 72       	andi	r22, 0x21	; 33
  6e:	64 75       	andi	r22, 0x54	; 84
  70:	69 6e       	ori	r22, 0xE9	; 233
  72:	6f 00       	.word	0x006f	; ????
  74:	43 3a       	cpi	r20, 0xA3	; 163
  76:	5c 55       	subi	r21, 0x5C	; 92
  78:	73 65       	ori	r23, 0x53	; 83
  7a:	72 73       	andi	r23, 0x32	; 50
  7c:	5c 52       	subi	r21, 0x2C	; 44
  7e:	59 77       	andi	r21, 0x79	; 121
  80:	6f 72       	andi	r22, 0x2F	; 47
  82:	6b 5c       	subi	r22, 0xCB	; 203
  84:	44 65       	ori	r20, 0x54	; 84
  86:	73 6b       	ori	r23, 0xB3	; 179
  88:	74 6f       	ori	r23, 0xF4	; 244
  8a:	70 5c       	subi	r23, 0xC0	; 192
  8c:	53 70       	andi	r21, 0x03	; 3
  8e:	72 69       	ori	r23, 0x92	; 146
  90:	6e 67       	ori	r22, 0x7E	; 126
  92:	20 31       	cpi	r18, 0x10	; 16
  94:	39 5c       	subi	r19, 0xC9	; 201
  96:	61 73       	andi	r22, 0x31	; 49
  98:	73 69       	ori	r23, 0x93	; 147
  9a:	67 6e       	ori	r22, 0xE7	; 231
  9c:	6d 65       	ori	r22, 0x5D	; 93
  9e:	6e 74       	andi	r22, 0x4E	; 78
  a0:	34 5c       	subi	r19, 0xC4	; 196
  a2:	41 72       	andi	r20, 0x21	; 33
  a4:	64 75       	andi	r22, 0x54	; 84
  a6:	69 6e       	ori	r22, 0xE9	; 233
  a8:	6f 41       	sbci	r22, 0x1F	; 31
  aa:	73 73       	andi	r23, 0x33	; 51
  ac:	65 6d       	ori	r22, 0xD5	; 213
  ae:	62 6c       	ori	r22, 0xC2	; 194
  b0:	79 50       	subi	r23, 0x09	; 9
  b2:	61 72       	andi	r22, 0x21	; 33
  b4:	73 65       	ori	r23, 0x53	; 83
  b6:	72 5c       	subi	r23, 0xC2	; 194
  b8:	50 61       	ori	r21, 0x10	; 16
  ba:	72 73       	andi	r23, 0x32	; 50
  bc:	65 72       	andi	r22, 0x25	; 37
  be:	49 6e       	ori	r20, 0xE9	; 233
  c0:	70 75       	andi	r23, 0x50	; 80
  c2:	74 46       	sbci	r23, 0x64	; 100
  c4:	69 6c       	ori	r22, 0xC9	; 201
  c6:	65 73       	andi	r22, 0x35	; 53
  c8:	5c 52       	subi	r21, 0x2C	; 44
  ca:	61 77       	andi	r22, 0x71	; 113
  cc:	41 72       	andi	r20, 0x21	; 33
  ce:	64 75       	andi	r22, 0x54	; 84
  d0:	69 6e       	ori	r22, 0xE9	; 233
  d2:	6f 46       	sbci	r22, 0x6F	; 111
  d4:	69 6c       	ori	r22, 0xC9	; 201
  d6:	65 73       	andi	r22, 0x35	; 53
  d8:	5c 4c       	sbci	r21, 0xCC	; 204
  da:	41 44       	sbci	r20, 0x41	; 65
  dc:	53 5f       	subi	r21, 0xF3	; 243
  de:	63 6f       	ori	r22, 0xF3	; 243
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	6e 74       	andi	r22, 0x4E	; 78
  e2:	72 6f       	ori	r23, 0xF2	; 242
  e4:	6c 5f       	subi	r22, 0xFC	; 252
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	66 6c       	ori	r22, 0xC6	; 198
  e8:	6f 77       	andi	r22, 0x7F	; 127
  ea:	5f 69       	ori	r21, 0x9F	; 159
	uint8_t port = digitalPinToPort(pin);
  ec:	66 5f       	subi	r22, 0xF6	; 246
  ee:	66 61       	ori	r22, 0x16	; 22
  f0:	6c 73       	andi	r22, 0x3C	; 60
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	65 5f       	subi	r22, 0xF5	; 245
  f4:	6c 6f       	ori	r22, 0xFC	; 252

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	6f 70       	andi	r22, 0x0F	; 15
  f8:	00 63       	ori	r16, 0x30	; 48
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	3a 5c       	subi	r19, 0xCA	; 202
  fc:	70 72       	andi	r23, 0x20	; 32
  fe:	6f 67       	ori	r22, 0x7F	; 127
 100:	72 61       	ori	r23, 0x12	; 18
 102:	6d 20       	and	r6, r13
 104:	66 69       	ori	r22, 0x96	; 150
 106:	6c 65       	ori	r22, 0x5C	; 92

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	73 20       	and	r7, r3
 10a:	28 78       	andi	r18, 0x88	; 136
 10c:	38 36       	cpi	r19, 0x68	; 104
 10e:	29 5c       	subi	r18, 0xC9	; 201
 110:	61 72       	andi	r22, 0x21	; 33
 112:	64 75       	andi	r22, 0x54	; 84
 114:	69 6e       	ori	r22, 0xE9	; 233

	uint8_t oldSREG = SREG;
 116:	6f 5c       	subi	r22, 0xCF	; 207
	cli();
 118:	68 61       	ori	r22, 0x18	; 24

	if (val == LOW) {
		*out &= ~bit;
 11a:	72 64       	ori	r23, 0x42	; 66
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	77 61       	ori	r23, 0x17	; 23
 11e:	72 65       	ori	r23, 0x52	; 82
		*out &= ~bit;
 120:	5c 74       	andi	r21, 0x4C	; 76
 122:	6f 6f       	ori	r22, 0xFF	; 255
	} else {
		*out |= bit;
 124:	6c 73       	andi	r22, 0x3C	; 60
	}

	SREG = oldSREG;
 126:	5c 61       	ori	r21, 0x1C	; 28
}
 128:	76 72       	andi	r23, 0x26	; 38
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	5c 61       	ori	r21, 0x1C	; 28
 12c:	76 72       	andi	r23, 0x26	; 38
 12e:	5c 69       	ori	r21, 0x9C	; 156
 130:	6e 63       	ori	r22, 0x3E	; 62
 132:	6c 75       	andi	r22, 0x5C	; 92
 134:	64 65       	ori	r22, 0x54	; 84
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	00 43       	sbci	r16, 0x30	; 48
 138:	3a 5c       	subi	r19, 0xCA	; 202
 13a:	50 72       	andi	r21, 0x20	; 32
 13c:	6f 67       	ori	r22, 0x7F	; 127
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	72 61       	ori	r23, 0x12	; 18
 140:	6d 20       	and	r6, r13
 142:	46 69       	ori	r20, 0x96	; 150
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	6c 65       	ori	r22, 0x5C	; 92
 146:	73 20       	and	r7, r3
 148:	28 78       	andi	r18, 0x88	; 136
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	38 36       	cpi	r19, 0x68	; 104
 14c:	29 5c       	subi	r18, 0xC9	; 201
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	41 72       	andi	r20, 0x21	; 33
 150:	64 75       	andi	r22, 0x54	; 84
 152:	69 6e       	ori	r22, 0xE9	; 233
 154:	6f 5c       	subi	r22, 0xCF	; 207
 156:	68 61       	ori	r22, 0x18	; 24
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	72 64       	ori	r23, 0x42	; 66
 15a:	77 61       	ori	r23, 0x17	; 23
 15c:	72 65       	ori	r23, 0x52	; 82
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	5c 61       	ori	r21, 0x1C	; 28
 160:	72 64       	ori	r23, 0x42	; 66
 162:	75 69       	ori	r23, 0x95	; 149
 164:	6e 6f       	ori	r22, 0xFE	; 254
 166:	5c 61       	ori	r21, 0x1C	; 28
 168:	76 72       	andi	r23, 0x26	; 38
 16a:	5c 76       	andi	r21, 0x6C	; 108
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	61 72       	andi	r22, 0x21	; 33
 16e:	69 61       	ori	r22, 0x19	; 25
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	6e 74       	andi	r22, 0x4E	; 78
 172:	73 5c       	subi	r23, 0xC3	; 195
 174:	73 74       	andi	r23, 0x43	; 67
 176:	61 6e       	ori	r22, 0xE1	; 225
 178:	64 61       	ori	r22, 0x14	; 20
 17a:	72 64       	ori	r23, 0x42	; 66
 17c:	00 00       	nop
 17e:	77 69       	ori	r23, 0x97	; 151
 180:	72 69       	ori	r23, 0x92	; 146
 182:	6e 67       	ori	r22, 0x7E	; 126
 184:	5f 64       	ori	r21, 0x4F	; 79
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	69 67       	ori	r22, 0x79	; 121
 188:	69 74       	andi	r22, 0x49	; 73
 18a:	61 6c       	ori	r22, 0xC1	; 193
 18c:	2e 63       	ori	r18, 0x3E	; 62
 18e:	00 01       	movw	r0, r0
 190:	00 00       	nop
 192:	77 69       	ori	r23, 0x97	; 151
 194:	72 69       	ori	r23, 0x92	; 146
	unsigned char f = timer0_fract;
 196:	6e 67       	ori	r22, 0x7E	; 126
 198:	2e 63       	ori	r18, 0x3E	; 62

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	00 01       	movw	r0, r0
 19c:	00 00       	nop
	if (f >= FRACT_MAX) {
 19e:	6d 61       	ori	r22, 0x1D	; 29
 1a0:	69 6e       	ori	r22, 0xE9	; 233
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	2e 63       	ori	r18, 0x3E	; 62
 1a4:	70 70       	andi	r23, 0x00	; 0
 1a6:	00 01       	movw	r0, r0
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	00 00       	nop
 1aa:	4c 41       	sbci	r20, 0x1C	; 28
	timer0_millis = m;
 1ac:	44 53       	subi	r20, 0x34	; 52
 1ae:	5f 63       	ori	r21, 0x3F	; 63
 1b0:	6f 6e       	ori	r22, 0xEF	; 239
 1b2:	74 72       	andi	r23, 0x24	; 36
 1b4:	6f 6c       	ori	r22, 0xCF	; 207
 1b6:	5f 66       	ori	r21, 0x6F	; 111
 1b8:	6c 6f       	ori	r22, 0xFC	; 252
 1ba:	77 5f       	subi	r23, 0xF7	; 247
	timer0_overflow_count++;
 1bc:	69 66       	ori	r22, 0x69	; 105
 1be:	5f 66       	ori	r21, 0x6F	; 111
 1c0:	61 6c       	ori	r22, 0xC1	; 193
 1c2:	73 65       	ori	r23, 0x53	; 83
 1c4:	5f 6c       	ori	r21, 0xCF	; 207
 1c6:	6f 6f       	ori	r22, 0xFF	; 255
 1c8:	70 2e       	mov	r7, r16
 1ca:	69 6e       	ori	r22, 0xE9	; 233
 1cc:	6f 00       	.word	0x006f	; ????
 1ce:	02 00       	.word	0x0002	; ????
 1d0:	00 73       	andi	r16, 0x30	; 48
 1d2:	74 64       	ori	r23, 0x44	; 68
 1d4:	69 6e       	ori	r22, 0xE9	; 233
 1d6:	74 2e       	mov	r7, r20
 1d8:	68 00       	.word	0x0068	; ????
 1da:	03 00       	.word	0x0003	; ????
 1dc:	00 70       	andi	r16, 0x00	; 0
 1de:	69 6e       	ori	r22, 0xE9	; 233
 1e0:	73 5f       	subi	r23, 0xF3	; 243
}
 1e2:	61 72       	andi	r22, 0x21	; 33
 1e4:	64 75       	andi	r22, 0x54	; 84
 1e6:	69 6e       	ori	r22, 0xE9	; 233
 1e8:	6f 2e       	mov	r6, r31
 1ea:	68 00       	.word	0x0068	; ????
 1ec:	04 00       	.word	0x0004	; ????
 1ee:	00 00       	nop
 1f0:	00 05       	cpc	r16, r0
 1f2:	02 e0       	ldi	r16, 0x02	; 2
 1f4:	00 00       	nop
 1f6:	00 03       	mulsu	r16, r16
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	89 01       	movw	r16, r18
 1fa:	01 03       	mulsu	r16, r17
		m += 1;
 1fc:	02 09       	sbc	r16, r2
 1fe:	00 00       	nop
 200:	01 03       	mulsu	r16, r17
 202:	01 09       	sbc	r16, r1

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	06 00       	.word	0x0006	; ????
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	01 03       	mulsu	r16, r17
 208:	01 09       	sbc	r16, r1
 20a:	06 00       	.word	0x0006	; ????
	sbi(TCCR0A, WGM00);
 20c:	01 03       	mulsu	r16, r17
 20e:	03 09       	sbc	r16, r3
 210:	06 00       	.word	0x0006	; ????
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	01 03       	mulsu	r16, r17
 214:	04 09       	sbc	r16, r4
 216:	04 00       	.word	0x0004	; ????
	sbi(TCCR0B, CS00);
 218:	01 03       	mulsu	r16, r17
 21a:	b8 7f       	andi	r27, 0xF8	; 248
 21c:	09 04       	cpc	r0, r9

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 01       	movw	r0, r0
 220:	03 ca       	rjmp	.-3066   	; 0xfffff628 <__eeprom_end+0xff7ef628>
 222:	00 09       	sbc	r16, r0
 224:	0e 00       	.word	0x000e	; ????
 226:	01 03       	mulsu	r16, r17
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	02 09       	sbc	r16, r2
 22a:	0e 00       	.word	0x000e	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	01 03       	mulsu	r16, r17
 22e:	01 09       	sbc	r16, r1
 230:	02 00       	.word	0x0002	; ????
 232:	01 03       	mulsu	r16, r17
 234:	03 09       	sbc	r16, r3
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	02 00       	.word	0x0002	; ????
 238:	01 03       	mulsu	r16, r17
 23a:	7f 09       	sbc	r23, r15
 23c:	02 00       	.word	0x0002	; ????
 23e:	01 03       	mulsu	r16, r17
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	01 09       	sbc	r16, r1
 242:	04 00       	.word	0x0004	; ????
 244:	01 03       	mulsu	r16, r17
 246:	02 09       	sbc	r16, r2
 248:	04 00       	.word	0x0004	; ????

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	01 03       	mulsu	r16, r17
 24c:	03 09       	sbc	r16, r3
 24e:	02 00       	.word	0x0002	; ????
 250:	01 03       	mulsu	r16, r17
 252:	01 09       	sbc	r16, r1

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	02 00       	.word	0x0002	; ????
 256:	01 03       	mulsu	r16, r17
 258:	aa 7f       	andi	r26, 0xFA	; 250
 25a:	09 02       	muls	r16, r25
 25c:	00 01       	movw	r0, r0
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	03 06       	cpc	r0, r19
 260:	09 0c       	add	r0, r9
 262:	00 01       	movw	r0, r0
 264:	03 7d       	andi	r16, 0xD3	; 211
 266:	09 08       	sbc	r0, r9
		sbi(ADCSRA, ADPS1);
 268:	00 01       	movw	r0, r0
 26a:	03 03       	mulsu	r16, r19
 26c:	09 06       	cpc	r0, r25
 26e:	00 01       	movw	r0, r0
 270:	03 0b       	sbc	r16, r19
		sbi(ADCSRA, ADPS0);
 272:	09 06       	cpc	r0, r25
 274:	00 01       	movw	r0, r0
 276:	03 04       	cpc	r0, r3
 278:	09 04       	cpc	r0, r9
 27a:	00 01       	movw	r0, r0
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	03 03       	mulsu	r16, r19
 27e:	09 0a       	sbc	r0, r25
 280:	00 01       	movw	r0, r0
 282:	03 03       	mulsu	r16, r19
 284:	09 06       	cpc	r0, r25
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	00 01       	movw	r0, r0
 288:	03 37       	cpi	r16, 0x73	; 115
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	09 0e       	add	r0, r25
 28c:	00 01       	movw	r0, r0
 28e:	04 02       	muls	r16, r20
	uint8_t port = digitalPinToPort(pin);
 290:	03 90       	.word	0x9003	; ????
 292:	7f 09       	sbc	r23, r15
 294:	04 00       	.word	0x0004	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	01 03       	mulsu	r16, r17
 298:	03 09       	sbc	r16, r3

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	16 00       	.word	0x0016	; ????
 29c:	01 03       	mulsu	r16, r17
 29e:	01 09       	sbc	r16, r1
 2a0:	10 00       	.word	0x0010	; ????
 2a2:	01 03       	mulsu	r16, r17
 2a4:	03 09       	sbc	r16, r3
 2a6:	04 00       	.word	0x0004	; ????
 2a8:	01 03       	mulsu	r16, r17
	out = portOutputRegister(port);
 2aa:	01 09       	sbc	r16, r1
 2ac:	04 00       	.word	0x0004	; ????
 2ae:	01 03       	mulsu	r16, r17
 2b0:	7e 09       	sbc	r23, r14
 2b2:	04 00       	.word	0x0004	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	01 03       	mulsu	r16, r17
                cli();
 2b6:	07 09       	sbc	r16, r7
		*reg |= bit;
 2b8:	06 00       	.word	0x0006	; ????
 2ba:	01 03       	mulsu	r16, r17
 2bc:	01 09       	sbc	r16, r1
		SREG = oldSREG;
 2be:	04 00       	.word	0x0004	; ????
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	01 03       	mulsu	r16, r17
 2c2:	01 09       	sbc	r16, r1
 2c4:	10 00       	.word	0x0010	; ????
 2c6:	01 03       	mulsu	r16, r17
 2c8:	01 09       	sbc	r16, r1
 2ca:	26 00       	.word	0x0026	; ????
 2cc:	01 03       	mulsu	r16, r17
 2ce:	79 09       	sbc	r23, r9
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	16 00       	.word	0x0016	; ????
 2d2:	01 03       	mulsu	r16, r17
 2d4:	01 09       	sbc	r16, r1
 2d6:	04 00       	.word	0x0004	; ????
 2d8:	01 09       	sbc	r16, r1
 2da:	08 00       	.word	0x0008	; ????

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	00 01       	movw	r0, r0
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	01 04       	cpc	r0, r1
 2e0:	03 00       	.word	0x0003	; ????
 2e2:	05 02       	muls	r16, r21
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	04 02       	muls	r16, r20
 2e6:	00 00       	nop
 2e8:	03 21       	and	r16, r3
 2ea:	01 04       	cpc	r0, r1
 2ec:	02 03       	mulsu	r16, r18
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	d3 01       	movw	r26, r6
 2f0:	09 00       	.word	0x0009	; ????
 2f2:	00 01       	movw	r0, r0
 2f4:	03 06       	cpc	r0, r19
 2f6:	09 02       	muls	r16, r25
 2f8:	00 01       	movw	r0, r0
 2fa:	03 01       	movw	r0, r6
 2fc:	09 06       	cpc	r0, r25
    b = 0xffffffff; 
 2fe:	00 01       	movw	r0, r0
 300:	03 0d       	add	r16, r3
 302:	09 06       	cpc	r0, r25
 304:	00 01       	movw	r0, r0
 306:	03 01       	movw	r0, r6
 308:	09 06       	cpc	r0, r25
 30a:	00 01       	movw	r0, r0
 30c:	03 0d       	add	r16, r3
    a |= b;
 30e:	09 06       	cpc	r0, r25
 310:	00 01       	movw	r0, r0
 312:	03 0b       	sbc	r16, r19
 314:	09 0a       	sbc	r0, r25
 316:	00 01       	movw	r0, r0
 318:	03 03       	mulsu	r16, r19
 31a:	09 04       	cpc	r0, r9
 31c:	00 01       	movw	r0, r0
 31e:	03 02       	muls	r16, r19
 320:	09 0a       	sbc	r0, r25
 322:	00 01       	movw	r0, r0
 324:	03 0a       	sbc	r0, r19
 326:	09 0a       	sbc	r0, r25
 328:	00 01       	movw	r0, r0
 32a:	03 07       	cpc	r16, r19
 32c:	09 0a       	sbc	r0, r25
 32e:	00 01       	movw	r0, r0
 330:	03 09       	sbc	r16, r3
 332:	09 0a       	sbc	r0, r25
 334:	00 01       	movw	r0, r0
 336:	03 23       	and	r16, r19
 338:	09 0a       	sbc	r0, r25
 33a:	00 01       	movw	r0, r0
 33c:	03 01       	movw	r0, r6
 33e:	09 0a       	sbc	r0, r25
 340:	00 01       	movw	r0, r0
 342:	03 01       	movw	r0, r6
 344:	09 0a       	sbc	r0, r25
    b = 0x00000000;
 346:	00 01       	movw	r0, r0
 348:	03 17       	cp	r16, r19
 34a:	09 0a       	sbc	r0, r25
 34c:	00 01       	movw	r0, r0
 34e:	03 09       	sbc	r16, r3
 350:	09 0a       	sbc	r0, r25
 352:	00 01       	movw	r0, r0
 354:	04 01       	movw	r0, r8
    if(x){
 356:	03 99       	sbic	0x00, 3	; 0
 358:	7d 09       	sbc	r23, r13
 35a:	04 00       	.word	0x0004	; ????
 35c:	01 03       	mulsu	r16, r17
 35e:	01 09       	sbc	r16, r1
 360:	06 00       	.word	0x0006	; ????
 362:	01 03       	mulsu	r16, r17
 364:	03 09       	sbc	r16, r3
 366:	06 00       	.word	0x0006	; ????
 368:	01 03       	mulsu	r16, r17
 36a:	03 09       	sbc	r16, r3
 36c:	04 00       	.word	0x0004	; ????
      //a &= b;
      b = 0xffffffff; 
 36e:	01 03       	mulsu	r16, r17
 370:	01 09       	sbc	r16, r1
 372:	10 00       	.word	0x0010	; ????
 374:	01 03       	mulsu	r16, r17
 376:	0f 09       	sbc	r16, r15
 378:	0a 00       	.word	0x000a	; ????
 37a:	01 03       	mulsu	r16, r17
 37c:	01 09       	sbc	r16, r1
      //a = a^b;
    }
    a &= b;
 37e:	02 00       	.word	0x0002	; ????
 380:	01 03       	mulsu	r16, r17
 382:	01 09       	sbc	r16, r1
 384:	02 00       	.word	0x0002	; ????
 386:	01 03       	mulsu	r16, r17
 388:	01 09       	sbc	r16, r1
 38a:	06 00       	.word	0x0006	; ????
 38c:	01 04       	cpc	r0, r1
 38e:	04 03       	mulsu	r16, r20
 390:	50 09       	sbc	r21, r0
 392:	02 00       	.word	0x0002	; ????
 394:	01 03       	mulsu	r16, r17
 396:	0d 09       	sbc	r16, r13
 398:	10 00       	.word	0x0010	; ????
 39a:	01 04       	cpc	r0, r1
 39c:	03 03       	mulsu	r16, r19
 39e:	19 09       	sbc	r17, r9
 3a0:	08 00       	.word	0x0008	; ????
 3a2:	01 04       	cpc	r0, r1
 3a4:	04 03       	mulsu	r16, r20
 3a6:	61 09       	sbc	r22, r1
 3a8:	04 00       	.word	0x0004	; ????
 3aa:	01 03       	mulsu	r16, r17
 3ac:	01 09       	sbc	r16, r1
 3ae:	02 00       	.word	0x0002	; ????
 3b0:	01 03       	mulsu	r16, r17
 3b2:	01 09       	sbc	r16, r1
 3b4:	06 00       	.word	0x0006	; ????
    b = 0xffffffff; 
 3b6:	01 03       	mulsu	r16, r17
 3b8:	03 09       	sbc	r16, r3
 3ba:	0a 00       	.word	0x000a	; ????
 3bc:	01 03       	mulsu	r16, r17
 3be:	01 09       	sbc	r16, r1
 3c0:	10 00       	.word	0x0010	; ????
 3c2:	01 03       	mulsu	r16, r17
 3c4:	01 09       	sbc	r16, r1
    a = a^b;
 3c6:	10 00       	.word	0x0010	; ????
 3c8:	01 03       	mulsu	r16, r17
 3ca:	01 09       	sbc	r16, r1
 3cc:	38 00       	.word	0x0038	; ????
 3ce:	01 03       	mulsu	r16, r17
 3d0:	01 09       	sbc	r16, r1
 3d2:	10 00       	.word	0x0010	; ????
 3d4:	01 03       	mulsu	r16, r17
 3d6:	02 09       	sbc	r16, r2
 3d8:	18 00       	.word	0x0018	; ????
 3da:	01 03       	mulsu	r16, r17
 3dc:	03 09       	sbc	r16, r3
 3de:	10 00       	.word	0x0010	; ????
 3e0:	01 03       	mulsu	r16, r17
 3e2:	01 09       	sbc	r16, r1
 3e4:	38 00       	.word	0x0038	; ????
 3e6:	01 03       	mulsu	r16, r17
 3e8:	01 09       	sbc	r16, r1
 3ea:	10 00       	.word	0x0010	; ????
 3ec:	01 03       	mulsu	r16, r17
 3ee:	74 09       	sbc	r23, r4
 3f0:	3a 00       	.word	0x003a	; ????
 3f2:	01 03       	mulsu	r16, r17
 3f4:	11 09       	sbc	r17, r1
 3f6:	04 00       	.word	0x0004	; ????
 3f8:	01 04       	cpc	r0, r1
 3fa:	03 03       	mulsu	r16, r19
 3fc:	0a 09       	sbc	r16, r10
 3fe:	02 00       	.word	0x0002	; ????
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	01 09       	sbc	r16, r1
 402:	0c 00       	.word	0x000c	; ????
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	00 01       	movw	r0, r0
 406:	01 5e       	subi	r16, 0xE1	; 225
 408:	00 00       	nop
 40a:	00 02       	muls	r16, r16
 40c:	00 41       	sbci	r16, 0x10	; 16
 40e:	00 00       	nop
 410:	00 02       	muls	r16, r16
 412:	01 fb       	bst	r16, 1
 414:	0e 0a       	sbc	r0, r30
 416:	00 01       	movw	r0, r0
 418:	01 01       	movw	r0, r2
 41a:	01 00       	.word	0x0001	; ????
 41c:	00 00       	nop
 41e:	01 2e       	mov	r0, r17
 420:	2e 2f       	mov	r18, r30
 422:	2e 2e       	mov	r2, r30
 424:	2f 2e       	mov	r2, r31
 426:	2e 2f       	mov	r18, r30
 428:	2e 2e       	mov	r2, r30
 42a:	2f 67       	ori	r18, 0x7F	; 127
 42c:	63 63       	ori	r22, 0x33	; 51
 42e:	2f 6c       	ori	r18, 0xCF	; 207
 430:	69 62       	ori	r22, 0x29	; 41
 432:	67 63       	ori	r22, 0x37	; 55
 434:	63 2f       	mov	r22, r19
 436:	63 6f       	ori	r22, 0xF3	; 243
 438:	6e 66       	ori	r22, 0x6E	; 110
 43a:	69 67       	ori	r22, 0x79	; 121
 43c:	2f 61       	ori	r18, 0x1F	; 31
 43e:	76 72       	andi	r23, 0x26	; 38
 440:	00 00       	nop
 442:	6c 69       	ori	r22, 0x9C	; 156
 444:	62 31       	cpi	r22, 0x12	; 18
 446:	66 75       	andi	r22, 0x56	; 86
 448:	6e 63       	ori	r22, 0x3E	; 62
 44a:	73 2e       	mov	r7, r19
 44c:	53 00       	.word	0x0053	; ????
 44e:	01 00       	.word	0x0001	; ????
 450:	00 00       	nop
 452:	00 05       	cpc	r16, r0
 454:	02 12       	cpse	r0, r18
 456:	04 00       	.word	0x0004	; ????
 458:	00 03       	mulsu	r16, r16
 45a:	e5 11       	cpse	r30, r5
 45c:	01 03       	mulsu	r16, r17
 45e:	02 09       	sbc	r16, r2
 460:	02 00       	.word	0x0002	; ????
 462:	01 09       	sbc	r16, r1
 464:	02 00       	.word	0x0002	; ????
 466:	00 01       	movw	r0, r0
 468:	01 82       	std	Z+1, r0	; 0x01
 46a:	00 00       	nop
 46c:	00 02       	muls	r16, r16
 46e:	00 41       	sbci	r16, 0x10	; 16
 470:	00 00       	nop
 472:	00 02       	muls	r16, r16
 474:	01 fb       	bst	r16, 1
 476:	0e 0a       	sbc	r0, r30
 478:	00 01       	movw	r0, r0
 47a:	01 01       	movw	r0, r2
 47c:	01 00       	.word	0x0001	; ????
 47e:	00 00       	nop
 480:	01 2e       	mov	r0, r17
 482:	2e 2f       	mov	r18, r30
 484:	2e 2e       	mov	r2, r30
 486:	2f 2e       	mov	r2, r31
 488:	2e 2f       	mov	r18, r30
 48a:	2e 2e       	mov	r2, r30
 48c:	2f 67       	ori	r18, 0x7F	; 127
 48e:	63 63       	ori	r22, 0x33	; 51
 490:	2f 6c       	ori	r18, 0xCF	; 207
 492:	69 62       	ori	r22, 0x29	; 41
 494:	67 63       	ori	r22, 0x37	; 55
 496:	63 2f       	mov	r22, r19
 498:	63 6f       	ori	r22, 0xF3	; 243
 49a:	6e 66       	ori	r22, 0x6E	; 110
 49c:	69 67       	ori	r22, 0x79	; 121
 49e:	2f 61       	ori	r18, 0x1F	; 31
 4a0:	76 72       	andi	r23, 0x26	; 38
 4a2:	00 00       	nop
 4a4:	6c 69       	ori	r22, 0x9C	; 156
 4a6:	62 31       	cpi	r22, 0x12	; 18
 4a8:	66 75       	andi	r22, 0x56	; 86
 4aa:	6e 63       	ori	r22, 0x3E	; 62
 4ac:	73 2e       	mov	r7, r19
 4ae:	53 00       	.word	0x0053	; ????
 4b0:	01 00       	.word	0x0001	; ????
 4b2:	00 00       	nop
 4b4:	00 05       	cpc	r16, r0
 4b6:	02 c4       	rjmp	.+2052   	; 0xcbc <__stack+0x3bd>
 4b8:	00 00       	nop
 4ba:	00 03       	mulsu	r16, r16
 4bc:	88 13       	cpse	r24, r24
 4be:	01 03       	mulsu	r16, r17
 4c0:	01 09       	sbc	r16, r1
 4c2:	02 00       	.word	0x0002	; ????
 4c4:	01 03       	mulsu	r16, r17
 4c6:	01 09       	sbc	r16, r1
 4c8:	02 00       	.word	0x0002	; ????
 4ca:	01 03       	mulsu	r16, r17
 4cc:	01 09       	sbc	r16, r1
 4ce:	02 00       	.word	0x0002	; ????
 4d0:	01 03       	mulsu	r16, r17
 4d2:	02 09       	sbc	r16, r2
 4d4:	02 00       	.word	0x0002	; ????
 4d6:	01 03       	mulsu	r16, r17
 4d8:	02 09       	sbc	r16, r2
 4da:	02 00       	.word	0x0002	; ????
 4dc:	01 03       	mulsu	r16, r17
 4de:	01 09       	sbc	r16, r1
 4e0:	02 00       	.word	0x0002	; ????
 4e2:	01 03       	mulsu	r16, r17
 4e4:	01 09       	sbc	r16, r1
 4e6:	02 00       	.word	0x0002	; ????
 4e8:	01 09       	sbc	r16, r1
 4ea:	02 00       	.word	0x0002	; ????
 4ec:	00 01       	movw	r0, r0
 4ee:	01 49       	Address 0x000004ee is out of bounds.
.word	0xffff	; ????

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	10 00       	.word	0x0010	; ????
   2:	00 00       	nop
   4:	ff ff       	.word	0xffff	; ????
   6:	ff ff       	.word	0xffff	; ????
   8:	01 00       	.word	0x0001	; ????
   a:	02 7f       	andi	r16, 0xF2	; 242
   c:	24 0c       	add	r2, r4
   e:	20 02       	muls	r18, r16
  10:	a4 01       	movw	r20, r8
  12:	00 00       	nop
  14:	0c 00       	.word	0x000c	; ????
  16:	00 00       	nop
  18:	00 00       	nop
  1a:	00 00       	nop
  1c:	e0 00       	.word	0x00e0	; ????
  1e:	00 00       	nop
  20:	90 00       	.word	0x0090	; ????
  22:	00 00       	nop
  24:	34 00       	.word	0x0034	; ????
  26:	00 00       	nop
  28:	00 00       	nop
  2a:	00 00       	nop
  2c:	70 01       	movw	r14, r0
  2e:	00 00       	nop
  30:	94 00       	.word	0x0094	; ????
  32:	00 00       	nop
  34:	41 0e       	add	r4, r17
  36:	03 81       	ldd	r16, Z+3	; 0x03
  38:	02 41       	sbci	r16, 0x12	; 18
  3a:	0e 04       	cpc	r0, r14
  3c:	80 03       	fmuls	r16, r16
  3e:	44 0e       	add	r4, r20
  40:	05 92       	las	Z, r0
  42:	04 41       	sbci	r16, 0x14	; 20
  44:	0e 06       	cpc	r0, r30
  46:	93 05       	cpc	r25, r3
  48:	41 0e       	add	r4, r17
  4a:	07 98       	cbi	0x00, 7	; 0
  4c:	06 41       	sbci	r16, 0x16	; 22
  4e:	0e 08       	sbc	r0, r14
  50:	99 07       	cpc	r25, r25
  52:	41 0e       	add	r4, r17
  54:	09 9a       	sbi	0x01, 1	; 1
  56:	08 41       	sbci	r16, 0x18	; 24
  58:	0e 0a       	sbc	r0, r30
  5a:	9b 09       	sbc	r25, r11
  5c:	0c 00       	.word	0x000c	; ????
  5e:	00 00       	nop
  60:	00 00       	nop
  62:	00 00       	nop
  64:	04 02       	muls	r16, r20
  66:	00 00       	nop
  68:	0e 02       	muls	r16, r30
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	61 76       	andi	r22, 0x61	; 97
   2:	72 2d       	mov	r23, r2
   4:	6c 69       	ori	r22, 0x9C	; 156
   6:	62 63       	ori	r22, 0x32	; 50
   8:	20 32       	cpi	r18, 0x20	; 32
   a:	2e 30       	cpi	r18, 0x0E	; 14
   c:	2e 30       	cpi	r18, 0x0E	; 14
   e:	00 75       	andi	r16, 0x50	; 80
  10:	69 6e       	ori	r22, 0xE9	; 233
  12:	74 38       	cpi	r23, 0x84	; 132
  14:	5f 74       	andi	r21, 0x4F	; 79
  16:	00 75       	andi	r16, 0x50	; 80
  18:	69 6e       	ori	r22, 0xE9	; 233
  1a:	74 31       	cpi	r23, 0x14	; 20
  1c:	36 5f       	subi	r19, 0xF6	; 246
  1e:	74 00       	.word	0x0074	; ????
  20:	5f 5f       	subi	r21, 0xFF	; 255
  22:	65 65       	ori	r22, 0x55	; 85
  24:	70 72       	andi	r23, 0x20	; 32
  26:	6f 6d       	ori	r22, 0xDF	; 223
  28:	00 55       	subi	r16, 0x50	; 80
  2a:	44 52       	subi	r20, 0x24	; 36
  2c:	30 00       	.word	0x0030	; ????
  2e:	55 43       	sbci	r21, 0x35	; 53
  30:	53 52       	subi	r21, 0x23	; 35
  32:	30 41       	sbci	r19, 0x10	; 16
  34:	00 55       	subi	r16, 0x50	; 80
  36:	43 53       	subi	r20, 0x33	; 51
  38:	52 30       	cpi	r21, 0x02	; 2
  3a:	42 00       	.word	0x0042	; ????
  3c:	55 43       	sbci	r21, 0x35	; 53
  3e:	53 52       	subi	r21, 0x23	; 35
  40:	30 43       	sbci	r19, 0x30	; 48
  42:	00 55       	subi	r16, 0x50	; 80
  44:	42 52       	subi	r20, 0x22	; 34
  46:	52 30       	cpi	r21, 0x02	; 2
  48:	00 54       	subi	r16, 0x40	; 64
  4a:	57 41       	sbci	r21, 0x17	; 23
  4c:	4d 52       	subi	r20, 0x2D	; 45
  4e:	00 54       	subi	r16, 0x40	; 64
  50:	57 42       	sbci	r21, 0x27	; 39
  52:	52 00       	.word	0x0052	; ????
  54:	54 57       	subi	r21, 0x74	; 116
  56:	43 52       	subi	r20, 0x23	; 35
  58:	00 54       	subi	r16, 0x40	; 64
  5a:	57 53       	subi	r21, 0x37	; 55
  5c:	52 00       	.word	0x0052	; ????
  5e:	54 57       	subi	r21, 0x74	; 116
  60:	44 52       	subi	r20, 0x24	; 36
  62:	00 54       	subi	r16, 0x40	; 64
  64:	57 41       	sbci	r21, 0x17	; 23
  66:	52 00       	.word	0x0052	; ????
  68:	54 49       	sbci	r21, 0x94	; 148
  6a:	4d 53       	subi	r20, 0x3D	; 61
  6c:	4b 31       	cpi	r20, 0x1B	; 27
  6e:	00 54       	subi	r16, 0x40	; 64
  70:	49 46       	sbci	r20, 0x69	; 105
  72:	52 31       	cpi	r21, 0x12	; 18
  74:	00 54       	subi	r16, 0x40	; 64
  76:	43 43       	sbci	r20, 0x33	; 51
  78:	52 31       	cpi	r21, 0x12	; 18
  7a:	41 00       	.word	0x0041	; ????
  7c:	54 43       	sbci	r21, 0x34	; 52
  7e:	43 52       	subi	r20, 0x23	; 35
  80:	31 42       	sbci	r19, 0x21	; 33
  82:	00 54       	subi	r16, 0x40	; 64
  84:	43 43       	sbci	r20, 0x33	; 51
  86:	52 31       	cpi	r21, 0x12	; 18
  88:	43 00       	.word	0x0043	; ????
  8a:	54 43       	sbci	r21, 0x34	; 52
  8c:	4e 54       	subi	r20, 0x4E	; 78
  8e:	31 00       	.word	0x0031	; ????
  90:	4f 43       	sbci	r20, 0x3F	; 63
  92:	52 31       	cpi	r21, 0x12	; 18
  94:	41 00       	.word	0x0041	; ????
  96:	4f 43       	sbci	r20, 0x3F	; 63
  98:	52 31       	cpi	r21, 0x12	; 18
  9a:	42 00       	.word	0x0042	; ????
  9c:	49 43       	sbci	r20, 0x39	; 57
  9e:	52 31       	cpi	r21, 0x12	; 18
  a0:	00 47       	sbci	r16, 0x70	; 112
  a2:	54 43       	sbci	r21, 0x34	; 52
  a4:	43 52       	subi	r20, 0x23	; 35
  a6:	00 54       	subi	r16, 0x40	; 64
  a8:	49 4d       	sbci	r20, 0xD9	; 217
  aa:	53 4b       	sbci	r21, 0xB3	; 179
  ac:	32 00       	.word	0x0032	; ????
  ae:	54 49       	sbci	r21, 0x94	; 148
  b0:	46 52       	subi	r20, 0x26	; 38
  b2:	32 00       	.word	0x0032	; ????
  b4:	54 43       	sbci	r21, 0x34	; 52
  b6:	43 52       	subi	r20, 0x23	; 35
  b8:	32 41       	sbci	r19, 0x12	; 18
  ba:	00 54       	subi	r16, 0x40	; 64
  bc:	43 43       	sbci	r20, 0x33	; 51
  be:	52 32       	cpi	r21, 0x22	; 34
  c0:	42 00       	.word	0x0042	; ????
  c2:	54 43       	sbci	r21, 0x34	; 52
  c4:	4e 54       	subi	r20, 0x4E	; 78
  c6:	32 00       	.word	0x0032	; ????
  c8:	4f 43       	sbci	r20, 0x3F	; 63
  ca:	52 32       	cpi	r21, 0x22	; 34
  cc:	42 00       	.word	0x0042	; ????
  ce:	4f 43       	sbci	r20, 0x3F	; 63
  d0:	52 32       	cpi	r21, 0x22	; 34
  d2:	41 00       	.word	0x0041	; ????
  d4:	41 53       	subi	r20, 0x31	; 49
  d6:	53 52       	subi	r21, 0x23	; 35
  d8:	00 47       	sbci	r16, 0x70	; 112
  da:	54 43       	sbci	r21, 0x34	; 52
  dc:	43 52       	subi	r20, 0x23	; 35
  de:	00 41       	sbci	r16, 0x10	; 16
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	44 4d       	sbci	r20, 0xD4	; 212
  e2:	55 58       	subi	r21, 0x85	; 133
  e4:	00 41       	sbci	r16, 0x10	; 16
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	44 43       	sbci	r20, 0x34	; 52
  e8:	00 41       	sbci	r16, 0x10	; 16
  ea:	44 43       	sbci	r20, 0x34	; 52
	uint8_t port = digitalPinToPort(pin);
  ec:	53 52       	subi	r21, 0x23	; 35
  ee:	41 00       	.word	0x0041	; ????
  f0:	41 44       	sbci	r20, 0x41	; 65
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	43 53       	subi	r20, 0x33	; 51
  f4:	52 42       	sbci	r21, 0x22	; 34

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	00 44       	sbci	r16, 0x40	; 64
  f8:	49 44       	sbci	r20, 0x49	; 73
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	52 30       	cpi	r21, 0x02	; 2
  fc:	00 41       	sbci	r16, 0x10	; 16
  fe:	43 53       	subi	r20, 0x33	; 51
 100:	52 00       	.word	0x0052	; ????
 102:	44 49       	sbci	r20, 0x94	; 148
 104:	44 52       	subi	r20, 0x24	; 36
 106:	31 00       	.word	0x0031	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	50 4f       	sbci	r21, 0xF0	; 240
 10a:	52 54       	subi	r21, 0x42	; 66
 10c:	42 00       	.word	0x0042	; ????
 10e:	44 44       	sbci	r20, 0x44	; 68
 110:	52 42       	sbci	r21, 0x22	; 34
 112:	00 50       	subi	r16, 0x00	; 0
 114:	49 4e       	sbci	r20, 0xE9	; 233

	uint8_t oldSREG = SREG;
 116:	42 00       	.word	0x0042	; ????
	cli();
 118:	50 4f       	sbci	r21, 0xF0	; 240

	if (val == LOW) {
		*out &= ~bit;
 11a:	52 54       	subi	r21, 0x42	; 66
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	43 00       	.word	0x0043	; ????
 11e:	44 44       	sbci	r20, 0x44	; 68
		*out &= ~bit;
 120:	52 43       	sbci	r21, 0x32	; 50
 122:	00 50       	subi	r16, 0x00	; 0
	} else {
		*out |= bit;
 124:	49 4e       	sbci	r20, 0xE9	; 233
	}

	SREG = oldSREG;
 126:	43 00       	.word	0x0043	; ????
}
 128:	50 4f       	sbci	r21, 0xF0	; 240
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	52 54       	subi	r21, 0x42	; 66
 12c:	44 00       	.word	0x0044	; ????
 12e:	44 44       	sbci	r20, 0x44	; 68
 130:	52 44       	sbci	r21, 0x42	; 66
 132:	00 50       	subi	r16, 0x00	; 0
 134:	49 4e       	sbci	r20, 0xE9	; 233
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	44 00       	.word	0x0044	; ????
 138:	4f 43       	sbci	r20, 0x3F	; 63
 13a:	52 30       	cpi	r21, 0x02	; 2
 13c:	42 00       	.word	0x0042	; ????
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	4f 43       	sbci	r20, 0x3F	; 63
 140:	52 30       	cpi	r21, 0x02	; 2
 142:	41 00       	.word	0x0041	; ????
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	54 43       	sbci	r21, 0x34	; 52
 146:	4e 54       	subi	r20, 0x4E	; 78
 148:	30 00       	.word	0x0030	; ????
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	54 43       	sbci	r21, 0x34	; 52
 14c:	43 52       	subi	r20, 0x23	; 35
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	30 42       	sbci	r19, 0x20	; 32
 150:	00 54       	subi	r16, 0x40	; 64
 152:	43 43       	sbci	r20, 0x33	; 51
 154:	52 30       	cpi	r21, 0x02	; 2
 156:	41 00       	.word	0x0041	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	54 49       	sbci	r21, 0x94	; 148
 15a:	4d 53       	subi	r20, 0x3D	; 61
 15c:	4b 30       	cpi	r20, 0x0B	; 11
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	00 54       	subi	r16, 0x40	; 64
 160:	49 46       	sbci	r20, 0x69	; 105
 162:	52 30       	cpi	r21, 0x02	; 2
 164:	00 47       	sbci	r16, 0x70	; 112
 166:	54 43       	sbci	r21, 0x34	; 52
 168:	43 52       	subi	r20, 0x23	; 35
 16a:	00 45       	sbci	r16, 0x50	; 80
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	49 43       	sbci	r20, 0x39	; 57
 16e:	52 41       	sbci	r21, 0x12	; 18
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 45       	sbci	r16, 0x50	; 80
 172:	49 4d       	sbci	r20, 0xD9	; 217
 174:	53 4b       	sbci	r21, 0xB3	; 179
 176:	00 45       	sbci	r16, 0x50	; 80
 178:	49 46       	sbci	r20, 0x69	; 105
 17a:	52 00       	.word	0x0052	; ????
 17c:	50 43       	sbci	r21, 0x30	; 48
 17e:	49 43       	sbci	r20, 0x39	; 57
 180:	52 00       	.word	0x0052	; ????
 182:	50 43       	sbci	r21, 0x30	; 48
 184:	4d 53       	subi	r20, 0x3D	; 61
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	4b 32       	cpi	r20, 0x2B	; 43
 188:	00 50       	subi	r16, 0x00	; 0
 18a:	43 4d       	sbci	r20, 0xD3	; 211
 18c:	53 4b       	sbci	r21, 0xB3	; 179
 18e:	31 00       	.word	0x0031	; ????
 190:	50 43       	sbci	r21, 0x30	; 48
 192:	4d 53       	subi	r20, 0x3D	; 61
 194:	4b 30       	cpi	r20, 0x0B	; 11
	unsigned char f = timer0_fract;
 196:	00 50       	subi	r16, 0x00	; 0
 198:	43 49       	sbci	r20, 0x93	; 147

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	46 52       	subi	r20, 0x26	; 38
 19c:	00 53       	subi	r16, 0x30	; 48
	if (f >= FRACT_MAX) {
 19e:	50 44       	sbci	r21, 0x40	; 64
 1a0:	52 00       	.word	0x0052	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	53 50       	subi	r21, 0x03	; 3
 1a4:	53 52       	subi	r21, 0x23	; 35
 1a6:	00 53       	subi	r16, 0x30	; 48
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	50 43       	sbci	r21, 0x30	; 48
 1aa:	52 00       	.word	0x0052	; ????
	timer0_millis = m;
 1ac:	57 44       	sbci	r21, 0x47	; 71
 1ae:	54 43       	sbci	r21, 0x34	; 52
 1b0:	53 52       	subi	r21, 0x23	; 35
 1b2:	00 50       	subi	r16, 0x00	; 0
 1b4:	52 52       	subi	r21, 0x22	; 34
 1b6:	00 4f       	sbci	r16, 0xF0	; 240
 1b8:	53 43       	sbci	r21, 0x33	; 51
 1ba:	43 41       	sbci	r20, 0x13	; 19
	timer0_overflow_count++;
 1bc:	4c 00       	.word	0x004c	; ????
 1be:	43 4c       	sbci	r20, 0xC3	; 195
 1c0:	4b 50       	subi	r20, 0x0B	; 11
 1c2:	52 00       	.word	0x0052	; ????
 1c4:	53 52       	subi	r21, 0x23	; 35
 1c6:	45 47       	sbci	r20, 0x75	; 117
 1c8:	00 53       	subi	r16, 0x30	; 48
 1ca:	50 00       	.word	0x0050	; ????
 1cc:	53 50       	subi	r21, 0x03	; 3
 1ce:	4d 43       	sbci	r20, 0x3D	; 61
 1d0:	53 52       	subi	r21, 0x23	; 35
 1d2:	00 4d       	sbci	r16, 0xD0	; 208
 1d4:	43 55       	subi	r20, 0x53	; 83
 1d6:	43 52       	subi	r20, 0x23	; 35
 1d8:	00 4d       	sbci	r16, 0xD0	; 208
 1da:	43 55       	subi	r20, 0x53	; 83
 1dc:	53 52       	subi	r21, 0x23	; 35
 1de:	00 53       	subi	r16, 0x30	; 48
 1e0:	4d 43       	sbci	r20, 0x3D	; 61
}
 1e2:	52 00       	.word	0x0052	; ????
 1e4:	47 50       	subi	r20, 0x07	; 7
 1e6:	49 4f       	sbci	r20, 0xF9	; 249
 1e8:	52 32       	cpi	r21, 0x22	; 34
 1ea:	00 47       	sbci	r16, 0x70	; 112
 1ec:	50 49       	sbci	r21, 0x90	; 144
 1ee:	4f 52       	subi	r20, 0x2F	; 47
 1f0:	31 00       	.word	0x0031	; ????
 1f2:	47 50       	subi	r20, 0x07	; 7
 1f4:	49 4f       	sbci	r20, 0xF9	; 249
 1f6:	52 30       	cpi	r21, 0x02	; 2
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 45       	sbci	r16, 0x50	; 80
 1fa:	45 41       	sbci	r20, 0x15	; 21
		m += 1;
 1fc:	52 00       	.word	0x0052	; ????
 1fe:	45 45       	sbci	r20, 0x55	; 85
 200:	44 52       	subi	r20, 0x24	; 36
 202:	00 45       	sbci	r16, 0x50	; 80

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	45 43       	sbci	r20, 0x35	; 53
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	52 00       	.word	0x0052	; ????
 208:	64 69       	ori	r22, 0x94	; 148
 20a:	67 69       	ori	r22, 0x97	; 151
	sbi(TCCR0A, WGM00);
 20c:	74 61       	ori	r23, 0x14	; 20
 20e:	6c 57       	subi	r22, 0x7C	; 124
 210:	72 69       	ori	r23, 0x92	; 146
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	74 65       	ori	r23, 0x54	; 84
 214:	00 69       	ori	r16, 0x90	; 144
 216:	6e 69       	ori	r22, 0x9E	; 158
	sbi(TCCR0B, CS00);
 218:	74 00       	.word	0x0074	; ????
 21a:	6d 6f       	ori	r22, 0xFD	; 253
 21c:	64 65       	ori	r22, 0x54	; 84

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 64       	ori	r16, 0x40	; 64
 220:	69 67       	ori	r22, 0x79	; 121
 222:	69 74       	andi	r22, 0x49	; 73
 224:	61 6c       	ori	r22, 0xC1	; 193
 226:	5f 70       	andi	r21, 0x0F	; 15
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	69 6e       	ori	r22, 0xE9	; 233
 22a:	5f 74       	andi	r21, 0x4F	; 79

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	6f 5f       	subi	r22, 0xFF	; 255
 22e:	70 6f       	ori	r23, 0xF0	; 240
 230:	72 74       	andi	r23, 0x42	; 66
 232:	5f 50       	subi	r21, 0x0F	; 15
 234:	47 4d       	sbci	r20, 0xD7	; 215
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 73       	andi	r16, 0x30	; 48
 238:	65 74       	andi	r22, 0x45	; 69
 23a:	75 70       	andi	r23, 0x05	; 5
 23c:	00 69       	ori	r16, 0x90	; 144
 23e:	6e 69       	ori	r22, 0x9E	; 158
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	74 56       	subi	r23, 0x64	; 100
 242:	61 72       	andi	r22, 0x21	; 33
 244:	69 61       	ori	r22, 0x19	; 25
 246:	6e 74       	andi	r22, 0x4E	; 78
 248:	00 74       	andi	r16, 0x40	; 64

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	69 6d       	ori	r22, 0xD9	; 217
 24c:	65 72       	andi	r22, 0x25	; 37
 24e:	30 5f       	subi	r19, 0xF0	; 240
 250:	6f 76       	andi	r22, 0x6F	; 111
 252:	65 72       	andi	r22, 0x25	; 37

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	66 6c       	ori	r22, 0xC6	; 198
 256:	6f 77       	andi	r22, 0x7F	; 127
 258:	5f 63       	ori	r21, 0x3F	; 63
 25a:	6f 75       	andi	r22, 0x5F	; 95
 25c:	6e 74       	andi	r22, 0x4E	; 78
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 70       	andi	r16, 0x00	; 0
 260:	6f 72       	andi	r22, 0x2F	; 47
 262:	74 5f       	subi	r23, 0xF4	; 244
 264:	74 6f       	ori	r23, 0xF4	; 244
 266:	5f 6f       	ori	r21, 0xFF	; 255
		sbi(ADCSRA, ADPS1);
 268:	75 74       	andi	r23, 0x45	; 69
 26a:	70 75       	andi	r23, 0x50	; 80
 26c:	74 5f       	subi	r23, 0xF4	; 244
 26e:	50 47       	sbci	r21, 0x70	; 112
 270:	4d 00       	.word	0x004d	; ????
		sbi(ADCSRA, ADPS0);
 272:	3c 61       	ori	r19, 0x1C	; 28
 274:	72 74       	andi	r23, 0x42	; 66
 276:	69 66       	ori	r22, 0x69	; 105
 278:	69 63       	ori	r22, 0x39	; 57
 27a:	69 61       	ori	r22, 0x19	; 25
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	6c 3e       	cpi	r22, 0xEC	; 236
 27e:	00 5f       	subi	r16, 0xF0	; 240
 280:	5f 61       	ori	r21, 0x1F	; 31
 282:	64 64       	ori	r22, 0x44	; 68
 284:	72 31       	cpi	r23, 0x12	; 18
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	36 00       	.word	0x0036	; ????
 288:	70 6f       	ori	r23, 0xF0	; 240
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	72 74       	andi	r23, 0x42	; 66
 28c:	00 74       	andi	r16, 0x40	; 64
 28e:	75 72       	andi	r23, 0x25	; 37
	uint8_t port = digitalPinToPort(pin);
 290:	6e 4f       	sbci	r22, 0xFE	; 254
 292:	66 66       	ori	r22, 0x66	; 102
 294:	50 57       	subi	r21, 0x70	; 112
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	4d 2e       	mov	r4, r29
 298:	70 61       	ori	r23, 0x10	; 16

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	72 74       	andi	r23, 0x42	; 66
 29c:	2e 30       	cpi	r18, 0x0E	; 14
 29e:	00 74       	andi	r16, 0x40	; 64
 2a0:	69 6d       	ori	r22, 0xD9	; 217
 2a2:	65 72       	andi	r22, 0x25	; 37
 2a4:	30 5f       	subi	r19, 0xF0	; 240
 2a6:	66 72       	andi	r22, 0x26	; 38
 2a8:	61 63       	ori	r22, 0x31	; 49
	out = portOutputRegister(port);
 2aa:	74 00       	.word	0x0074	; ????
 2ac:	75 69       	ori	r23, 0x95	; 149
 2ae:	6e 74       	andi	r22, 0x4E	; 78
 2b0:	38 5f       	subi	r19, 0xF8	; 248
 2b2:	74 00       	.word	0x0074	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	75 6e       	ori	r23, 0xE5	; 229
                cli();
 2b6:	73 69       	ori	r23, 0x93	; 147
		*reg |= bit;
 2b8:	67 6e       	ori	r22, 0xE7	; 231
 2ba:	65 64       	ori	r22, 0x45	; 69
 2bc:	20 63       	ori	r18, 0x30	; 48
		SREG = oldSREG;
 2be:	68 61       	ori	r22, 0x18	; 24
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	72 00       	.word	0x0072	; ????
 2c2:	6d 61       	ori	r22, 0x1D	; 29
 2c4:	69 6e       	ori	r22, 0xE9	; 233
 2c6:	00 5f       	subi	r16, 0xF0	; 240
 2c8:	5f 76       	andi	r21, 0x6F	; 111
 2ca:	65 63       	ori	r22, 0x35	; 53
 2cc:	74 6f       	ori	r23, 0xF4	; 244
 2ce:	72 5f       	subi	r23, 0xF2	; 242
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	31 36       	cpi	r19, 0x61	; 97
 2d2:	00 47       	sbci	r16, 0x70	; 112
 2d4:	4e 55       	subi	r20, 0x5E	; 94
 2d6:	20 47       	sbci	r18, 0x70	; 112
 2d8:	49 4d       	sbci	r20, 0xD9	; 217
 2da:	50 4c       	sbci	r21, 0xC0	; 192

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	45 20       	and	r4, r5
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	37 2e       	mov	r3, r23
 2e0:	33 2e       	mov	r3, r19
 2e2:	30 20       	and	r3, r0
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	2d 6d       	ori	r18, 0xDD	; 221
 2e6:	6e 2d       	mov	r22, r14
 2e8:	66 6c       	ori	r22, 0xC6	; 198
 2ea:	61 73       	andi	r22, 0x31	; 49
 2ec:	68 3d       	cpi	r22, 0xD8	; 216
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	31 20       	and	r3, r1
 2f0:	2d 6d       	ori	r18, 0xDD	; 221
 2f2:	6d 63       	ori	r22, 0x3D	; 61
 2f4:	75 3d       	cpi	r23, 0xD5	; 213
 2f6:	61 76       	andi	r22, 0x61	; 97
 2f8:	72 35       	cpi	r23, 0x52	; 82
 2fa:	20 2d       	mov	r18, r0
 2fc:	6d 6e       	ori	r22, 0xED	; 237
    b = 0xffffffff; 
 2fe:	2d 66       	ori	r18, 0x6D	; 109
 300:	6c 61       	ori	r22, 0x1C	; 28
 302:	73 68       	ori	r23, 0x83	; 131
 304:	3d 31       	cpi	r19, 0x1D	; 29
 306:	20 2d       	mov	r18, r0
 308:	6d 6e       	ori	r22, 0xED	; 237
 30a:	6f 2d       	mov	r22, r15
 30c:	73 6b       	ori	r23, 0xB3	; 179
    a |= b;
 30e:	69 70       	andi	r22, 0x09	; 9
 310:	2d 62       	ori	r18, 0x2D	; 45
 312:	75 67       	ori	r23, 0x75	; 117
 314:	20 2d       	mov	r18, r0
 316:	6d 6d       	ori	r22, 0xDD	; 221
 318:	63 75       	andi	r22, 0x53	; 83
 31a:	3d 61       	ori	r19, 0x1D	; 29
 31c:	76 72       	andi	r23, 0x26	; 38
 31e:	35 20       	and	r3, r5
 320:	2d 67       	ori	r18, 0x7D	; 125
 322:	20 2d       	mov	r18, r0
 324:	4f 73       	andi	r20, 0x3F	; 63
 326:	20 2d       	mov	r18, r0
 328:	4f 73       	andi	r20, 0x3F	; 63
 32a:	20 2d       	mov	r18, r0
 32c:	66 6d       	ori	r22, 0xD6	; 214
 32e:	61 74       	andi	r22, 0x41	; 65
 330:	68 2d       	mov	r22, r8
 332:	65 72       	andi	r22, 0x25	; 37
 334:	72 6e       	ori	r23, 0xE2	; 226
 336:	6f 20       	and	r6, r15
 338:	2d 66       	ori	r18, 0x6D	; 109
 33a:	73 69       	ori	r23, 0x93	; 147
 33c:	67 6e       	ori	r22, 0xE7	; 231
 33e:	65 64       	ori	r22, 0x45	; 69
 340:	2d 7a       	andi	r18, 0xAD	; 173
 342:	65 72       	andi	r22, 0x25	; 37
 344:	6f 73       	andi	r22, 0x3F	; 63
    b = 0x00000000;
 346:	20 2d       	mov	r18, r0
 348:	66 74       	andi	r22, 0x46	; 70
 34a:	72 61       	ori	r23, 0x12	; 18
 34c:	70 70       	andi	r23, 0x00	; 0
 34e:	69 6e       	ori	r22, 0xE9	; 233
 350:	67 2d       	mov	r22, r7
 352:	6d 61       	ori	r22, 0x1D	; 29
 354:	74 68       	ori	r23, 0x84	; 132
    if(x){
 356:	20 2d       	mov	r18, r0
 358:	66 6e       	ori	r22, 0xE6	; 230
 35a:	6f 2d       	mov	r22, r15
 35c:	74 72       	andi	r23, 0x24	; 36
 35e:	61 70       	andi	r22, 0x01	; 1
 360:	76 20       	and	r7, r6
 362:	2d 66       	ori	r18, 0x6D	; 109
 364:	6e 6f       	ori	r22, 0xFE	; 254
 366:	2d 6f       	ori	r18, 0xFD	; 253
 368:	70 65       	ori	r23, 0x50	; 80
 36a:	6e 6d       	ori	r22, 0xDE	; 222
 36c:	70 20       	and	r7, r0
      //a &= b;
      b = 0xffffffff; 
 36e:	2d 66       	ori	r18, 0x6D	; 109
 370:	6e 6f       	ori	r22, 0xFE	; 254
 372:	2d 6f       	ori	r18, 0xFD	; 253
 374:	70 65       	ori	r23, 0x50	; 80
 376:	6e 61       	ori	r22, 0x1E	; 30
 378:	63 63       	ori	r22, 0x33	; 51
 37a:	20 2d       	mov	r18, r0
 37c:	66 6e       	ori	r22, 0xE6	; 230
      //a = a^b;
    }
    a &= b;
 37e:	6f 2d       	mov	r22, r15
 380:	65 78       	andi	r22, 0x85	; 133
 382:	63 65       	ori	r22, 0x53	; 83
 384:	70 74       	andi	r23, 0x40	; 64
 386:	69 6f       	ori	r22, 0xF9	; 249
 388:	6e 73       	andi	r22, 0x3E	; 62
 38a:	20 2d       	mov	r18, r0
 38c:	66 75       	andi	r22, 0x56	; 86
 38e:	73 65       	ori	r23, 0x53	; 83
 390:	2d 6c       	ori	r18, 0xCD	; 205
 392:	69 6e       	ori	r22, 0xE9	; 233
 394:	6b 65       	ori	r22, 0x5B	; 91
 396:	72 2d       	mov	r23, r2
 398:	70 6c       	ori	r23, 0xC0	; 192
 39a:	75 67       	ori	r23, 0x75	; 117
 39c:	69 6e       	ori	r22, 0xE9	; 233
 39e:	20 2d       	mov	r18, r0
 3a0:	66 6c       	ori	r22, 0xC6	; 198
 3a2:	74 72       	andi	r23, 0x24	; 36
 3a4:	61 6e       	ori	r22, 0xE1	; 225
 3a6:	73 00       	.word	0x0073	; ????
 3a8:	64 69       	ori	r22, 0x94	; 148
 3aa:	67 69       	ori	r22, 0x97	; 151
 3ac:	74 61       	ori	r23, 0x14	; 20
 3ae:	6c 5f       	subi	r22, 0xFC	; 252
 3b0:	70 69       	ori	r23, 0x90	; 144
 3b2:	6e 5f       	subi	r22, 0xFE	; 254
 3b4:	74 6f       	ori	r23, 0xF4	; 244
    b = 0xffffffff; 
 3b6:	5f 62       	ori	r21, 0x2F	; 47
 3b8:	69 74       	andi	r22, 0x49	; 73
 3ba:	5f 6d       	ori	r21, 0xDF	; 223
 3bc:	61 73       	andi	r22, 0x31	; 49
 3be:	6b 5f       	subi	r22, 0xFB	; 251
 3c0:	50 47       	sbci	r21, 0x70	; 112
 3c2:	4d 00       	.word	0x004d	; ????
 3c4:	74 69       	ori	r23, 0x94	; 148
    a = a^b;
 3c6:	6d 65       	ori	r22, 0x5D	; 93
 3c8:	72 30       	cpi	r23, 0x02	; 2
 3ca:	5f 6d       	ori	r21, 0xDF	; 223
 3cc:	69 6c       	ori	r22, 0xC9	; 201
 3ce:	6c 69       	ori	r22, 0x9C	; 156
 3d0:	73 00       	.word	0x0073	; ????
 3d2:	6c 6f       	ori	r22, 0xFC	; 252
 3d4:	6e 67       	ori	r22, 0x7E	; 126
 3d6:	20 75       	andi	r18, 0x50	; 80
 3d8:	6e 73       	andi	r22, 0x3E	; 62
 3da:	69 67       	ori	r22, 0x79	; 121
 3dc:	6e 65       	ori	r22, 0x5E	; 94
 3de:	64 20       	and	r6, r4
 3e0:	69 6e       	ori	r22, 0xE9	; 233
 3e2:	74 00       	.word	0x0074	; ????
 3e4:	74 75       	andi	r23, 0x54	; 84
 3e6:	72 6e       	ori	r23, 0xE2	; 226
 3e8:	4f 66       	ori	r20, 0x6F	; 111
 3ea:	66 50       	subi	r22, 0x06	; 6
 3ec:	57 4d       	sbci	r21, 0xD7	; 215
 3ee:	00 5f       	subi	r16, 0xF0	; 240
 3f0:	5f 72       	andi	r21, 0x2F	; 47
 3f2:	65 73       	andi	r22, 0x35	; 53
 3f4:	75 6c       	ori	r23, 0xC5	; 197
 3f6:	74 00       	.word	0x0074	; ????
 3f8:	64 69       	ori	r22, 0x94	; 148
 3fa:	67 69       	ori	r22, 0x97	; 151
 3fc:	74 61       	ori	r23, 0x14	; 20
 3fe:	6c 5f       	subi	r22, 0xFC	; 252
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	70 69       	ori	r23, 0x90	; 144
 402:	6e 5f       	subi	r22, 0xFE	; 254
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	74 6f       	ori	r23, 0xF4	; 244
 406:	5f 74       	andi	r21, 0x4F	; 79
 408:	69 6d       	ori	r22, 0xD9	; 217
 40a:	65 72       	andi	r22, 0x25	; 37
 40c:	5f 50       	subi	r21, 0x0F	; 15
 40e:	47 4d       	sbci	r20, 0xD7	; 215
 410:	00 75       	andi	r16, 0x50	; 80
 412:	69 6e       	ori	r22, 0xE9	; 233
 414:	74 31       	cpi	r23, 0x14	; 20
 416:	36 5f       	subi	r19, 0xF6	; 246
 418:	74 00       	.word	0x0074	; ????
 41a:	70 6f       	ori	r23, 0xF0	; 240
 41c:	72 74       	andi	r23, 0x42	; 66
 41e:	5f 74       	andi	r21, 0x4F	; 79
 420:	6f 5f       	subi	r22, 0xFF	; 255
 422:	6d 6f       	ori	r22, 0xFD	; 253
 424:	64 65       	ori	r22, 0x54	; 84
 426:	5f 50       	subi	r21, 0x0F	; 15
 428:	47 4d       	sbci	r20, 0xD7	; 215
 42a:	00 74       	andi	r16, 0x40	; 64
 42c:	69 6d       	ori	r22, 0xD9	; 217
 42e:	65 72       	andi	r22, 0x25	; 37
 430:	00 70       	andi	r16, 0x00	; 0
 432:	69 6e       	ori	r22, 0xE9	; 233
 434:	4d 6f       	ori	r20, 0xFD	; 253
 436:	64 65       	ori	r22, 0x54	; 84
 438:	00 43       	sbci	r16, 0x30	; 48
 43a:	3a 5c       	subi	r19, 0xCA	; 202
 43c:	55 73       	andi	r21, 0x35	; 53
 43e:	65 72       	andi	r22, 0x25	; 37
 440:	73 5c       	subi	r23, 0xC3	; 195
 442:	52 59       	subi	r21, 0x92	; 146
 444:	77 6f       	ori	r23, 0xF7	; 247
 446:	72 6b       	ori	r23, 0xB2	; 178
 448:	5c 44       	sbci	r21, 0x4C	; 76
 44a:	65 73       	andi	r22, 0x35	; 53
 44c:	6b 74       	andi	r22, 0x4B	; 75
 44e:	6f 70       	andi	r22, 0x0F	; 15
 450:	5c 53       	subi	r21, 0x3C	; 60
 452:	70 72       	andi	r23, 0x20	; 32
 454:	69 6e       	ori	r22, 0xE9	; 233
 456:	67 20       	and	r6, r7
 458:	31 39       	cpi	r19, 0x91	; 145
 45a:	5c 61       	ori	r21, 0x1C	; 28
 45c:	73 73       	andi	r23, 0x33	; 51
 45e:	69 67       	ori	r22, 0x79	; 121
 460:	6e 6d       	ori	r22, 0xDE	; 222
 462:	65 6e       	ori	r22, 0xE5	; 229
 464:	74 34       	cpi	r23, 0x44	; 68
 466:	5c 41       	sbci	r21, 0x1C	; 28
 468:	72 64       	ori	r23, 0x42	; 66
 46a:	75 69       	ori	r23, 0x95	; 149
 46c:	6e 6f       	ori	r22, 0xFE	; 254
 46e:	41 73       	andi	r20, 0x31	; 49
 470:	73 65       	ori	r23, 0x53	; 83
 472:	6d 62       	ori	r22, 0x2D	; 45
 474:	6c 79       	andi	r22, 0x9C	; 156
 476:	50 61       	ori	r21, 0x10	; 16
 478:	72 73       	andi	r23, 0x32	; 50
 47a:	65 72       	andi	r22, 0x25	; 37
 47c:	5c 50       	subi	r21, 0x0C	; 12
 47e:	61 72       	andi	r22, 0x21	; 33
 480:	73 65       	ori	r23, 0x53	; 83
 482:	72 49       	sbci	r23, 0x92	; 146
 484:	6e 70       	andi	r22, 0x0E	; 14
 486:	75 74       	andi	r23, 0x45	; 69
 488:	46 69       	ori	r20, 0x96	; 150
 48a:	6c 65       	ori	r22, 0x5C	; 92
 48c:	73 5c       	subi	r23, 0xC3	; 195
 48e:	52 61       	ori	r21, 0x12	; 18
 490:	77 41       	sbci	r23, 0x17	; 23
 492:	72 64       	ori	r23, 0x42	; 66
 494:	75 69       	ori	r23, 0x95	; 149
 496:	6e 6f       	ori	r22, 0xFE	; 254
 498:	46 69       	ori	r20, 0x96	; 150
 49a:	6c 65       	ori	r22, 0x5C	; 92
 49c:	73 5c       	subi	r23, 0xC3	; 195
 49e:	4c 41       	sbci	r20, 0x1C	; 28
 4a0:	44 53       	subi	r20, 0x34	; 52
 4a2:	5f 63       	ori	r21, 0x3F	; 63
 4a4:	6f 6e       	ori	r22, 0xEF	; 239
 4a6:	74 72       	andi	r23, 0x24	; 36
 4a8:	6f 6c       	ori	r22, 0xCF	; 207
 4aa:	5f 66       	ori	r21, 0x6F	; 111
 4ac:	6c 6f       	ori	r22, 0xFC	; 252
 4ae:	77 5f       	subi	r23, 0xF7	; 247
 4b0:	69 66       	ori	r22, 0x69	; 105
 4b2:	5f 66       	ori	r21, 0x6F	; 111
 4b4:	61 6c       	ori	r22, 0xC1	; 193
 4b6:	73 65       	ori	r23, 0x53	; 83
 4b8:	5f 6c       	ori	r21, 0xCF	; 207
 4ba:	6f 6f       	ori	r22, 0xFF	; 255
 4bc:	70 00       	.word	0x0070	; ????
 4be:	6f 6c       	ori	r22, 0xCF	; 207
 4c0:	64 53       	subi	r22, 0x34	; 52
 4c2:	52 45       	sbci	r21, 0x52	; 82
 4c4:	47 00       	.word	0x0047	; ????

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
   0:	e6 00       	.word	0x00e6	; ????
   2:	00 00       	nop
   4:	08 01       	movw	r0, r16
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	62 2a       	or	r6, r18
   c:	01 00       	.word	0x0001	; ????
   e:	00 3a       	cpi	r16, 0xA0	; 160
  10:	01 00       	.word	0x0001	; ????
  12:	00 01       	movw	r0, r0
  14:	00 62       	ori	r16, 0x20	; 32
  16:	3e 01       	movw	r6, r28
  18:	00 00       	nop
  1a:	42 01       	movw	r8, r4
  1c:	00 00       	nop
  1e:	01 00       	.word	0x0001	; ????
  20:	62 4a       	sbci	r22, 0xA2	; 162
  22:	01 00       	.word	0x0001	; ????
  24:	00 4c       	sbci	r16, 0xC0	; 192
  26:	01 00       	.word	0x0001	; ????
  28:	00 01       	movw	r0, r0
  2a:	00 62       	ori	r16, 0x20	; 32
  2c:	52 01       	movw	r10, r4
  2e:	00 00       	nop
  30:	54 01       	movw	r10, r8
  32:	00 00       	nop
  34:	01 00       	.word	0x0001	; ????
  36:	62 58       	subi	r22, 0x82	; 130
  38:	01 00       	.word	0x0001	; ????
  3a:	00 5c       	subi	r16, 0xC0	; 192
  3c:	01 00       	.word	0x0001	; ????
  3e:	00 01       	movw	r0, r0
  40:	00 62       	ori	r16, 0x20	; 32
  42:	64 01       	movw	r12, r8
  44:	00 00       	nop
  46:	68 01       	movw	r12, r16
  48:	00 00       	nop
  4a:	01 00       	.word	0x0001	; ????
  4c:	62 00       	.word	0x0062	; ????
  4e:	00 00       	nop
  50:	00 00       	nop
  52:	00 00       	nop
  54:	00 ec       	ldi	r16, 0xC0	; 192
  56:	00 00       	nop
  58:	00 22       	and	r0, r16
  5a:	01 00       	.word	0x0001	; ????
  5c:	00 01       	movw	r0, r0
  5e:	00 69       	ori	r16, 0x90	; 144
  60:	22 01       	movw	r4, r4
  62:	00 00       	nop
  64:	24 01       	movw	r4, r8
  66:	00 00       	nop
  68:	04 00       	.word	0x0004	; ????
  6a:	89 00       	.word	0x0089	; ????
  6c:	20 9f       	mul	r18, r16
  6e:	2a 01       	movw	r4, r20
  70:	00 00       	nop
  72:	6e 01       	movw	r12, r28
  74:	00 00       	nop
  76:	01 00       	.word	0x0001	; ????
  78:	69 00       	.word	0x0069	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	00 f2       	brcs	.-128    	; 0x2 <__zero_reg__+0x1>
  82:	00 00       	nop
  84:	00 0e       	add	r0, r16
  86:	01 00       	.word	0x0001	; ????
  88:	00 01       	movw	r0, r0
  8a:	00 6e       	ori	r16, 0xE0	; 224
  8c:	2a 01       	movw	r4, r20
  8e:	00 00       	nop
  90:	6c 01       	movw	r12, r24
  92:	00 00       	nop
  94:	01 00       	.word	0x0001	; ????
  96:	6e 00       	.word	0x006e	; ????
  98:	00 00       	nop
  9a:	00 00       	nop
  9c:	00 00       	nop
  9e:	00 16       	cp	r0, r16
  a0:	01 00       	.word	0x0001	; ????
  a2:	00 28       	or	r0, r0
  a4:	01 00       	.word	0x0001	; ????
  a6:	00 06       	cpc	r0, r16
  a8:	00 6a       	ori	r16, 0xA0	; 160
  aa:	93 01       	movw	r18, r6
  ac:	6b 93       	.word	0x936b	; ????
  ae:	01 6c       	ori	r16, 0xC1	; 193
  b0:	01 00       	.word	0x0001	; ????
  b2:	00 70       	andi	r16, 0x00	; 0
  b4:	01 00       	.word	0x0001	; ????
  b6:	00 06       	cpc	r0, r16
  b8:	00 6a       	ori	r16, 0xA0	; 160
  ba:	93 01       	movw	r18, r6
  bc:	6b 93       	.word	0x936b	; ????
  be:	01 00       	.word	0x0001	; ????
  c0:	00 00       	nop
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	00 18       	sub	r0, r0
  c8:	01 00       	.word	0x0001	; ????
  ca:	00 28       	or	r0, r0
  cc:	01 00       	.word	0x0001	; ????
  ce:	00 01       	movw	r0, r0
  d0:	00 62       	ori	r16, 0x20	; 32
  d2:	6c 01       	movw	r12, r24
  d4:	00 00       	nop
  d6:	70 01       	movw	r14, r0
  d8:	00 00       	nop
  da:	01 00       	.word	0x0001	; ????
  dc:	62 00       	.word	0x0062	; ????
  de:	00 00       	nop
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	00 00       	nop
  e2:	00 00       	nop
  e4:	00 e4       	ldi	r16, 0x40	; 64
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	00 00       	nop
  e8:	00 ea       	ldi	r16, 0xA0	; 160
  ea:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
  ec:	00 06       	cpc	r0, r16
  ee:	00 6e       	ori	r16, 0xE0	; 224
  f0:	93 01       	movw	r18, r6
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	6f 93       	push	r22
  f4:	01 00       	.word	0x0001	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	00 00       	nop
  f8:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 00       	nop
  fc:	00 ea       	ldi	r16, 0xA0	; 160
  fe:	00 00       	nop
 100:	00 f0       	brcs	.+0      	; 0x102 <digitalWrite.constprop.0+0x22>
 102:	00 00       	nop
 104:	00 06       	cpc	r0, r16
 106:	00 6e       	ori	r16, 0xE0	; 224

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	93 01       	movw	r18, r6
 10a:	6f 93       	push	r22
 10c:	01 00       	.word	0x0001	; ????
 10e:	00 00       	nop
 110:	00 00       	nop
 112:	00 00       	nop
 114:	00 f0       	brcs	.+0      	; 0x116 <digitalWrite.constprop.0+0x36>

	uint8_t oldSREG = SREG;
 116:	00 00       	nop
	cli();
 118:	00 f2       	brcs	.-128    	; 0x9a <digital_pin_to_bit_mask_PGM+0xa>

	if (val == LOW) {
		*out &= ~bit;
 11a:	00 00       	nop
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 06       	cpc	r0, r16
 11e:	00 6e       	ori	r16, 0xE0	; 224
		*out &= ~bit;
 120:	93 01       	movw	r18, r6
 122:	6f 93       	push	r22
	} else {
		*out |= bit;
 124:	01 00       	.word	0x0001	; ????
	}

	SREG = oldSREG;
 126:	00 00       	nop
}
 128:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	00 00       	nop
 12c:	00 fa       	bst	r0, 0
 12e:	00 00       	nop
 130:	00 08       	sbc	r0, r0
 132:	01 00       	.word	0x0001	; ????
 134:	00 01       	movw	r0, r0
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	00 62       	ori	r16, 0x20	; 32
 138:	2a 01       	movw	r4, r20
 13a:	00 00       	nop
 13c:	3a 01       	movw	r6, r20
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	00 00       	nop
 140:	01 00       	.word	0x0001	; ????
 142:	62 3e       	cpi	r22, 0xE2	; 226
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	01 00       	.word	0x0001	; ????
 146:	00 42       	sbci	r16, 0x20	; 32
 148:	01 00       	.word	0x0001	; ????
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	00 01       	movw	r0, r0
 14c:	00 62       	ori	r16, 0x20	; 32
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	4a 01       	movw	r8, r20
 150:	00 00       	nop
 152:	4c 01       	movw	r8, r24
 154:	00 00       	nop
 156:	01 00       	.word	0x0001	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	62 52       	subi	r22, 0x22	; 34
 15a:	01 00       	.word	0x0001	; ????
 15c:	00 54       	subi	r16, 0x40	; 64
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	01 00       	.word	0x0001	; ????
 160:	00 01       	movw	r0, r0
 162:	00 62       	ori	r16, 0x20	; 32
 164:	58 01       	movw	r10, r16
 166:	00 00       	nop
 168:	5c 01       	movw	r10, r24
 16a:	00 00       	nop
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	01 00       	.word	0x0001	; ????
 16e:	62 64       	ori	r22, 0x42	; 66
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	01 00       	.word	0x0001	; ????
 172:	00 68       	ori	r16, 0x80	; 128
 174:	01 00       	.word	0x0001	; ????
 176:	00 01       	movw	r0, r0
 178:	00 62       	ori	r16, 0x20	; 32
	...
 182:	12 01       	movw	r2, r4
 184:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	16 01       	movw	r2, r12
 188:	00 00       	nop
 18a:	06 00       	.word	0x0006	; ????
 18c:	6e 93       	st	-X, r22
 18e:	01 6f       	ori	r16, 0xF1	; 241
 190:	93 01       	movw	r18, r6
	...
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	70 01       	movw	r14, r0
 19c:	00 00       	nop
	if (f >= FRACT_MAX) {
 19e:	72 01       	movw	r14, r4
 1a0:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	03 00       	.word	0x0003	; ????
 1a4:	92 20       	and	r9, r2
 1a6:	02 72       	andi	r16, 0x22	; 34
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	01 00       	.word	0x0001	; ????
 1aa:	00 74       	andi	r16, 0x40	; 64
	timer0_millis = m;
 1ac:	01 00       	.word	0x0001	; ????
 1ae:	00 03       	mulsu	r16, r16
 1b0:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x20b>
 1b4:	74 01       	movw	r14, r8
 1b6:	00 00       	nop
 1b8:	7c 01       	movw	r14, r24
 1ba:	00 00       	nop
	timer0_overflow_count++;
 1bc:	03 00       	.word	0x0003	; ????
 1be:	92 20       	and	r9, r2
 1c0:	04 7c       	andi	r16, 0xC4	; 196
 1c2:	01 00       	.word	0x0001	; ????
 1c4:	00 7e       	andi	r16, 0xE0	; 224
 1c6:	01 00       	.word	0x0001	; ????
 1c8:	00 03       	mulsu	r16, r16
 1ca:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x40b>
 1ce:	7e 01       	movw	r14, r28
 1d0:	00 00       	nop
 1d2:	80 01       	movw	r16, r0
 1d4:	00 00       	nop
 1d6:	03 00       	.word	0x0003	; ????
 1d8:	92 20       	and	r9, r2
 1da:	06 80       	ldd	r0, Z+6	; 0x06
 1dc:	01 00       	.word	0x0001	; ????
 1de:	00 82       	st	Z, r0
 1e0:	01 00       	.word	0x0001	; ????
}
 1e2:	00 03       	mulsu	r16, r16
 1e4:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x60b>
 1e8:	82 01       	movw	r16, r4
 1ea:	00 00       	nop
 1ec:	84 01       	movw	r16, r8
 1ee:	00 00       	nop
 1f0:	03 00       	.word	0x0003	; ????
 1f2:	92 20       	and	r9, r2
 1f4:	08 84       	ldd	r0, Y+8	; 0x08
 1f6:	01 00       	.word	0x0001	; ????
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 86       	std	Z+8, r0	; 0x08
 1fa:	01 00       	.word	0x0001	; ????
		m += 1;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x80b>
 202:	86 01       	movw	r16, r12

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	00 00       	nop
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	04 02       	muls	r16, r20
 208:	00 00       	nop
 20a:	03 00       	.word	0x0003	; ????
	sbi(TCCR0A, WGM00);
 20c:	92 20       	and	r9, r2
 20e:	0a 00       	.word	0x000a	; ????
 210:	00 00       	nop
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	00 00       	nop
 214:	00 00       	nop
 216:	00 96       	adiw	r24, 0x00	; 0
	sbi(TCCR0B, CS00);
 218:	01 00       	.word	0x0001	; ????
 21a:	00 9a       	sbi	0x00, 0	; 0
 21c:	01 00       	.word	0x0001	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 0c       	add	r0, r0
 220:	00 68       	ori	r16, 0x80	; 128
 222:	93 01       	movw	r18, r6
 224:	69 93       	st	Y+, r22
 226:	01 6a       	ori	r16, 0xA1	; 161
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	93 01       	movw	r18, r6
 22a:	6b 93       	.word	0x936b	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	01 9a       	sbi	0x00, 1	; 0
 22e:	01 00       	.word	0x0001	; ????
 230:	00 a8       	ldd	r0, Z+48	; 0x30
 232:	01 00       	.word	0x0001	; ????
 234:	00 03       	mulsu	r16, r16
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 88       	ldd	r0, Z+16	; 0x10
 238:	01 9f       	mul	r16, r17
 23a:	a8 01       	movw	r20, r16
 23c:	00 00       	nop
 23e:	cc 01       	movw	r24, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	00 00       	nop
 242:	0c 00       	.word	0x000c	; ????
 244:	68 93       	.word	0x9368	; ????
 246:	01 69       	ori	r16, 0x91	; 145
 248:	93 01       	movw	r18, r6

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	6a 93       	st	-Y, r22
 24c:	01 6b       	ori	r16, 0xB1	; 177
 24e:	93 01       	movw	r18, r6
 250:	cc 01       	movw	r24, r24
 252:	00 00       	nop

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	e2 01       	movw	r28, r4
 256:	00 00       	nop
 258:	05 00       	.word	0x0005	; ????
 25a:	03 11       	cpse	r16, r3
 25c:	01 80       	ldd	r0, Z+1	; 0x01
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 f8       	bld	r0, 0
 260:	01 00       	.word	0x0001	; ????
 262:	00 02       	muls	r16, r16
 264:	02 00       	.word	0x0002	; ????
 266:	00 03       	mulsu	r16, r16
		sbi(ADCSRA, ADPS1);
 268:	00 88       	ldd	r0, Z+16	; 0x10
 26a:	01 9f       	mul	r16, r17
 26c:	02 02       	muls	r16, r18
 26e:	00 00       	nop
 270:	04 02       	muls	r16, r20
		sbi(ADCSRA, ADPS0);
 272:	00 00       	nop
 274:	0c 00       	.word	0x000c	; ????
 276:	68 93       	.word	0x9368	; ????
 278:	01 69       	ori	r16, 0x91	; 145
 27a:	93 01       	movw	r18, r6
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	6a 93       	st	-Y, r22
 27e:	01 6b       	ori	r16, 0xB1	; 177
 280:	93 01       	movw	r18, r6
	...
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	9a 01       	movw	r18, r20
 28c:	00 00       	nop
 28e:	9e 01       	movw	r18, r28
	uint8_t port = digitalPinToPort(pin);
 290:	00 00       	nop
 292:	01 00       	.word	0x0001	; ????
 294:	63 9e       	mul	r6, r19
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	01 00       	.word	0x0001	; ????
 298:	00 ee       	ldi	r16, 0xE0	; 224

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	01 00       	.word	0x0001	; ????
 29c:	00 01       	movw	r0, r0
 29e:	00 62       	ori	r16, 0x20	; 32
 2a0:	ee 01       	movw	r28, r28
 2a2:	00 00       	nop
 2a4:	f2 01       	movw	r30, r4
 2a6:	00 00       	nop
 2a8:	05 00       	.word	0x0005	; ????
	out = portOutputRegister(port);
 2aa:	03 10       	cpse	r0, r3
 2ac:	01 80       	ldd	r0, Z+1	; 0x01
 2ae:	00 f8       	bld	r0, 0
 2b0:	01 00       	.word	0x0001	; ????
 2b2:	00 fa       	bst	r0, 0
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	01 00       	.word	0x0001	; ????
                cli();
 2b6:	00 01       	movw	r0, r0
		*reg |= bit;
 2b8:	00 62       	ori	r16, 0x20	; 32
 2ba:	fa 01       	movw	r30, r20
 2bc:	00 00       	nop
		SREG = oldSREG;
 2be:	fc 01       	movw	r30, r24
void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);          //  setup serial
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  x = 0;
 2c0:	00 00       	nop
 2c2:	03 00       	.word	0x0003	; ????
 2c4:	83 03       	fmuls	r16, r19
 2c6:	9f fc       	.word	0xfc9f	; ????
 2c8:	01 00       	.word	0x0001	; ????
 2ca:	00 04       	cpc	r0, r0
 2cc:	02 00       	.word	0x0002	; ????
 2ce:	00 01       	movw	r0, r0
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
    b = 0xffffffff; 
 2d0:	00 62       	ori	r16, 0x20	; 32
	...
 2da:	8a 02       	muls	r24, r26

void loop() {
  // put your main code here, to run repeatedly:
  
  // Create trigger
  noInterrupts();
 2dc:	00 00       	nop
  digitalWrite(LED_BUILTIN, LOW);   
 2de:	c0 02       	muls	r28, r16
 2e0:	00 00       	nop
 2e2:	02 00       	.word	0x0002	; ????
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2e4:	3d 9f       	mul	r19, r29
	...
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
    a = 0x00000000;
 2ee:	8a 02       	muls	r24, r26
 2f0:	00 00       	nop
 2f2:	c0 02       	muls	r28, r16
 2f4:	00 00       	nop
 2f6:	02 00       	.word	0x0002	; ????
 2f8:	31 9f       	mul	r19, r17
	...
    b = 0xffffffff; 
 302:	90 02       	muls	r25, r16
 304:	00 00       	nop
 306:	dc 02       	muls	r29, r28
 308:	00 00       	nop
 30a:	01 00       	.word	0x0001	; ????
 30c:	62 00       	.word	0x0062	; ????
    a |= b;
 30e:	00 00       	nop
 310:	00 00       	nop
 312:	00 00       	nop
 314:	00 96       	adiw	r24, 0x00	; 0
 316:	02 00       	.word	0x0002	; ????
 318:	00 a0       	ldd	r0, Z+32	; 0x20
 31a:	02 00       	.word	0x0002	; ????
 31c:	00 01       	movw	r0, r0
 31e:	00 68       	ori	r16, 0x80	; 128
	...
 328:	aa 02       	muls	r26, r26
 32a:	00 00       	nop
 32c:	c0 02       	muls	r28, r16
 32e:	00 00       	nop
 330:	06 00       	.word	0x0006	; ????
 332:	6a 93       	st	-Y, r22
 334:	01 6b       	ori	r16, 0xB1	; 177
 336:	93 01       	movw	r18, r6
	...
 340:	8e 02       	muls	r24, r30
 342:	00 00       	nop
 344:	94 02       	muls	r25, r20
    b = 0x00000000;
 346:	00 00       	nop
 348:	06 00       	.word	0x0006	; ????
 34a:	6e 93       	st	-X, r22
 34c:	01 6f       	ori	r16, 0xF1	; 241
 34e:	93 01       	movw	r18, r6
	...
    if(x){
 358:	90 02       	muls	r25, r16
 35a:	00 00       	nop
 35c:	c0 02       	muls	r28, r16
 35e:	00 00       	nop
 360:	01 00       	.word	0x0001	; ????
 362:	62 00       	.word	0x0062	; ????
 364:	00 00       	nop
 366:	00 00       	nop
 368:	00 00       	nop
 36a:	00 94       	com	r0
 36c:	02 00       	.word	0x0002	; ????
      //a &= b;
      b = 0xffffffff; 
 36e:	00 a2       	std	Z+32, r0	; 0x20
 370:	02 00       	.word	0x0002	; ????
 372:	00 06       	cpc	r0, r16
 374:	00 6e       	ori	r16, 0xE0	; 224
 376:	93 01       	movw	r18, r6
 378:	6f 93       	push	r22
 37a:	01 00       	.word	0x0001	; ????
 37c:	00 00       	nop
      //a = a^b;
    }
    a &= b;
 37e:	00 00       	nop
 380:	00 00       	nop
 382:	00 a6       	std	Z+40, r0	; 0x28
 384:	02 00       	.word	0x0002	; ????
 386:	00 aa       	std	Z+48, r0	; 0x30
 388:	02 00       	.word	0x0002	; ????
 38a:	00 06       	cpc	r0, r16
 38c:	00 6e       	ori	r16, 0xE0	; 224
 38e:	93 01       	movw	r18, r6
 390:	6f 93       	push	r22
 392:	01 00       	.word	0x0001	; ????
 394:	00 00       	nop
 396:	00 00       	nop
 398:	00 00       	nop
 39a:	00 b0       	in	r0, 0x00	; 0
 39c:	02 00       	.word	0x0002	; ????
 39e:	00 b4       	in	r0, 0x20	; 32
 3a0:	02 00       	.word	0x0002	; ????
 3a2:	00 06       	cpc	r0, r16
 3a4:	00 6e       	ori	r16, 0xE0	; 224
 3a6:	93 01       	movw	r18, r6
 3a8:	6f 93       	push	r22
 3aa:	01 00       	.word	0x0001	; ????
 3ac:	00 00       	nop
 3ae:	00 00       	nop
 3b0:	00 00       	nop
 3b2:	00 b6       	in	r0, 0x30	; 48
 3b4:	02 00       	.word	0x0002	; ????
    b = 0xffffffff; 
 3b6:	00 c0       	rjmp	.+0      	; 0x3b8 <main+0x1b4>
 3b8:	02 00       	.word	0x0002	; ????
 3ba:	00 01       	movw	r0, r0
 3bc:	00 68       	ori	r16, 0x80	; 128
	...
    a = a^b;
 3c6:	ea 02       	muls	r30, r26
 3c8:	00 00       	nop
 3ca:	ee 02       	muls	r30, r30
 3cc:	00 00       	nop
 3ce:	02 00       	.word	0x0002	; ????
 3d0:	30 9f       	mul	r19, r16
 3d2:	ee 02       	muls	r30, r30
 3d4:	00 00       	nop
 3d6:	fe 03       	fmulsu	r23, r22
 3d8:	00 00       	nop
 3da:	05 00       	.word	0x0005	; ????
 3dc:	3f 88       	ldd	r3, Y+23	; 0x17
 3de:	00 1c       	adc	r0, r0
 3e0:	9f fe       	.word	0xfe9f	; ????
 3e2:	03 00       	.word	0x0003	; ????
 3e4:	00 00       	nop
 3e6:	04 00       	.word	0x0004	; ????
 3e8:	00 05       	cpc	r16, r0
 3ea:	00 40       	sbci	r16, 0x00	; 0
 3ec:	88 00       	.word	0x0088	; ????
 3ee:	1c 9f       	mul	r17, r28
 3f0:	00 04       	cpc	r0, r0
 3f2:	00 00       	nop
 3f4:	06 04       	cpc	r0, r6
 3f6:	00 00       	nop
 3f8:	05 00       	.word	0x0005	; ????
 3fa:	3f 88       	ldd	r3, Y+23	; 0x17
 3fc:	00 1c       	adc	r0, r0
 3fe:	9f 00       	.word	0x009f	; ????
  // Create trigger
  noInterrupts();
  digitalWrite(LED_BUILTIN, LOW);   
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
  //Code goes here
  for(unsigned int ii=0; ii<15; ii++){
 400:	00 00       	nop
 402:	00 00       	nop
    a = a^b;
    //asm("nop\n"); //delay
  
  }
  
  interrupts();
 404:	00 00       	nop
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	fa 00       	.word	0x00fa	; ????
   2:	00 00       	nop
   4:	08 01       	movw	r0, r16
   6:	00 00       	nop
   8:	2a 01       	movw	r4, r20
   a:	00 00       	nop
   c:	6c 01       	movw	r12, r24
	...
  16:	00 00       	nop
  18:	d0 02       	muls	r29, r16
  1a:	00 00       	nop
  1c:	d8 02       	muls	r29, r24
  1e:	00 00       	nop
  20:	dc 02       	muls	r29, r28
  22:	00 00       	nop
  24:	06 04       	cpc	r0, r6
	...
  2e:	00 00       	nop
  30:	d0 02       	muls	r29, r16
  32:	00 00       	nop
  34:	d8 02       	muls	r29, r24
  36:	00 00       	nop
  38:	ee 02       	muls	r30, r30
  3a:	00 00       	nop
  3c:	04 04       	cpc	r0, r4
	...
  46:	00 00       	nop
  48:	e0 00       	.word	0x00e0	; ????
  4a:	00 00       	nop
  4c:	04 02       	muls	r16, r20
  4e:	00 00       	nop
  50:	04 02       	muls	r16, r20
  52:	00 00       	nop
  54:	12 04       	cpc	r1, r2
	...
