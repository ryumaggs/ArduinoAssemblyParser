
.\LADS_Sleep_loop\LADS_Sleep_loop.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__ctors_end>
   4:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
   8:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
   c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  10:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  14:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  18:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  1c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  20:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  24:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  28:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  2c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  30:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  34:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  38:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  3c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  40:	0c 94 b8 00 	jmp	0x170	; 0x170 <__vector_16>
  44:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  48:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  4c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  50:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  54:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  58:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  5c:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  60:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>
  64:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	24 00       	.word	0x0024	; ????
  6e:	27 00       	.word	0x0027	; ????
  70:	2a 00       	.word	0x002a	; ????

00000072 <port_to_output_PGM>:
  72:	00 00       	nop
  74:	00 00       	nop
  76:	25 00       	.word	0x0025	; ????
  78:	28 00       	.word	0x0028	; ????
  7a:	2b 00       	.word	0x002b	; ????

0000007c <digital_pin_to_port_PGM>:
  7c:	04 04       	cpc	r0, r4
  7e:	04 04       	cpc	r0, r4
  80:	04 04       	cpc	r0, r4
  82:	04 04       	cpc	r0, r4
  84:	02 02       	muls	r16, r18
  86:	02 02       	muls	r16, r18
  88:	02 02       	muls	r16, r18
  8a:	03 03       	mulsu	r16, r19
  8c:	03 03       	mulsu	r16, r19
  8e:	03 03       	mulsu	r16, r19

00000090 <digital_pin_to_bit_mask_PGM>:
  90:	01 02       	muls	r16, r17
  92:	04 08       	sbc	r0, r4
  94:	10 20       	and	r1, r0
  96:	40 80       	ld	r4, Z
  98:	01 02       	muls	r16, r17
  9a:	04 08       	sbc	r0, r4
  9c:	10 20       	and	r1, r0
  9e:	01 02       	muls	r16, r17
  a0:	04 08       	sbc	r0, r4
  a2:	10 20       	and	r1, r0

000000a4 <digital_pin_to_timer_PGM>:
  a4:	00 00       	nop
  a6:	00 08       	sbc	r0, r0
  a8:	00 02       	muls	r16, r16
  aa:	01 00       	.word	0x0001	; ????
  ac:	00 03       	mulsu	r16, r16
  ae:	04 07       	cpc	r16, r20
	...

000000b8 <__ctors_end>:
  b8:	11 24       	eor	r1, r1
  ba:	1f be       	out	0x3f, r1	; 63
  bc:	cf ef       	ldi	r28, 0xFF	; 255
  be:	d8 e0       	ldi	r29, 0x08	; 8
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	cd bf       	out	0x3d, r28	; 61

000000c4 <__do_clear_bss>:
  c4:	21 e0       	ldi	r18, 0x01	; 1
  c6:	a0 e0       	ldi	r26, 0x00	; 0
  c8:	b1 e0       	ldi	r27, 0x01	; 1
  ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
  cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
  ce:	a9 30       	cpi	r26, 0x09	; 9
  d0:	b2 07       	cpc	r27, r18
  d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
  d4:	0e 94 02 01 	call	0x204	; 0x204 <main>
  d8:	0c 94 b2 07 	jmp	0xf64	; 0xf64 <_exit>

000000dc <__bad_interrupt>:
  dc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000e0 <digitalWrite.constprop.0>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	e1 eb       	ldi	r30, 0xB1	; 177
  e2:	f0 e0       	ldi	r31, 0x00	; 0
  e4:	24 91       	lpm	r18, Z
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	ed e9       	ldi	r30, 0x9D	; 157
  e8:	f0 e0       	ldi	r31, 0x00	; 0
  ea:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
  ec:	e9 e8       	ldi	r30, 0x89	; 137
  ee:	f0 e0       	ldi	r31, 0x00	; 0
  f0:	e4 91       	lpm	r30, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	ee 23       	and	r30, r30
  f4:	c9 f0       	breq	.+50     	; 0x128 <digitalWrite.constprop.0+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	22 23       	and	r18, r18
  f8:	39 f0       	breq	.+14     	; 0x108 <digitalWrite.constprop.0+0x28>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	23 30       	cpi	r18, 0x03	; 3
  fc:	01 f1       	breq	.+64     	; 0x13e <digitalWrite.constprop.0+0x5e>
  fe:	a8 f4       	brcc	.+42     	; 0x12a <digitalWrite.constprop.0+0x4a>
 100:	21 30       	cpi	r18, 0x01	; 1
 102:	19 f1       	breq	.+70     	; 0x14a <digitalWrite.constprop.0+0x6a>
 104:	22 30       	cpi	r18, 0x02	; 2
 106:	29 f1       	breq	.+74     	; 0x152 <digitalWrite.constprop.0+0x72>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	ee 0f       	add	r30, r30
 10c:	ff 1f       	adc	r31, r31
 10e:	ee 58       	subi	r30, 0x8E	; 142
 110:	ff 4f       	sbci	r31, 0xFF	; 255
 112:	a5 91       	lpm	r26, Z+
 114:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 116:	2f b7       	in	r18, 0x3f	; 63
	cli();
 118:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
 11a:	ec 91       	ld	r30, X
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	81 11       	cpse	r24, r1
 11e:	26 c0       	rjmp	.+76     	; 0x16c <digitalWrite.constprop.0+0x8c>
		*out &= ~bit;
 120:	90 95       	com	r25
 122:	9e 23       	and	r25, r30
	} else {
		*out |= bit;
 124:	9c 93       	st	X, r25
	}

	SREG = oldSREG;
 126:	2f bf       	out	0x3f, r18	; 63
}
 128:	08 95       	ret
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	27 30       	cpi	r18, 0x07	; 7
 12c:	a9 f0       	breq	.+42     	; 0x158 <digitalWrite.constprop.0+0x78>
 12e:	28 30       	cpi	r18, 0x08	; 8
 130:	c9 f0       	breq	.+50     	; 0x164 <digitalWrite.constprop.0+0x84>
 132:	24 30       	cpi	r18, 0x04	; 4
 134:	49 f7       	brne	.-46     	; 0x108 <digitalWrite.constprop.0+0x28>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 13a:	2f 7d       	andi	r18, 0xDF	; 223
 13c:	03 c0       	rjmp	.+6      	; 0x144 <digitalWrite.constprop.0+0x64>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 142:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 148:	df cf       	rjmp	.-66     	; 0x108 <digitalWrite.constprop.0+0x28>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	24 b5       	in	r18, 0x24	; 36
 14c:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	24 bd       	out	0x24, r18	; 36
 150:	db cf       	rjmp	.-74     	; 0x108 <digitalWrite.constprop.0+0x28>
 152:	24 b5       	in	r18, 0x24	; 36
 154:	2f 7d       	andi	r18, 0xDF	; 223
 156:	fb cf       	rjmp	.-10     	; 0x14e <digitalWrite.constprop.0+0x6e>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 15c:	2f 77       	andi	r18, 0x7F	; 127
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 162:	d2 cf       	rjmp	.-92     	; 0x108 <digitalWrite.constprop.0+0x28>
 164:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 168:	2f 7d       	andi	r18, 0xDF	; 223
 16a:	f9 cf       	rjmp	.-14     	; 0x15e <digitalWrite.constprop.0+0x7e>
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	9e 2b       	or	r25, r30
 16e:	da cf       	rjmp	.-76     	; 0x124 <digitalWrite.constprop.0+0x44>

00000170 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	1f 92       	push	r1
 172:	0f 92       	push	r0
 174:	0f b6       	in	r0, 0x3f	; 63
 176:	0f 92       	push	r0
 178:	11 24       	eor	r1, r1
 17a:	2f 93       	push	r18
 17c:	3f 93       	push	r19
 17e:	8f 93       	push	r24
 180:	9f 93       	push	r25
 182:	af 93       	push	r26
 184:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <timer0_millis>
 18a:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <timer0_millis+0x1>
 18e:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <timer0_millis+0x2>
 192:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 196:	30 91 04 01 	lds	r19, 0x0104	; 0x800104 <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	23 e0       	ldi	r18, 0x03	; 3
 19c:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 19e:	2d 37       	cpi	r18, 0x7D	; 125
 1a0:	58 f5       	brcc	.+86     	; 0x1f8 <__vector_16+0x88>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	01 96       	adiw	r24, 0x01	; 1
 1a4:	a1 1d       	adc	r26, r1
 1a6:	b1 1d       	adc	r27, r1
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	20 93 04 01 	sts	0x0104, r18	; 0x800104 <timer0_fract>
	timer0_millis = m;
 1ac:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <timer0_millis>
 1b0:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <timer0_millis+0x1>
 1b4:	a0 93 07 01 	sts	0x0107, r26	; 0x800107 <timer0_millis+0x2>
 1b8:	b0 93 08 01 	sts	0x0108, r27	; 0x800108 <timer0_millis+0x3>
	timer0_overflow_count++;
 1bc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 1c0:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
 1c4:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <_edata+0x2>
 1c8:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <_edata+0x3>
 1cc:	01 96       	adiw	r24, 0x01	; 1
 1ce:	a1 1d       	adc	r26, r1
 1d0:	b1 1d       	adc	r27, r1
 1d2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 1d6:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <_edata+0x1>
 1da:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <_edata+0x2>
 1de:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <_edata+0x3>
}
 1e2:	bf 91       	pop	r27
 1e4:	af 91       	pop	r26
 1e6:	9f 91       	pop	r25
 1e8:	8f 91       	pop	r24
 1ea:	3f 91       	pop	r19
 1ec:	2f 91       	pop	r18
 1ee:	0f 90       	pop	r0
 1f0:	0f be       	out	0x3f, r0	; 63
 1f2:	0f 90       	pop	r0
 1f4:	1f 90       	pop	r1
 1f6:	18 95       	reti
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	26 e8       	ldi	r18, 0x86	; 134
 1fa:	23 0f       	add	r18, r19
		m += 1;
 1fc:	02 96       	adiw	r24, 0x02	; 2
 1fe:	a1 1d       	adc	r26, r1
 200:	b1 1d       	adc	r27, r1
 202:	d2 cf       	rjmp	.-92     	; 0x1a8 <__vector_16+0x38>

00000204 <main>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	84 b5       	in	r24, 0x24	; 36
 208:	82 60       	ori	r24, 0x02	; 2
 20a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 20c:	84 b5       	in	r24, 0x24	; 36
 20e:	81 60       	ori	r24, 0x01	; 1
 210:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	85 b5       	in	r24, 0x25	; 37
 214:	82 60       	ori	r24, 0x02	; 2
 216:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 218:	85 b5       	in	r24, 0x25	; 37
 21a:	81 60       	ori	r24, 0x01	; 1
 21c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 222:	81 60       	ori	r24, 0x01	; 1
 224:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 230:	82 60       	ori	r24, 0x02	; 2
 232:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 23a:	81 60       	ori	r24, 0x01	; 1
 23c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 244:	81 60       	ori	r24, 0x01	; 1
 246:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 24e:	84 60       	ori	r24, 0x04	; 4
 250:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 258:	81 60       	ori	r24, 0x01	; 1
 25a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 262:	84 60       	ori	r24, 0x04	; 4
 264:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS1);
 268:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 26c:	82 60       	ori	r24, 0x02	; 2
 26e:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS0);
 272:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 276:	81 60       	ori	r24, 0x01	; 1
 278:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 280:	80 68       	ori	r24, 0x80	; 128
 282:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	ed e9       	ldi	r30, 0x9D	; 157
 28c:	f0 e0       	ldi	r31, 0x00	; 0
 28e:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 290:	e9 e8       	ldi	r30, 0x89	; 137
 292:	f0 e0       	ldi	r31, 0x00	; 0
 294:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	88 23       	and	r24, r24
 298:	99 f0       	breq	.+38     	; 0x2c0 <main+0xbc>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	88 0f       	add	r24, r24
 29e:	99 1f       	adc	r25, r25
 2a0:	fc 01       	movw	r30, r24
 2a2:	e8 59       	subi	r30, 0x98	; 152
 2a4:	ff 4f       	sbci	r31, 0xFF	; 255
 2a6:	a5 91       	lpm	r26, Z+
 2a8:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
 2aa:	fc 01       	movw	r30, r24
 2ac:	ee 58       	subi	r30, 0x8E	; 142
 2ae:	ff 4f       	sbci	r31, 0xFF	; 255
 2b0:	85 91       	lpm	r24, Z+
 2b2:	94 91       	lpm	r25, Z
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	8f b7       	in	r24, 0x3f	; 63
                cli();
 2b6:	f8 94       	cli
		*reg |= bit;
 2b8:	ec 91       	ld	r30, X
 2ba:	e2 2b       	or	r30, r18
 2bc:	ec 93       	st	X, r30
		SREG = oldSREG;
 2be:	8f bf       	out	0x3f, r24	; 63
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 2c0:	c0 e0       	ldi	r28, 0x00	; 0
 2c2:	d0 e0       	ldi	r29, 0x00	; 0
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	f8 94       	cli
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	80 e0       	ldi	r24, 0x00	; 0
 2c8:	0e 94 70 00 	call	0xe0	; 0xe0 <digitalWrite.constprop.0>
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	0e 94 70 00 	call	0xe0	; 0xe0 <digitalWrite.constprop.0>
	...
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay

  interrupts();
 f52:	78 94       	sei
 f54:	20 97       	sbiw	r28, 0x00	; 0
 f56:	11 f4       	brne	.+4      	; 0xf5c <__stack+0x65d>
 f58:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <main+0xc0>
 f5c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 f60:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <main+0xc0>

00000f64 <_exit>:
 f64:	f8 94       	cli

00000f66 <__stop_program>:
 f66:	ff cf       	rjmp	.-2      	; 0xf66 <__stop_program>

Disassembly of section .bss:

00800100 <__bss_start>:
  800100:	00 00       	nop
	...

00800104 <timer0_fract>:
	...

00800105 <timer0_millis>:
  800105:	00 00       	nop
	...

Disassembly of section .comment:

00000000 <_end-0x800109>:
   0:	47 43       	sbci	r20, 0x37	; 55
   2:	43 3a       	cpi	r20, 0xA3	; 163
   4:	20 28       	or	r2, r0
   6:	47 4e       	sbci	r20, 0xE7	; 231
   8:	55 29       	or	r21, r5
   a:	20 37       	cpi	r18, 0x70	; 112
   c:	2e 33       	cpi	r18, 0x3E	; 62
   e:	2e 30       	cpi	r18, 0x0E	; 14
	...

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 <.note.gnu.avr.deviceinfo>:
   0:	04 00       	.word	0x0004	; ????
   2:	00 00       	nop
   4:	2d 00       	.word	0x002d	; ????
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	00 00       	nop
   c:	41 56       	subi	r20, 0x61	; 97
   e:	52 00       	.word	0x0052	; ????
  10:	00 00       	nop
  12:	00 00       	nop
  14:	00 80       	ld	r0, Z
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	00 00       	nop
  1c:	00 08       	sbc	r0, r0
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 04       	cpc	r0, r0
  26:	00 00       	nop
  28:	08 00       	.word	0x0008	; ????
  2a:	00 00       	nop
  2c:	01 00       	.word	0x0001	; ????
  2e:	00 00       	nop
  30:	00 61       	ori	r16, 0x10	; 16
  32:	74 6d       	ori	r23, 0xD4	; 212
  34:	65 67       	ori	r22, 0x75	; 117
  36:	61 33       	cpi	r22, 0x31	; 49
  38:	32 38       	cpi	r19, 0x82	; 130
  3a:	70 00       	.word	0x0070	; ????
  3c:	00 00       	nop
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	24 00       	.word	0x0024	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	f4 05       	cpc	r31, r4
   8:	00 00       	nop
   a:	04 00       	.word	0x0004	; ????
   c:	00 00       	nop
   e:	00 00       	nop
  10:	e0 00       	.word	0x00e0	; ????
  12:	00 00       	nop
  14:	24 01       	movw	r4, r8
  16:	00 00       	nop
  18:	04 02       	muls	r16, r20
  1a:	00 00       	nop
  1c:	60 0d       	add	r22, r0
	...
  26:	00 00       	nop
  28:	1c 00       	.word	0x001c	; ????
  2a:	00 00       	nop
  2c:	02 00       	.word	0x0002	; ????
  2e:	d7 0b       	sbc	r29, r23
  30:	00 00       	nop
  32:	04 00       	.word	0x0004	; ????
  34:	00 00       	nop
  36:	00 00       	nop
  38:	64 0f       	add	r22, r20
  3a:	00 00       	nop
  3c:	04 00       	.word	0x0004	; ????
	...
  46:	00 00       	nop
  48:	1c 00       	.word	0x001c	; ????
  4a:	00 00       	nop
  4c:	02 00       	.word	0x0002	; ????
  4e:	92 0c       	add	r9, r2
  50:	00 00       	nop
  52:	04 00       	.word	0x0004	; ????
  54:	00 00       	nop
  56:	00 00       	nop
  58:	c4 00       	.word	0x00c4	; ????
  5a:	00 00       	nop
  5c:	10 00       	.word	0x0010	; ????
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
   0:	f0 05       	cpc	r31, r0
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	00 00       	nop
   8:	00 00       	nop
   a:	04 01       	movw	r0, r8
	...
  14:	02 0f       	add	r16, r18
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	08 03       	fmul	r16, r16
  1c:	17 00       	.word	0x0017	; ????
  1e:	00 00       	nop
  20:	02 07       	cpc	r16, r18
  22:	04 14       	cp	r0, r4
  24:	00 00       	nop
  26:	00 05       	cpc	r16, r0
  28:	1b 00       	.word	0x001b	; ????
  2a:	00 00       	nop
  2c:	ff 03       	fmulsu	r23, r23
  2e:	00 06       	cpc	r0, r16
  30:	20 00       	.word	0x0020	; ????
  32:	00 00       	nop
  34:	00 00       	nop
  36:	22 00       	.word	0x0022	; ????
  38:	00 00       	nop
  3a:	01 05       	cpc	r16, r1
  3c:	03 00       	.word	0x0003	; ????
  3e:	00 81       	ld	r16, Z
  40:	00 07       	cpc	r16, r16
  42:	29 00       	.word	0x0029	; ????
  44:	00 00       	nop
  46:	00 00       	nop
  48:	14 00       	.word	0x0014	; ????
  4a:	00 00       	nop
  4c:	01 05       	cpc	r16, r1
  4e:	03 c6       	rjmp	.+3078   	; 0xc56 <__stack+0x357>
  50:	00 80       	ld	r0, Z
  52:	00 08       	sbc	r0, r0
  54:	2e 00       	.word	0x002e	; ????
  56:	00 00       	nop
  58:	00 00       	nop
  5a:	14 00       	.word	0x0014	; ????
  5c:	00 00       	nop
  5e:	01 05       	cpc	r16, r1
  60:	03 c0       	rjmp	.+6      	; 0x68 <__trampolines_end>
  62:	00 80       	ld	r0, Z
  64:	00 09       	sbc	r16, r0
  66:	35 00       	.word	0x0035	; ????
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	14 00       	.word	0x0014	; ????
  6e:	00 00       	nop
  70:	01 05       	cpc	r16, r1
  72:	03 c1       	rjmp	.+518    	; 0x27a <main+0x76>
  74:	00 80       	ld	r0, Z
  76:	00 0a       	sbc	r0, r16
  78:	3c 00       	.word	0x003c	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	14 00       	.word	0x0014	; ????
  80:	00 00       	nop
  82:	01 05       	cpc	r16, r1
  84:	03 c2       	rjmp	.+1030   	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
  86:	00 80       	ld	r0, Z
  88:	00 0b       	sbc	r16, r16
  8a:	43 00       	.word	0x0043	; ????
  8c:	00 00       	nop
  8e:	00 00       	nop
  90:	1b 00       	.word	0x001b	; ????
  92:	00 00       	nop
  94:	01 05       	cpc	r16, r1
  96:	03 c4       	rjmp	.+2054   	; 0x89e <__LOCK_REGION_LENGTH__+0x49e>
  98:	00 80       	ld	r0, Z
  9a:	00 0c       	add	r0, r0
  9c:	49 00       	.word	0x0049	; ????
  9e:	00 00       	nop
  a0:	00 00       	nop
  a2:	14 00       	.word	0x0014	; ????
  a4:	00 00       	nop
  a6:	01 05       	cpc	r16, r1
  a8:	03 bd       	out	0x23, r16	; 35
  aa:	00 80       	ld	r0, Z
  ac:	00 0d       	add	r16, r0
  ae:	4f 00       	.word	0x004f	; ????
  b0:	00 00       	nop
  b2:	00 00       	nop
  b4:	14 00       	.word	0x0014	; ????
  b6:	00 00       	nop
  b8:	01 05       	cpc	r16, r1
  ba:	03 b8       	out	0x03, r0	; 3
  bc:	00 80       	ld	r0, Z
  be:	00 0e       	add	r0, r16
  c0:	54 00       	.word	0x0054	; ????
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	14 00       	.word	0x0014	; ????
  c8:	00 00       	nop
  ca:	01 05       	cpc	r16, r1
  cc:	03 bc       	out	0x23, r0	; 35
  ce:	00 80       	ld	r0, Z
  d0:	00 0f       	add	r16, r16
  d2:	59 00       	.word	0x0059	; ????
  d4:	00 00       	nop
  d6:	00 00       	nop
  d8:	14 00       	.word	0x0014	; ????
  da:	00 00       	nop
  dc:	01 05       	cpc	r16, r1
  de:	03 b9       	out	0x03, r16	; 3
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	00 80       	ld	r0, Z
  e2:	00 10       	cpse	r0, r0
  e4:	5e 00       	.word	0x005e	; ????
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	00 00       	nop
  e8:	00 00       	nop
  ea:	14 00       	.word	0x0014	; ????
	uint8_t port = digitalPinToPort(pin);
  ec:	00 00       	nop
  ee:	01 05       	cpc	r16, r1
  f0:	03 bb       	out	0x13, r16	; 19
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	00 80       	ld	r0, Z
  f4:	00 11       	cpse	r16, r0

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	63 00       	.word	0x0063	; ????
  f8:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 00       	nop
  fc:	14 00       	.word	0x0014	; ????
  fe:	00 00       	nop
 100:	01 05       	cpc	r16, r1
 102:	03 ba       	out	0x13, r0	; 19
 104:	00 80       	ld	r0, Z
 106:	00 12       	cpse	r0, r16

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	68 00       	.word	0x0068	; ????
 10a:	00 00       	nop
 10c:	00 00       	nop
 10e:	14 00       	.word	0x0014	; ????
 110:	00 00       	nop
 112:	01 05       	cpc	r16, r1
 114:	03 6f       	ori	r16, 0xF3	; 243

	uint8_t oldSREG = SREG;
 116:	00 80       	ld	r0, Z
	cli();
 118:	00 13       	cpse	r16, r16

	if (val == LOW) {
		*out &= ~bit;
 11a:	6f 00       	.word	0x006f	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 00       	nop
 11e:	00 00       	nop
		*out &= ~bit;
 120:	14 00       	.word	0x0014	; ????
 122:	00 00       	nop
	} else {
		*out |= bit;
 124:	01 05       	cpc	r16, r1
	}

	SREG = oldSREG;
 126:	03 36       	cpi	r16, 0x63	; 99
}
 128:	00 80       	ld	r0, Z
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	00 14       	cp	r0, r0
 12c:	75 00       	.word	0x0075	; ????
 12e:	00 00       	nop
 130:	00 00       	nop
 132:	14 00       	.word	0x0014	; ????
 134:	00 00       	nop
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	01 05       	cpc	r16, r1
 138:	03 80       	ldd	r0, Z+3	; 0x03
 13a:	00 80       	ld	r0, Z
 13c:	00 15       	cp	r16, r0
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	7c 00       	.word	0x007c	; ????
 140:	00 00       	nop
 142:	00 00       	nop
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	14 00       	.word	0x0014	; ????
 146:	00 00       	nop
 148:	01 05       	cpc	r16, r1
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	03 81       	ldd	r16, Z+3	; 0x03
 14c:	00 80       	ld	r0, Z
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	00 16       	cp	r0, r16
 150:	83 00       	.word	0x0083	; ????
 152:	00 00       	nop
 154:	00 00       	nop
 156:	14 00       	.word	0x0014	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	00 00       	nop
 15a:	01 05       	cpc	r16, r1
 15c:	03 82       	std	Z+3, r0	; 0x03
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	00 80       	ld	r0, Z
 160:	00 17       	cp	r16, r16
 162:	8a 00       	.word	0x008a	; ????
 164:	00 00       	nop
 166:	00 00       	nop
 168:	1b 00       	.word	0x001b	; ????
 16a:	00 00       	nop
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	01 05       	cpc	r16, r1
 16e:	03 84       	ldd	r0, Z+11	; 0x0b
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 80       	ld	r0, Z
 172:	00 18       	sub	r0, r0
 174:	90 00       	.word	0x0090	; ????
 176:	00 00       	nop
 178:	00 00       	nop
 17a:	1b 00       	.word	0x001b	; ????
 17c:	00 00       	nop
 17e:	01 05       	cpc	r16, r1
 180:	03 88       	ldd	r0, Z+19	; 0x13
 182:	00 80       	ld	r0, Z
 184:	00 19       	sub	r16, r0
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	96 00       	.word	0x0096	; ????
 188:	00 00       	nop
 18a:	00 00       	nop
 18c:	1b 00       	.word	0x001b	; ????
 18e:	00 00       	nop
 190:	01 05       	cpc	r16, r1
 192:	03 8a       	std	Z+19, r0	; 0x13
 194:	00 80       	ld	r0, Z
	unsigned char f = timer0_fract;
 196:	00 1a       	sub	r0, r16
 198:	9c 00       	.word	0x009c	; ????

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	00 00       	nop
 19c:	00 00       	nop
	if (f >= FRACT_MAX) {
 19e:	1b 00       	.word	0x001b	; ????
 1a0:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	01 05       	cpc	r16, r1
 1a4:	03 86       	std	Z+11, r0	; 0x0b
 1a6:	00 80       	ld	r0, Z
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	00 1b       	sub	r16, r16
 1aa:	a1 00       	.word	0x00a1	; ????
	timer0_millis = m;
 1ac:	00 00       	nop
 1ae:	00 00       	nop
 1b0:	14 00       	.word	0x0014	; ????
 1b2:	00 00       	nop
 1b4:	01 05       	cpc	r16, r1
 1b6:	03 43       	sbci	r16, 0x33	; 51
 1b8:	00 80       	ld	r0, Z
 1ba:	00 1c       	adc	r0, r0
	timer0_overflow_count++;
 1bc:	a7 00       	.word	0x00a7	; ????
 1be:	00 00       	nop
 1c0:	00 00       	nop
 1c2:	14 00       	.word	0x0014	; ????
 1c4:	00 00       	nop
 1c6:	01 05       	cpc	r16, r1
 1c8:	03 70       	andi	r16, 0x03	; 3
 1ca:	00 80       	ld	r0, Z
 1cc:	00 1d       	adc	r16, r0
 1ce:	ae 00       	.word	0x00ae	; ????
 1d0:	00 00       	nop
 1d2:	00 00       	nop
 1d4:	14 00       	.word	0x0014	; ????
 1d6:	00 00       	nop
 1d8:	01 05       	cpc	r16, r1
 1da:	03 37       	cpi	r16, 0x73	; 115
 1dc:	00 80       	ld	r0, Z
 1de:	00 1e       	adc	r0, r16
 1e0:	b4 00       	.word	0x00b4	; ????
}
 1e2:	00 00       	nop
 1e4:	00 00       	nop
 1e6:	14 00       	.word	0x0014	; ????
 1e8:	00 00       	nop
 1ea:	01 05       	cpc	r16, r1
 1ec:	03 b0       	in	r0, 0x03	; 3
 1ee:	00 80       	ld	r0, Z
 1f0:	00 1f       	adc	r16, r16
 1f2:	bb 00       	.word	0x00bb	; ????
 1f4:	00 00       	nop
 1f6:	00 00       	nop
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	14 00       	.word	0x0014	; ????
 1fa:	00 00       	nop
		m += 1;
 1fc:	01 05       	cpc	r16, r1
 1fe:	03 b1       	in	r16, 0x03	; 3
 200:	00 80       	ld	r0, Z
 202:	00 20       	and	r0, r0

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	c2 00       	.word	0x00c2	; ????
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	00 00       	nop
 208:	00 00       	nop
 20a:	14 00       	.word	0x0014	; ????
	sbi(TCCR0A, WGM00);
 20c:	00 00       	nop
 20e:	01 05       	cpc	r16, r1
 210:	03 b2       	in	r0, 0x13	; 19
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	00 80       	ld	r0, Z
 214:	00 21       	and	r16, r0
 216:	c8 00       	.word	0x00c8	; ????
	sbi(TCCR0B, CS00);
 218:	00 00       	nop
 21a:	00 00       	nop
 21c:	14 00       	.word	0x0014	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 00       	nop
 220:	01 05       	cpc	r16, r1
 222:	03 b4       	in	r0, 0x23	; 35
 224:	00 80       	ld	r0, Z
 226:	00 22       	and	r0, r16
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	ce 00       	.word	0x00ce	; ????
 22a:	00 00       	nop

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	00 00       	nop
 22e:	14 00       	.word	0x0014	; ????
 230:	00 00       	nop
 232:	01 05       	cpc	r16, r1
 234:	03 b3       	in	r16, 0x13	; 19
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 80       	ld	r0, Z
 238:	00 23       	and	r16, r16
 23a:	d4 00       	.word	0x00d4	; ????
 23c:	00 00       	nop
 23e:	00 00       	nop
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	14 00       	.word	0x0014	; ????
 242:	00 00       	nop
 244:	01 05       	cpc	r16, r1
 246:	03 b6       	in	r0, 0x33	; 51
 248:	00 80       	ld	r0, Z

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	00 24       	eor	r0, r0
 24c:	d9 00       	.word	0x00d9	; ????
 24e:	00 00       	nop
 250:	00 00       	nop
 252:	14 00       	.word	0x0014	; ????

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	00 00       	nop
 256:	01 05       	cpc	r16, r1
 258:	03 43       	sbci	r16, 0x33	; 51
 25a:	00 80       	ld	r0, Z
 25c:	00 25       	eor	r16, r0
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	df 00       	.word	0x00df	; ????
 260:	00 00       	nop
 262:	00 00       	nop
 264:	14 00       	.word	0x0014	; ????
 266:	00 00       	nop
		sbi(ADCSRA, ADPS1);
 268:	01 05       	cpc	r16, r1
 26a:	03 7c       	andi	r16, 0xC3	; 195
 26c:	00 80       	ld	r0, Z
 26e:	00 26       	eor	r0, r16
 270:	e5 00       	.word	0x00e5	; ????
		sbi(ADCSRA, ADPS0);
 272:	00 00       	nop
 274:	00 00       	nop
 276:	1b 00       	.word	0x001b	; ????
 278:	00 00       	nop
 27a:	01 05       	cpc	r16, r1
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	03 78       	andi	r16, 0x83	; 131
 27e:	00 80       	ld	r0, Z
 280:	00 27       	eor	r16, r16
 282:	e9 00       	.word	0x00e9	; ????
 284:	00 00       	nop
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	00 00       	nop
 288:	14 00       	.word	0x0014	; ????
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	00 00       	nop
 28c:	01 05       	cpc	r16, r1
 28e:	03 7a       	andi	r16, 0xA3	; 163
	uint8_t port = digitalPinToPort(pin);
 290:	00 80       	ld	r0, Z
 292:	00 28       	or	r0, r0
 294:	f0 00       	.word	0x00f0	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	00 00       	nop
 298:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	14 00       	.word	0x0014	; ????
 29c:	00 00       	nop
 29e:	01 05       	cpc	r16, r1
 2a0:	03 7b       	andi	r16, 0xB3	; 179
 2a2:	00 80       	ld	r0, Z
 2a4:	00 29       	or	r16, r0
 2a6:	f7 00       	.word	0x00f7	; ????
 2a8:	00 00       	nop
	out = portOutputRegister(port);
 2aa:	00 00       	nop
 2ac:	14 00       	.word	0x0014	; ????
 2ae:	00 00       	nop
 2b0:	01 05       	cpc	r16, r1
 2b2:	03 7e       	andi	r16, 0xE3	; 227
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	00 80       	ld	r0, Z
                cli();
 2b6:	00 2a       	or	r0, r16
		*reg |= bit;
 2b8:	fd 00       	.word	0x00fd	; ????
 2ba:	00 00       	nop
 2bc:	00 00       	nop
		SREG = oldSREG;
 2be:	14 00       	.word	0x0014	; ????
 2c0:	00 00       	nop
 2c2:	01 05       	cpc	r16, r1
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	03 50       	subi	r16, 0x03	; 3
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	00 80       	ld	r0, Z
 2c8:	00 2b       	or	r16, r16
 2ca:	02 01       	movw	r0, r4
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	00 00       	nop
 2ce:	00 00       	nop
 2d0:	14 00       	.word	0x0014	; ????
  
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2d2:	00 00       	nop
 2d4:	01 05       	cpc	r16, r1
 2d6:	03 7f       	andi	r16, 0xF3	; 243
 2d8:	00 80       	ld	r0, Z
 2da:	00 2c       	mov	r0, r0
 2dc:	08 01       	movw	r0, r16
 2de:	00 00       	nop
 2e0:	00 00       	nop
 2e2:	14 00       	.word	0x0014	; ????
 2e4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2e6:	01 05       	cpc	r16, r1
 2e8:	03 25       	eor	r16, r3
 2ea:	00 80       	ld	r0, Z
 2ec:	00 2d       	mov	r16, r0
 2ee:	0e 01       	movw	r0, r28
 2f0:	00 00       	nop
 2f2:	00 00       	nop
 2f4:	14 00       	.word	0x0014	; ????
 2f6:	00 00       	nop
 2f8:	01 05       	cpc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2fa:	03 24       	eor	r0, r3
 2fc:	00 80       	ld	r0, Z
 2fe:	00 2e       	mov	r0, r16
 300:	13 01       	movw	r2, r6
 302:	00 00       	nop
 304:	00 00       	nop
 306:	14 00       	.word	0x0014	; ????
 308:	00 00       	nop
 30a:	01 05       	cpc	r16, r1
 30c:	03 23       	and	r16, r19
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 30e:	00 80       	ld	r0, Z
 310:	00 2f       	mov	r16, r16
 312:	18 01       	movw	r2, r16
 314:	00 00       	nop
 316:	00 00       	nop
 318:	14 00       	.word	0x0014	; ????
 31a:	00 00       	nop
 31c:	01 05       	cpc	r16, r1
 31e:	03 28       	or	r0, r3
 320:	00 80       	ld	r0, Z
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 322:	00 30       	cpi	r16, 0x00	; 0
 324:	1e 01       	movw	r2, r28
 326:	00 00       	nop
 328:	00 00       	nop
 32a:	14 00       	.word	0x0014	; ????
 32c:	00 00       	nop
 32e:	01 05       	cpc	r16, r1
 330:	03 27       	eor	r16, r19
 332:	00 80       	ld	r0, Z
 334:	00 31       	cpi	r16, 0x10	; 16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 336:	23 01       	movw	r4, r6
 338:	00 00       	nop
 33a:	00 00       	nop
 33c:	14 00       	.word	0x0014	; ????
 33e:	00 00       	nop
 340:	01 05       	cpc	r16, r1
 342:	03 26       	eor	r0, r19
 344:	00 80       	ld	r0, Z
 346:	00 32       	cpi	r16, 0x20	; 32
 348:	28 01       	movw	r4, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 34a:	00 00       	nop
 34c:	00 00       	nop
 34e:	14 00       	.word	0x0014	; ????
 350:	00 00       	nop
 352:	01 05       	cpc	r16, r1
 354:	03 2b       	or	r16, r19
 356:	00 80       	ld	r0, Z
 358:	00 33       	cpi	r16, 0x30	; 48
 35a:	2e 01       	movw	r4, r28
 35c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 35e:	00 00       	nop
 360:	14 00       	.word	0x0014	; ????
 362:	00 00       	nop
 364:	01 05       	cpc	r16, r1
 366:	03 2a       	or	r0, r19
 368:	00 80       	ld	r0, Z
 36a:	00 34       	cpi	r16, 0x40	; 64
 36c:	33 01       	movw	r6, r6
 36e:	00 00       	nop
 370:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 372:	14 00       	.word	0x0014	; ????
 374:	00 00       	nop
 376:	01 05       	cpc	r16, r1
 378:	03 29       	or	r16, r3
 37a:	00 80       	ld	r0, Z
 37c:	00 35       	cpi	r16, 0x50	; 80
 37e:	38 01       	movw	r6, r16
 380:	00 00       	nop
 382:	00 00       	nop
 384:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 386:	00 00       	nop
 388:	01 05       	cpc	r16, r1
 38a:	03 48       	sbci	r16, 0x83	; 131
 38c:	00 80       	ld	r0, Z
 38e:	00 36       	cpi	r16, 0x60	; 96
 390:	3e 01       	movw	r6, r28
 392:	00 00       	nop
 394:	00 00       	nop
 396:	14 00       	.word	0x0014	; ????
 398:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 39a:	01 05       	cpc	r16, r1
 39c:	03 47       	sbci	r16, 0x73	; 115
 39e:	00 80       	ld	r0, Z
 3a0:	00 37       	cpi	r16, 0x70	; 112
 3a2:	44 01       	movw	r8, r8
 3a4:	00 00       	nop
 3a6:	00 00       	nop
 3a8:	14 00       	.word	0x0014	; ????
 3aa:	00 00       	nop
 3ac:	01 05       	cpc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ae:	03 46       	sbci	r16, 0x63	; 99
 3b0:	00 80       	ld	r0, Z
 3b2:	00 38       	cpi	r16, 0x80	; 128
 3b4:	4a 01       	movw	r8, r20
 3b6:	00 00       	nop
 3b8:	00 00       	nop
 3ba:	14 00       	.word	0x0014	; ????
 3bc:	00 00       	nop
 3be:	01 05       	cpc	r16, r1
 3c0:	03 45       	sbci	r16, 0x53	; 83
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3c2:	00 80       	ld	r0, Z
 3c4:	00 39       	cpi	r16, 0x90	; 144
 3c6:	51 01       	movw	r10, r2
 3c8:	00 00       	nop
 3ca:	00 00       	nop
 3cc:	14 00       	.word	0x0014	; ????
 3ce:	00 00       	nop
 3d0:	01 05       	cpc	r16, r1
 3d2:	03 44       	sbci	r16, 0x43	; 67
 3d4:	00 80       	ld	r0, Z
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3d6:	00 3a       	cpi	r16, 0xA0	; 160
 3d8:	58 01       	movw	r10, r16
 3da:	00 00       	nop
 3dc:	00 00       	nop
 3de:	14 00       	.word	0x0014	; ????
 3e0:	00 00       	nop
 3e2:	01 05       	cpc	r16, r1
 3e4:	03 6e       	ori	r16, 0xE3	; 227
 3e6:	00 80       	ld	r0, Z
 3e8:	00 3b       	cpi	r16, 0xB0	; 176
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ea:	5f 01       	movw	r10, r30
 3ec:	00 00       	nop
 3ee:	00 00       	nop
 3f0:	14 00       	.word	0x0014	; ????
 3f2:	00 00       	nop
 3f4:	01 05       	cpc	r16, r1
 3f6:	03 35       	cpi	r16, 0x53	; 83
 3f8:	00 80       	ld	r0, Z
 3fa:	00 3c       	cpi	r16, 0xC0	; 192
 3fc:	65 01       	movw	r12, r10
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3fe:	00 00       	nop
 400:	00 00       	nop
 402:	14 00       	.word	0x0014	; ????
 404:	00 00       	nop
 406:	01 05       	cpc	r16, r1
 408:	03 43       	sbci	r16, 0x33	; 51
 40a:	00 80       	ld	r0, Z
 40c:	00 3d       	cpi	r16, 0xD0	; 208
 40e:	6b 01       	movw	r12, r22
 410:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 412:	00 00       	nop
 414:	14 00       	.word	0x0014	; ????
 416:	00 00       	nop
 418:	01 05       	cpc	r16, r1
 41a:	03 69       	ori	r16, 0x93	; 147
 41c:	00 80       	ld	r0, Z
 41e:	00 3e       	cpi	r16, 0xE0	; 224
 420:	71 01       	movw	r14, r2
 422:	00 00       	nop
 424:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 426:	14 00       	.word	0x0014	; ????
 428:	00 00       	nop
 42a:	01 05       	cpc	r16, r1
 42c:	03 3d       	cpi	r16, 0xD3	; 211
 42e:	00 80       	ld	r0, Z
 430:	00 3f       	cpi	r16, 0xF0	; 240
 432:	77 01       	movw	r14, r14
 434:	00 00       	nop
 436:	00 00       	nop
 438:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 43a:	00 00       	nop
 43c:	01 05       	cpc	r16, r1
 43e:	03 3c       	cpi	r16, 0xC3	; 195
 440:	00 80       	ld	r0, Z
 442:	00 40       	sbci	r16, 0x00	; 0
 444:	7c 01       	movw	r14, r24
 446:	00 00       	nop
 448:	00 00       	nop
 44a:	14 00       	.word	0x0014	; ????
 44c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 44e:	01 05       	cpc	r16, r1
 450:	03 68       	ori	r16, 0x83	; 131
 452:	00 80       	ld	r0, Z
 454:	00 41       	sbci	r16, 0x10	; 16
 456:	82 01       	movw	r16, r4
 458:	00 00       	nop
 45a:	00 00       	nop
 45c:	14 00       	.word	0x0014	; ????
 45e:	00 00       	nop
 460:	01 05       	cpc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 462:	03 6d       	ori	r16, 0xD3	; 211
 464:	00 80       	ld	r0, Z
 466:	00 42       	sbci	r16, 0x20	; 32
 468:	89 01       	movw	r16, r18
 46a:	00 00       	nop
 46c:	00 00       	nop
 46e:	14 00       	.word	0x0014	; ????
 470:	00 00       	nop
 472:	01 05       	cpc	r16, r1
 474:	03 6c       	ori	r16, 0xC3	; 195
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 476:	00 80       	ld	r0, Z
 478:	00 43       	sbci	r16, 0x30	; 48
 47a:	90 01       	movw	r18, r0
 47c:	00 00       	nop
 47e:	00 00       	nop
 480:	14 00       	.word	0x0014	; ????
 482:	00 00       	nop
 484:	01 05       	cpc	r16, r1
 486:	03 6b       	ori	r16, 0xB3	; 179
 488:	00 80       	ld	r0, Z
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 48a:	00 44       	sbci	r16, 0x40	; 64
 48c:	97 01       	movw	r18, r14
 48e:	00 00       	nop
 490:	00 00       	nop
 492:	14 00       	.word	0x0014	; ????
 494:	00 00       	nop
 496:	01 05       	cpc	r16, r1
 498:	03 3b       	cpi	r16, 0xB3	; 179
 49a:	00 80       	ld	r0, Z
 49c:	00 45       	sbci	r16, 0x50	; 80
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 49e:	9d 01       	movw	r18, r26
 4a0:	00 00       	nop
 4a2:	00 00       	nop
 4a4:	14 00       	.word	0x0014	; ????
 4a6:	00 00       	nop
 4a8:	01 05       	cpc	r16, r1
 4aa:	03 4e       	sbci	r16, 0xE3	; 227
 4ac:	00 80       	ld	r0, Z
 4ae:	00 46       	sbci	r16, 0x60	; 96
 4b0:	a2 01       	movw	r20, r4
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4b2:	00 00       	nop
 4b4:	00 00       	nop
 4b6:	14 00       	.word	0x0014	; ????
 4b8:	00 00       	nop
 4ba:	01 05       	cpc	r16, r1
 4bc:	03 4d       	sbci	r16, 0xD3	; 211
 4be:	00 80       	ld	r0, Z
 4c0:	00 47       	sbci	r16, 0x70	; 112
 4c2:	a7 01       	movw	r20, r14
 4c4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4c6:	00 00       	nop
 4c8:	14 00       	.word	0x0014	; ????
 4ca:	00 00       	nop
 4cc:	01 05       	cpc	r16, r1
 4ce:	03 4c       	sbci	r16, 0xC3	; 195
 4d0:	00 80       	ld	r0, Z
 4d2:	00 48       	sbci	r16, 0x80	; 128
 4d4:	ac 01       	movw	r20, r24
 4d6:	00 00       	nop
 4d8:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4da:	14 00       	.word	0x0014	; ????
 4dc:	00 00       	nop
 4de:	01 05       	cpc	r16, r1
 4e0:	03 60       	ori	r16, 0x03	; 3
 4e2:	00 80       	ld	r0, Z
 4e4:	00 49       	sbci	r16, 0x90	; 144
 4e6:	b3 01       	movw	r22, r6
 4e8:	00 00       	nop
 4ea:	00 00       	nop
 4ec:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4ee:	00 00       	nop
 4f0:	01 05       	cpc	r16, r1
 4f2:	03 64       	ori	r16, 0x43	; 67
 4f4:	00 80       	ld	r0, Z
 4f6:	00 4a       	sbci	r16, 0xA0	; 160
 4f8:	b7 01       	movw	r22, r14
 4fa:	00 00       	nop
 4fc:	00 00       	nop
 4fe:	14 00       	.word	0x0014	; ????
 500:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 502:	01 05       	cpc	r16, r1
 504:	03 66       	ori	r16, 0x63	; 99
 506:	00 80       	ld	r0, Z
 508:	00 4b       	sbci	r16, 0xB0	; 176
 50a:	be 01       	movw	r22, r28
 50c:	00 00       	nop
 50e:	00 00       	nop
 510:	14 00       	.word	0x0014	; ????
 512:	00 00       	nop
 514:	01 05       	cpc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 516:	03 61       	ori	r16, 0x13	; 19
 518:	00 80       	ld	r0, Z
 51a:	00 4c       	sbci	r16, 0xC0	; 192
 51c:	c4 01       	movw	r24, r8
 51e:	00 00       	nop
 520:	00 00       	nop
 522:	14 00       	.word	0x0014	; ????
 524:	00 00       	nop
 526:	01 05       	cpc	r16, r1
 528:	03 5f       	subi	r16, 0xF3	; 243
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 52a:	00 80       	ld	r0, Z
 52c:	00 4d       	sbci	r16, 0xD0	; 208
 52e:	c9 01       	movw	r24, r18
 530:	00 00       	nop
 532:	00 00       	nop
 534:	1b 00       	.word	0x001b	; ????
 536:	00 00       	nop
 538:	01 05       	cpc	r16, r1
 53a:	03 5d       	subi	r16, 0xD3	; 211
 53c:	00 80       	ld	r0, Z
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 53e:	00 4e       	sbci	r16, 0xE0	; 224
 540:	cc 01       	movw	r24, r24
 542:	00 00       	nop
 544:	00 00       	nop
 546:	14 00       	.word	0x0014	; ????
 548:	00 00       	nop
 54a:	01 05       	cpc	r16, r1
 54c:	03 57       	subi	r16, 0x73	; 115
 54e:	00 80       	ld	r0, Z
 550:	00 4f       	sbci	r16, 0xF0	; 240
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 552:	d3 01       	movw	r26, r6
 554:	00 00       	nop
 556:	00 00       	nop
 558:	14 00       	.word	0x0014	; ????
 55a:	00 00       	nop
 55c:	01 05       	cpc	r16, r1
 55e:	03 55       	subi	r16, 0x53	; 83
 560:	00 80       	ld	r0, Z
 562:	00 50       	subi	r16, 0x00	; 0
 564:	d9 01       	movw	r26, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 566:	00 00       	nop
 568:	00 00       	nop
 56a:	14 00       	.word	0x0014	; ????
 56c:	00 00       	nop
 56e:	01 05       	cpc	r16, r1
 570:	03 54       	subi	r16, 0x43	; 67
 572:	00 80       	ld	r0, Z
 574:	00 51       	subi	r16, 0x10	; 16
 576:	df 01       	movw	r26, r30
 578:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 57a:	00 00       	nop
 57c:	14 00       	.word	0x0014	; ????
 57e:	00 00       	nop
 580:	01 05       	cpc	r16, r1
 582:	03 53       	subi	r16, 0x33	; 51
 584:	00 80       	ld	r0, Z
 586:	00 52       	subi	r16, 0x20	; 32
 588:	e4 01       	movw	r28, r8
 58a:	00 00       	nop
 58c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 58e:	14 00       	.word	0x0014	; ????
 590:	00 00       	nop
 592:	01 05       	cpc	r16, r1
 594:	03 4b       	sbci	r16, 0xB3	; 179
 596:	00 80       	ld	r0, Z
 598:	00 53       	subi	r16, 0x30	; 48
 59a:	eb 01       	movw	r28, r22
 59c:	00 00       	nop
 59e:	00 00       	nop
 5a0:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5a2:	00 00       	nop
 5a4:	01 05       	cpc	r16, r1
 5a6:	03 4a       	sbci	r16, 0xA3	; 163
 5a8:	00 80       	ld	r0, Z
 5aa:	00 54       	subi	r16, 0x40	; 64
 5ac:	f2 01       	movw	r30, r4
 5ae:	00 00       	nop
 5b0:	00 00       	nop
 5b2:	14 00       	.word	0x0014	; ????
 5b4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5b6:	01 05       	cpc	r16, r1
 5b8:	03 3e       	cpi	r16, 0xE3	; 227
 5ba:	00 80       	ld	r0, Z
 5bc:	00 55       	subi	r16, 0x50	; 80
 5be:	f9 01       	movw	r30, r18
 5c0:	00 00       	nop
 5c2:	00 00       	nop
 5c4:	1b 00       	.word	0x001b	; ????
 5c6:	00 00       	nop
 5c8:	01 05       	cpc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5ca:	03 41       	sbci	r16, 0x13	; 19
 5cc:	00 80       	ld	r0, Z
 5ce:	00 56       	subi	r16, 0x60	; 96
 5d0:	fe 01       	movw	r30, r28
 5d2:	00 00       	nop
 5d4:	00 00       	nop
 5d6:	14 00       	.word	0x0014	; ????
 5d8:	00 00       	nop
 5da:	01 05       	cpc	r16, r1
 5dc:	03 40       	sbci	r16, 0x03	; 3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5de:	00 80       	ld	r0, Z
 5e0:	00 57       	subi	r16, 0x70	; 112
 5e2:	03 02       	muls	r16, r19
 5e4:	00 00       	nop
 5e6:	00 00       	nop
 5e8:	14 00       	.word	0x0014	; ????
 5ea:	00 00       	nop
 5ec:	01 05       	cpc	r16, r1
 5ee:	03 3f       	cpi	r16, 0xF3	; 243
 5f0:	00 80       	ld	r0, Z
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5f2:	00 00       	nop
 5f4:	df 05       	cpc	r29, r15
 5f6:	00 00       	nop
 5f8:	02 00       	.word	0x0002	; ????
 5fa:	a2 05       	cpc	r26, r2
 5fc:	00 00       	nop
 5fe:	04 01       	movw	r0, r8
 600:	d3 02       	muls	r29, r19
 602:	00 00       	nop
 604:	04 72       	andi	r16, 0x24	; 36
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 606:	02 00       	.word	0x0002	; ????
 608:	00 11       	cpse	r16, r0
 60a:	04 00       	.word	0x0004	; ????
 60c:	00 18       	sub	r0, r0
	...
 616:	00 00       	nop
 618:	00 1a       	sub	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 61a:	00 00       	nop
 61c:	00 02       	muls	r16, r16
 61e:	ac 02       	muls	r26, r28
 620:	00 00       	nop
 622:	05 7e       	andi	r16, 0xE5	; 229
 624:	34 00       	.word	0x0034	; ????
 626:	00 00       	nop
 628:	03 01       	movw	r0, r6
 62a:	08 b4       	in	r0, 0x28	; 40
 62c:	02 00       	.word	0x0002	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 62e:	00 02       	muls	r16, r16
 630:	86 04       	cpc	r8, r6
 632:	00 00       	nop
 634:	05 80       	ldd	r0, Z+5	; 0x05
 636:	4b 00       	.word	0x004b	; ????
 638:	00 00       	nop
 63a:	04 3b       	cpi	r16, 0xB4	; 180
 63c:	00 00       	nop
 63e:	00 03       	mulsu	r16, r16
 640:	02 07       	cpc	r16, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 642:	d7 03       	fmuls	r21, r23
 644:	00 00       	nop
 646:	05 a6       	std	Z+45, r0	; 0x2d
 648:	04 00       	.word	0x0004	; ????
 64a:	00 01       	movw	r0, r0
 64c:	1d 01       	movw	r2, r26
 64e:	40 01       	movw	r8, r0
 650:	00 00       	nop
 652:	06 70       	andi	r16, 0x06	; 6
 654:	69 6e       	ori	r22, 0xE9	; 233
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 656:	00 01       	movw	r0, r0
 658:	1d 29       	or	r17, r13
 65a:	00 00       	nop
 65c:	00 07       	cpc	r16, r16
 65e:	1a 02       	muls	r17, r26
 660:	00 00       	nop
 662:	01 1d       	adc	r16, r1
 664:	29 00       	.word	0x0029	; ????
 666:	00 00       	nop
 668:	08 62       	ori	r16, 0x28	; 40
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 66a:	69 74       	andi	r22, 0x49	; 73
 66c:	00 01       	movw	r0, r0
 66e:	1f 29       	or	r17, r15
 670:	00 00       	nop
 672:	00 09       	sbc	r16, r0
 674:	88 02       	muls	r24, r24
 676:	00 00       	nop
 678:	01 20       	and	r0, r1
 67a:	29 00       	.word	0x0029	; ????
 67c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 67e:	08 72       	andi	r16, 0x28	; 40
 680:	65 67       	ori	r22, 0x75	; 117
 682:	00 01       	movw	r0, r0
 684:	21 40       	sbci	r18, 0x01	; 1
 686:	01 00       	.word	0x0001	; ????
 688:	00 08       	sbc	r0, r0
 68a:	6f 75       	andi	r22, 0x5F	; 95
 68c:	74 00       	.word	0x0074	; ????
 68e:	01 21       	and	r16, r1
 690:	40 01       	movw	r8, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 692:	00 00       	nop
 694:	0a b1       	in	r16, 0x0a	; 10
 696:	00 00       	nop
 698:	00 09       	sbc	r16, r0
 69a:	ae 04       	cpc	r10, r14
 69c:	00 00       	nop
 69e:	01 36       	cpi	r16, 0x61	; 97
 6a0:	29 00       	.word	0x0029	; ????
 6a2:	00 00       	nop
 6a4:	00 0a       	sbc	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6a6:	c2 00       	.word	0x00c2	; ????
 6a8:	00 00       	nop
 6aa:	09 ae       	std	Y+57, r0	; 0x39
 6ac:	04 00       	.word	0x0004	; ????
 6ae:	00 01       	movw	r0, r0
 6b0:	30 29       	or	r19, r0
 6b2:	00 00       	nop
 6b4:	00 00       	nop
 6b6:	0a d3       	rcall	.+1556   	; 0xccc <__stack+0x3cd>
 6b8:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ba:	00 09       	sbc	r16, r0
 6bc:	ae 04       	cpc	r10, r14
 6be:	00 00       	nop
 6c0:	01 2a       	or	r0, r17
 6c2:	29 00       	.word	0x0029	; ????
 6c4:	00 00       	nop
 6c6:	00 0a       	sbc	r0, r16
 6c8:	ef 00       	.word	0x00ef	; ????
 6ca:	00 00       	nop
 6cc:	09 7f       	andi	r16, 0xF9	; 249
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ce:	02 00       	.word	0x0002	; ????
 6d0:	00 01       	movw	r0, r0
 6d2:	27 3b       	cpi	r18, 0xB7	; 183
 6d4:	00 00       	nop
 6d6:	00 09       	sbc	r16, r0
 6d8:	08 04       	cpc	r0, r8
 6da:	00 00       	nop
 6dc:	01 27       	eor	r16, r17
 6de:	3b 00       	.word	0x003b	; ????
 6e0:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6e2:	00 0a       	sbc	r0, r16
 6e4:	0b 01       	movw	r0, r22
 6e6:	00 00       	nop
 6e8:	09 7f       	andi	r16, 0xF9	; 249
 6ea:	02 00       	.word	0x0002	; ????
 6ec:	00 01       	movw	r0, r0
 6ee:	26 3b       	cpi	r18, 0xB6	; 182
 6f0:	00 00       	nop
 6f2:	00 09       	sbc	r16, r0
 6f4:	08 04       	cpc	r0, r8
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6f6:	00 00       	nop
 6f8:	01 26       	eor	r0, r17
 6fa:	3b 00       	.word	0x003b	; ????
 6fc:	00 00       	nop
 6fe:	00 0a       	sbc	r0, r16
 700:	27 01       	movw	r4, r14
 702:	00 00       	nop
 704:	09 7f       	andi	r16, 0xF9	; 249
 706:	02 00       	.word	0x0002	; ????
 708:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 70a:	20 3b       	cpi	r18, 0xB0	; 176
 70c:	00 00       	nop
 70e:	00 09       	sbc	r16, r0
 710:	08 04       	cpc	r0, r8
 712:	00 00       	nop
 714:	01 20       	and	r0, r1
 716:	29 00       	.word	0x0029	; ????
 718:	00 00       	nop
 71a:	00 0b       	sbc	r16, r16
 71c:	09 7f       	andi	r16, 0xF9	; 249
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 71e:	02 00       	.word	0x0002	; ????
 720:	00 01       	movw	r0, r0
 722:	1f 3b       	cpi	r17, 0xBF	; 191
 724:	00 00       	nop
 726:	00 09       	sbc	r16, r0
 728:	08 04       	cpc	r0, r8
 72a:	00 00       	nop
 72c:	01 1f       	adc	r16, r17
 72e:	29 00       	.word	0x0029	; ????
 730:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 732:	00 00       	nop
 734:	0c 02       	muls	r16, r28
 736:	4d 01       	movw	r8, r26
 738:	00 00       	nop
 73a:	03 01       	movw	r0, r6
 73c:	08 ac       	ldd	r0, Y+56	; 0x38
 73e:	02 00       	.word	0x0002	; ????
 740:	00 0d       	add	r16, r0
 742:	46 01       	movw	r8, r12
 744:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 746:	05 08       	sbc	r0, r5
 748:	02 00       	.word	0x0002	; ????
 74a:	00 01       	movw	r0, r0
 74c:	8a 01       	movw	r16, r20
 74e:	18 02       	muls	r17, r24
 750:	00 00       	nop
 752:	06 70       	andi	r16, 0x06	; 6
 754:	69 6e       	ori	r22, 0xE9	; 233
 756:	00 01       	movw	r0, r0
 758:	8a 29       	or	r24, r10
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 75a:	00 00       	nop
 75c:	00 06       	cpc	r0, r16
 75e:	76 61       	ori	r23, 0x16	; 22
 760:	6c 00       	.word	0x006c	; ????
 762:	01 8a       	std	Z+17, r0	; 0x11
 764:	29 00       	.word	0x0029	; ????
 766:	00 00       	nop
 768:	09 a0       	ldd	r0, Y+33	; 0x21
 76a:	04 00       	.word	0x0004	; ????
 76c:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 76e:	8c 29       	or	r24, r12
 770:	00 00       	nop
 772:	00 08       	sbc	r0, r0
 774:	62 69       	ori	r22, 0x92	; 146
 776:	74 00       	.word	0x0074	; ????
 778:	01 8d       	ldd	r16, Z+25	; 0x19
 77a:	29 00       	.word	0x0029	; ????
 77c:	00 00       	nop
 77e:	09 88       	ldd	r0, Y+17	; 0x11
 780:	02 00       	.word	0x0002	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 782:	00 01       	movw	r0, r0
 784:	8e 29       	or	r24, r14
 786:	00 00       	nop
 788:	00 08       	sbc	r0, r0
 78a:	6f 75       	andi	r22, 0x5F	; 95
 78c:	74 00       	.word	0x0074	; ????
 78e:	01 8f       	std	Z+25, r16	; 0x19
 790:	40 01       	movw	r8, r0
 792:	00 00       	nop
 794:	09 ae       	std	Y+57, r0	; 0x39
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 796:	04 00       	.word	0x0004	; ????
 798:	00 01       	movw	r0, r0
 79a:	99 29       	or	r25, r9
 79c:	00 00       	nop
 79e:	00 0a       	sbc	r0, r16
 7a0:	c7 01       	movw	r24, r14
 7a2:	00 00       	nop
 7a4:	09 7f       	andi	r16, 0xF9	; 249
 7a6:	02 00       	.word	0x0002	; ????
 7a8:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7aa:	97 3b       	cpi	r25, 0xB7	; 183
 7ac:	00 00       	nop
 7ae:	00 09       	sbc	r16, r0
 7b0:	08 04       	cpc	r0, r8
 7b2:	00 00       	nop
 7b4:	01 97       	sbiw	r24, 0x01	; 1
 7b6:	3b 00       	.word	0x003b	; ????
 7b8:	00 00       	nop
 7ba:	00 0a       	sbc	r0, r16
 7bc:	e3 01       	movw	r28, r6
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7be:	00 00       	nop
 7c0:	09 7f       	andi	r16, 0xF9	; 249
 7c2:	02 00       	.word	0x0002	; ????
 7c4:	00 01       	movw	r0, r0
 7c6:	8e 3b       	cpi	r24, 0xBE	; 190
 7c8:	00 00       	nop
 7ca:	00 09       	sbc	r16, r0
 7cc:	08 04       	cpc	r0, r8
 7ce:	00 00       	nop
 7d0:	01 8e       	std	Z+25, r0	; 0x19
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7d2:	29 00       	.word	0x0029	; ????
 7d4:	00 00       	nop
 7d6:	00 0a       	sbc	r0, r16
 7d8:	ff 01       	movw	r30, r30
 7da:	00 00       	nop
 7dc:	09 7f       	andi	r16, 0xF9	; 249
 7de:	02 00       	.word	0x0002	; ????
 7e0:	00 01       	movw	r0, r0
 7e2:	8d 3b       	cpi	r24, 0xBD	; 189
 7e4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7e6:	00 09       	sbc	r16, r0
 7e8:	08 04       	cpc	r0, r8
 7ea:	00 00       	nop
 7ec:	01 8d       	ldd	r16, Z+25	; 0x19
 7ee:	29 00       	.word	0x0029	; ????
 7f0:	00 00       	nop
 7f2:	00 0b       	sbc	r16, r16
 7f4:	09 7f       	andi	r16, 0xF9	; 249
 7f6:	02 00       	.word	0x0002	; ????
 7f8:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7fa:	8c 3b       	cpi	r24, 0xBC	; 188
 7fc:	00 00       	nop
 7fe:	00 09       	sbc	r16, r0
 800:	08 04       	cpc	r0, r8
 802:	00 00       	nop
 804:	01 8c       	ldd	r0, Z+25	; 0x19
 806:	29 00       	.word	0x0029	; ????
 808:	00 00       	nop
 80a:	00 00       	nop
 80c:	05 e4       	ldi	r16, 0x45	; 69
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 80e:	03 00       	.word	0x0003	; ????
 810:	00 01       	movw	r0, r0
 812:	4b 01       	movw	r8, r22
 814:	30 02       	muls	r19, r16
 816:	00 00       	nop
 818:	07 a0       	ldd	r0, Z+39	; 0x27
 81a:	04 00       	.word	0x0004	; ????
 81c:	00 01       	movw	r0, r0
 81e:	4b 29       	or	r20, r11
 820:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 822:	00 00       	nop
 824:	0e 8d       	ldd	r16, Y+30	; 0x1e
 826:	02 00       	.word	0x0002	; ????
 828:	00 01       	movw	r0, r0
 82a:	01 47       	sbci	r16, 0x71	; 113
 82c:	02 00       	.word	0x0002	; ????
 82e:	00 09       	sbc	r16, r0
 830:	a0 04       	cpc	r10, r0
 832:	00 00       	nop
 834:	01 4b       	sbci	r16, 0xB1	; 177
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 836:	29 00       	.word	0x0029	; ????
 838:	00 00       	nop
 83a:	00 0f       	add	r16, r16
 83c:	52 01       	movw	r10, r4
 83e:	00 00       	nop
 840:	e0 00       	.word	0x00e0	; ????
 842:	00 00       	nop
 844:	70 01       	movw	r14, r0
 846:	00 00       	nop
 848:	03 92       	.word	0x9203	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 84a:	20 02       	muls	r18, r16
 84c:	01 50       	subi	r16, 0x01	; 1
 84e:	03 00       	.word	0x0003	; ????
 850:	00 10       	cpse	r0, r0
 852:	69 01       	movw	r12, r18
 854:	00 00       	nop
 856:	01 68       	ori	r16, 0x81	; 129
 858:	11 74       	andi	r17, 0x41	; 65
 85a:	01 00       	.word	0x0001	; ????
 85c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 85e:	00 00       	nop
 860:	00 11       	cpse	r16, r0
 862:	7f 01       	movw	r14, r30
 864:	00 00       	nop
 866:	55 00       	.word	0x0055	; ????
 868:	00 00       	nop
 86a:	11 8a       	std	Z+17, r1	; 0x11
 86c:	01 00       	.word	0x0001	; ????
 86e:	00 81       	ld	r16, Z
 870:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 872:	00 11       	cpse	r16, r0
 874:	95 01       	movw	r18, r10
 876:	00 00       	nop
 878:	9f 00       	.word	0x009f	; ????
 87a:	00 00       	nop
 87c:	11 a0       	ldd	r1, Z+33	; 0x21
 87e:	01 00       	.word	0x0001	; ????
 880:	00 c7       	rjmp	.+3584   	; 0x1682 <__data_load_end+0x71a>
 882:	00 00       	nop
 884:	00 12       	cpse	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 886:	5e 01       	movw	r10, r28
 888:	00 00       	nop
 88a:	0d 13       	cpse	r16, r29
 88c:	ff 01       	movw	r30, r30
 88e:	00 00       	nop
 890:	e0 00       	.word	0x00e0	; ????
 892:	00 00       	nop
 894:	e6 00       	.word	0x00e6	; ????
 896:	00 00       	nop
 898:	bb 02       	muls	r27, r27
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 89a:	00 00       	nop
 89c:	11 00       	.word	0x0011	; ????
 89e:	02 00       	.word	0x0002	; ????
 8a0:	00 e5       	ldi	r16, 0x50	; 80
 8a2:	00 00       	nop
 8a4:	00 11       	cpse	r16, r0
 8a6:	0b 02       	muls	r16, r27
 8a8:	00 00       	nop
 8aa:	00 00       	nop
 8ac:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 8ae:	00 13       	cpse	r16, r16
 8b0:	e3 01       	movw	r28, r6
 8b2:	00 00       	nop
 8b4:	e6 00       	.word	0x00e6	; ????
 8b6:	00 00       	nop
 8b8:	ec 00       	.word	0x00ec	; ????
 8ba:	00 00       	nop
 8bc:	df 02       	muls	r29, r31
 8be:	00 00       	nop
 8c0:	11 e8       	ldi	r17, 0x81	; 129
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 8c2:	01 00       	.word	0x0001	; ????
 8c4:	00 fd       	sbrc	r16, 0
 8c6:	00 00       	nop
 8c8:	00 11       	cpse	r16, r0
 8ca:	f3 01       	movw	r30, r6
 8cc:	00 00       	nop
 8ce:	55 00       	.word	0x0055	; ????
 8d0:	00 00       	nop
 8d2:	00 13       	cpse	r16, r16
 8d4:	c7 01       	movw	r24, r14
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 8d6:	00 00       	nop
 8d8:	ec 00       	.word	0x00ec	; ????
 8da:	00 00       	nop
 8dc:	f2 00       	.word	0x00f2	; ????
 8de:	00 00       	nop
 8e0:	03 03       	mulsu	r16, r19
 8e2:	00 00       	nop
 8e4:	11 cc       	rjmp	.-2014   	; 0x108 <digitalWrite.constprop.0+0x28>
 8e6:	01 00       	.word	0x0001	; ????
 8e8:	00 15       	cp	r16, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 8ea:	01 00       	.word	0x0001	; ????
 8ec:	00 11       	cpse	r16, r0
 8ee:	d7 01       	movw	r26, r14
 8f0:	00 00       	nop
 8f2:	81 00       	.word	0x0081	; ????
 8f4:	00 00       	nop
 8f6:	00 14       	cp	r0, r0
 8f8:	18 02       	muls	r17, r24
 8fa:	00 00       	nop
 8fc:	fa 00       	.word	0x00fa	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 8fe:	00 00       	nop
 900:	00 00       	nop
 902:	00 00       	nop
 904:	01 95       	neg	r16
 906:	2f 03       	fmul	r18, r23
 908:	00 00       	nop
 90a:	15 24       	eor	r1, r5
 90c:	02 00       	.word	0x0002	; ????
 90e:	00 2d       	mov	r16, r0
 910:	01 00       	.word	0x0001	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 912:	00 16       	cp	r0, r16
 914:	4a 01       	movw	r8, r20
 916:	00 00       	nop
 918:	4e 01       	movw	r8, r28
 91a:	00 00       	nop
 91c:	17 3b       	cpi	r17, 0xB7	; 183
 91e:	02 00       	.word	0x0002	; ????
 920:	00 00       	nop
 922:	00 18       	sub	r0, r0
 924:	ab 01       	movw	r20, r22
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 926:	00 00       	nop
 928:	08 01       	movw	r0, r16
 92a:	00 00       	nop
 92c:	16 01       	movw	r2, r12
 92e:	00 00       	nop
 930:	11 b0       	in	r1, 0x01	; 1
 932:	01 00       	.word	0x0001	; ????
 934:	00 82       	st	Z, r0
 936:	01 00       	.word	0x0001	; ????
 938:	00 11       	cpse	r16, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 93a:	bb 01       	movw	r22, r22
 93c:	00 00       	nop
 93e:	9f 00       	.word	0x009f	; ????
 940:	00 00       	nop
 942:	00 00       	nop
 944:	19 01       	movw	r2, r18
 946:	c7 02       	muls	r28, r23
 948:	00 00       	nop
 94a:	02 2d       	mov	r16, r2
 94c:	70 01       	movw	r14, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 94e:	00 00       	nop
 950:	04 02       	muls	r16, r20
 952:	00 00       	nop
 954:	9a 01       	movw	r18, r20
 956:	00 00       	nop
 958:	01 84       	ldd	r0, Z+9	; 0x09
 95a:	03 00       	.word	0x0003	; ????
 95c:	00 1a       	sub	r0, r16
 95e:	6d 00       	.word	0x006d	; ????
 960:	02 32       	cpi	r16, 0x22	; 34
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 962:	84 03       	fmuls	r16, r20
 964:	00 00       	nop
 966:	17 02       	muls	r17, r23
 968:	00 00       	nop
 96a:	1a 66       	ori	r17, 0x6A	; 106
 96c:	00 02       	muls	r16, r16
 96e:	33 34       	cpi	r19, 0x43	; 67
 970:	00 00       	nop
 972:	00 8a       	std	Z+16, r0	; 0x10
 974:	02 00       	.word	0x0002	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 976:	00 00       	nop
 978:	03 04       	cpc	r0, r3
 97a:	07 d2       	rcall	.+1038   	; 0xd8a <__stack+0x48b>
 97c:	03 00       	.word	0x0003	; ????
 97e:	00 1b       	sub	r16, r16
 980:	37 02       	muls	r19, r23
 982:	00 00       	nop
 984:	04 06       	cpc	r0, r20
 986:	01 1b       	sub	r16, r17
 988:	3d 02       	muls	r19, r29
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 98a:	00 00       	nop
 98c:	03 1c       	adc	r0, r3
 98e:	01 1b       	sub	r16, r17
 990:	15 02       	muls	r17, r21
 992:	00 00       	nop
 994:	02 f1       	brmi	.+64     	; 0x9d6 <__stack+0xd7>
 996:	01 1b       	sub	r16, r17
 998:	81 04       	cpc	r8, r1
 99a:	00 00       	nop
 99c:	04 0d       	add	r16, r4
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 99e:	01 1c       	adc	r0, r1
 9a0:	01 c2       	rjmp	.+1026   	; 0xda4 <__stack+0x4a5>
 9a2:	02 00       	.word	0x0002	; ????
 9a4:	00 03       	mulsu	r16, r16
 9a6:	21 11       	cpse	r18, r1
 9a8:	05 00       	.word	0x0005	; ????
 9aa:	00 01       	movw	r0, r0
 9ac:	04 02       	muls	r16, r20
 9ae:	00 00       	nop
 9b0:	64 0f       	add	r22, r20
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 9b2:	00 00       	nop
 9b4:	03 92       	.word	0x9203	; ????
 9b6:	20 02       	muls	r18, r16
 9b8:	01 11       	cpse	r16, r1
 9ba:	05 00       	.word	0x0005	; ????
 9bc:	00 1d       	adc	r16, r0
 9be:	9b 03       	fmulsu	r17, r19
 9c0:	00 00       	nop
 9c2:	04 02       	muls	r16, r20
 9c4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 9c6:	8a 02       	muls	r24, r26
 9c8:	00 00       	nop
 9ca:	03 23       	and	r16, r19
 9cc:	1e 8b       	std	Y+22, r17	; 0x16
 9ce:	03 00       	.word	0x0003	; ????
 9d0:	00 8a       	std	Z+16, r0	; 0x10
 9d2:	02 00       	.word	0x0002	; ????
 9d4:	00 c0       	rjmp	.+0      	; 0x9d6 <__stack+0xd7>
 9d6:	02 00       	.word	0x0002	; ????
 9d8:	00 03       	mulsu	r16, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 9da:	2b d5       	rcall	.+2646   	; 0x1432 <__data_load_end+0x4ca>
 9dc:	04 00       	.word	0x0004	; ????
 9de:	00 1f       	adc	r16, r16
 9e0:	52 00       	.word	0x0052	; ????
 9e2:	00 00       	nop
 9e4:	8a 02       	muls	r24, r26
 9e6:	00 00       	nop
 9e8:	c0 02       	muls	r28, r16
 9ea:	00 00       	nop
 9ec:	04 09       	sbc	r16, r4
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 9ee:	12 5e       	subi	r17, 0xE2	; 226
 9f0:	00 00       	nop
 9f2:	00 0d       	add	r16, r0
 9f4:	12 69       	ori	r17, 0x92	; 146
 9f6:	00 00       	nop
 9f8:	00 01       	movw	r0, r0
 9fa:	16 8a       	std	Z+22, r1	; 0x16
 9fc:	02 00       	.word	0x0002	; ????
 9fe:	00 c0       	rjmp	.+0      	; 0xa00 <__stack+0x101>
 a00:	02 00       	.word	0x0002	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a02:	00 11       	cpse	r16, r0
 a04:	74 00       	.word	0x0074	; ????
 a06:	00 00       	nop
 a08:	da 02       	muls	r29, r26
 a0a:	00 00       	nop
 a0c:	11 7f       	andi	r17, 0xF1	; 241
 a0e:	00 00       	nop
 a10:	00 ed       	ldi	r16, 0xD0	; 208
 a12:	02 00       	.word	0x0002	; ????
 a14:	00 11       	cpse	r16, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a16:	8a 00       	.word	0x008a	; ????
 a18:	00 00       	nop
 a1a:	00 03       	mulsu	r16, r16
 a1c:	00 00       	nop
 a1e:	17 95       	ror	r17
 a20:	00 00       	nop
 a22:	00 13       	cpse	r16, r16
 a24:	27 01       	movw	r4, r14
 a26:	00 00       	nop
 a28:	8a 02       	muls	r24, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a2a:	00 00       	nop
 a2c:	90 02       	muls	r25, r16
 a2e:	00 00       	nop
 a30:	53 04       	cpc	r5, r3
 a32:	00 00       	nop
 a34:	11 28       	or	r1, r1
 a36:	01 00       	.word	0x0001	; ????
 a38:	00 18       	sub	r0, r0
 a3a:	03 00       	.word	0x0003	; ????
 a3c:	00 11       	cpse	r16, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a3e:	33 01       	movw	r6, r6
 a40:	00 00       	nop
 a42:	da 02       	muls	r29, r26
 a44:	00 00       	nop
 a46:	00 13       	cpse	r16, r16
 a48:	0b 01       	movw	r0, r22
 a4a:	00 00       	nop
 a4c:	90 02       	muls	r25, r16
 a4e:	00 00       	nop
 a50:	96 02       	muls	r25, r22
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a52:	00 00       	nop
 a54:	77 04       	cpc	r7, r7
 a56:	00 00       	nop
 a58:	11 10       	cpse	r1, r1
 a5a:	01 00       	.word	0x0001	; ????
 a5c:	00 30       	cpi	r16, 0x00	; 0
 a5e:	03 00       	.word	0x0003	; ????
 a60:	00 11       	cpse	r16, r0
 a62:	1b 01       	movw	r2, r22
 a64:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a66:	ed 02       	muls	r30, r29
 a68:	00 00       	nop
 a6a:	00 13       	cpse	r16, r16
 a6c:	ef 00       	.word	0x00ef	; ????
 a6e:	00 00       	nop
 a70:	9a 02       	muls	r25, r26
 a72:	00 00       	nop
 a74:	aa 02       	muls	r26, r26
 a76:	00 00       	nop
 a78:	9b 04       	cpc	r9, r11
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a7a:	00 00       	nop
 a7c:	11 f4       	brne	.+4      	; 0xa82 <__stack+0x183>
 a7e:	00 00       	nop
 a80:	00 48       	sbci	r16, 0x80	; 128
 a82:	03 00       	.word	0x0003	; ????
 a84:	00 11       	cpse	r16, r0
 a86:	ff 00       	.word	0x00ff	; ????
 a88:	00 00       	nop
 a8a:	00 03       	mulsu	r16, r16
 a8c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 a8e:	00 13       	cpse	r16, r16
 a90:	d3 00       	.word	0x00d3	; ????
 a92:	00 00       	nop
 a94:	aa 02       	muls	r26, r26
 a96:	00 00       	nop
 a98:	b4 02       	muls	r27, r20
 a9a:	00 00       	nop
 a9c:	bb 04       	cpc	r11, r11
 a9e:	00 00       	nop
 aa0:	11 d8       	rcall	.-4062   	; 0xfffffac4 <__eeprom_end+0xff7efac4>
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 aa2:	00 00       	nop
 aa4:	00 60       	ori	r16, 0x00	; 0
 aa6:	03 00       	.word	0x0003	; ????
 aa8:	00 17       	cp	r16, r16
 aaa:	e3 00       	.word	0x00e3	; ????
 aac:	00 00       	nop
 aae:	00 18       	sub	r0, r0
 ab0:	a0 00       	.word	0x00a0	; ????
 ab2:	00 00       	nop
 ab4:	b4 02       	muls	r27, r20
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 ab6:	00 00       	nop
 ab8:	c0 02       	muls	r28, r16
 aba:	00 00       	nop
 abc:	11 a5       	ldd	r17, Z+41	; 0x29
 abe:	00 00       	nop
 ac0:	00 78       	andi	r16, 0x80	; 128
 ac2:	03 00       	.word	0x0003	; ????
 ac4:	00 00       	nop
 ac6:	00 00       	nop
 ac8:	00 1e       	adc	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 aca:	a3 03       	fmuls	r18, r19
 acc:	00 00       	nop
 ace:	c4 02       	muls	r28, r20
 ad0:	00 00       	nop
 ad2:	54 0f       	add	r21, r20
 ad4:	00 00       	nop
 ad6:	03 2e       	mov	r0, r19
 ad8:	0b 05       	cpc	r16, r11
 ada:	00 00       	nop
 adc:	20 cc       	rjmp	.-1984   	; 0x31e <main+0x11a>
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 ade:	02 00       	.word	0x0002	; ????
 ae0:	00 47       	sbci	r16, 0x70	; 112
 ae2:	02 00       	.word	0x0002	; ????
 ae4:	00 fb       	bst	r16, 0
 ae6:	04 00       	.word	0x0004	; ????
 ae8:	00 21       	and	r16, r0
 aea:	01 68       	ori	r16, 0x81	; 129
 aec:	01 30       	cpi	r16, 0x01	; 1
 aee:	00 22       	and	r0, r16
 af0:	d2 02       	muls	r29, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 af2:	00 00       	nop
 af4:	47 02       	muls	r20, r23
 af6:	00 00       	nop
 af8:	21 01       	movw	r4, r2
 afa:	68 01       	movw	r12, r16
 afc:	31 00       	.word	0x0031	; ????
 afe:	00 23       	and	r16, r16
 b00:	60 0f       	add	r22, r16
 b02:	00 00       	nop
 b04:	00 24       	eor	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b06:	02 05       	cpc	r16, r2
 b08:	69 6e       	ori	r22, 0xE9	; 233
 b0a:	74 00       	.word	0x0074	; ????
 b0c:	25 46       	sbci	r18, 0x65	; 101
 b0e:	00 00       	nop
 b10:	00 28       	or	r0, r0
 b12:	05 00       	.word	0x0005	; ????
 b14:	00 26       	eor	r0, r16
 b16:	4b 00       	.word	0x004b	; ????
 b18:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b1a:	04 00       	.word	0x0004	; ????
 b1c:	04 18       	sub	r0, r4
 b1e:	05 00       	.word	0x0005	; ????
 b20:	00 27       	eor	r16, r16
 b22:	8f 04       	cpc	r8, r15
 b24:	00 00       	nop
 b26:	06 7e       	andi	r16, 0xE6	; 230
 b28:	28 05       	cpc	r18, r8
 b2a:	00 00       	nop
 b2c:	05 03       	mulsu	r16, r21
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b2e:	68 00       	.word	0x0068	; ????
 b30:	00 00       	nop
 b32:	27 49       	sbci	r18, 0x97	; 151
 b34:	02 00       	.word	0x0002	; ????
 b36:	00 02       	muls	r16, r16
 b38:	26 56       	subi	r18, 0x66	; 102
 b3a:	05 00       	.word	0x0005	; ????
 b3c:	00 05       	cpc	r16, r0
 b3e:	03 00       	.word	0x0003	; ????
 b40:	01 80       	ldd	r0, Z+1	; 0x01
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b42:	00 03       	mulsu	r16, r16
 b44:	04 07       	cpc	r16, r20
 b46:	d2 03       	fmuls	r21, r18
 b48:	00 00       	nop
 b4a:	0d 4f       	sbci	r16, 0xFD	; 253
 b4c:	05 00       	.word	0x0005	; ????
 b4e:	00 27       	eor	r16, r16
 b50:	9f 02       	muls	r25, r31
 b52:	00 00       	nop
 b54:	02 28       	or	r0, r2
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b56:	34 00       	.word	0x0034	; ????
 b58:	00 00       	nop
 b5a:	05 03       	mulsu	r16, r21
 b5c:	04 01       	movw	r0, r8
 b5e:	80 00       	.word	0x0080	; ????
 b60:	27 c4       	rjmp	.+2126   	; 0x13b0 <__data_load_end+0x448>
 b62:	03 00       	.word	0x0003	; ????
 b64:	00 02       	muls	r16, r16
 b66:	27 56       	subi	r18, 0x67	; 103
 b68:	05 00       	.word	0x0005	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b6a:	00 05       	cpc	r16, r0
 b6c:	03 05       	cpc	r16, r3
 b6e:	01 80       	ldd	r0, Z+1	; 0x01
 b70:	00 27       	eor	r16, r16
 b72:	5f 02       	muls	r21, r31
 b74:	00 00       	nop
 b76:	06 86       	std	Z+14, r0	; 0x0e
 b78:	28 05       	cpc	r18, r8
 b7a:	00 00       	nop
 b7c:	05 03       	mulsu	r16, r21
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b7e:	72 00       	.word	0x0072	; ????
 b80:	00 00       	nop
 b82:	25 aa       	std	Z+53, r2	; 0x35
 b84:	05 00       	.word	0x0005	; ????
 b86:	00 9e       	mul	r0, r16
 b88:	05 00       	.word	0x0005	; ????
 b8a:	00 26       	eor	r0, r16
 b8c:	4b 00       	.word	0x004b	; ????
 b8e:	00 00       	nop
 b90:	13 00       	.word	0x0013	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 b92:	04 8e       	std	Z+28, r0	; 0x1c
 b94:	05 00       	.word	0x0005	; ????
 b96:	00 03       	mulsu	r16, r16
 b98:	01 08       	sbc	r0, r1
 b9a:	ac 02       	muls	r26, r28
 b9c:	00 00       	nop
 b9e:	04 a3       	std	Z+36, r16	; 0x24
 ba0:	05 00       	.word	0x0005	; ????
 ba2:	00 27       	eor	r16, r16
 ba4:	1f 02       	muls	r17, r31
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 ba6:	00 00       	nop
 ba8:	06 96       	adiw	r24, 0x06	; 6
 baa:	9e 05       	cpc	r25, r14
 bac:	00 00       	nop
 bae:	05 03       	mulsu	r16, r21
 bb0:	7c 00       	.word	0x007c	; ????
 bb2:	00 00       	nop
 bb4:	27 a8       	ldd	r2, Z+55	; 0x37
 bb6:	03 00       	.word	0x0003	; ????
 bb8:	00 06       	cpc	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 bba:	ad 9e       	mul	r10, r29
 bbc:	05 00       	.word	0x0005	; ????
 bbe:	00 05       	cpc	r16, r0
 bc0:	03 90       	.word	0x9003	; ????
 bc2:	00 00       	nop
 bc4:	00 27       	eor	r16, r16
 bc6:	ef 03       	fmulsu	r22, r23
 bc8:	00 00       	nop
 bca:	06 c4       	rjmp	.+2060   	; 0x13d8 <__data_load_end+0x470>
 bcc:	9e 05       	cpc	r25, r14
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 bce:	00 00       	nop
 bd0:	05 03       	mulsu	r16, r21
 bd2:	a4 00       	.word	0x00a4	; ????
 bd4:	00 00       	nop
 bd6:	00 b7       	in	r16, 0x30	; 48
 bd8:	00 00       	nop
 bda:	00 02       	muls	r16, r16
 bdc:	00 8b       	std	Z+16, r16	; 0x10
 bde:	07 00       	.word	0x0007	; ????
 be0:	00 04       	cpc	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 be2:	01 5e       	subi	r16, 0xE1	; 225
 be4:	07 00       	.word	0x0007	; ????
 be6:	00 64       	ori	r16, 0x40	; 64
 be8:	0f 00       	.word	0x000f	; ????
 bea:	00 68       	ori	r16, 0x80	; 128
 bec:	0f 00       	.word	0x000f	; ????
 bee:	00 2e       	mov	r0, r16
 bf0:	2e 2f       	mov	r18, r30
 bf2:	2e 2e       	mov	r2, r30
 bf4:	2f 2e       	mov	r2, r31
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 bf6:	2e 2f       	mov	r18, r30
 bf8:	2e 2e       	mov	r2, r30
 bfa:	2f 67       	ori	r18, 0x7F	; 127
 bfc:	63 63       	ori	r22, 0x33	; 51
 bfe:	2f 6c       	ori	r18, 0xCF	; 207
 c00:	69 62       	ori	r22, 0x29	; 41
 c02:	67 63       	ori	r22, 0x37	; 55
 c04:	63 2f       	mov	r22, r19
 c06:	63 6f       	ori	r22, 0xF3	; 243
 c08:	6e 66       	ori	r22, 0x6E	; 110
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c0a:	69 67       	ori	r22, 0x79	; 121
 c0c:	2f 61       	ori	r18, 0x1F	; 31
 c0e:	76 72       	andi	r23, 0x26	; 38
 c10:	2f 6c       	ori	r18, 0xCF	; 207
 c12:	69 62       	ori	r22, 0x29	; 41
 c14:	31 66       	ori	r19, 0x61	; 97
 c16:	75 6e       	ori	r23, 0xE5	; 229
 c18:	63 73       	andi	r22, 0x33	; 51
 c1a:	2e 53       	subi	r18, 0x3E	; 62
 c1c:	00 2f       	mov	r16, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c1e:	68 6f       	ori	r22, 0xF8	; 248
 c20:	6d 65       	ori	r22, 0x5D	; 93
 c22:	2f 6a       	ori	r18, 0xAF	; 175
 c24:	65 6e       	ori	r22, 0xE5	; 229
 c26:	6b 69       	ori	r22, 0x9B	; 155
 c28:	6e 73       	andi	r22, 0x3E	; 62
 c2a:	2d 6d       	ori	r18, 0xDD	; 221
 c2c:	69 6e       	ori	r22, 0xE9	; 233
 c2e:	67 77       	andi	r22, 0x77	; 119
 c30:	33 32       	cpi	r19, 0x23	; 35
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c32:	2f 77       	andi	r18, 0x7F	; 127
 c34:	6f 72       	andi	r22, 0x2F	; 47
 c36:	6b 73       	andi	r22, 0x3B	; 59
 c38:	70 61       	ori	r23, 0x10	; 16
 c3a:	63 65       	ori	r22, 0x53	; 83
 c3c:	2f 61       	ori	r18, 0x1F	; 31
 c3e:	76 72       	andi	r23, 0x26	; 38
 c40:	2d 67       	ori	r18, 0x7D	; 125
 c42:	63 63       	ori	r22, 0x33	; 51
 c44:	2d 73       	andi	r18, 0x3D	; 61
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c46:	74 61       	ori	r23, 0x14	; 20
 c48:	67 69       	ori	r22, 0x97	; 151
 c4a:	6e 67       	ori	r22, 0x7E	; 126
 c4c:	2f 6c       	ori	r18, 0xCF	; 207
 c4e:	61 62       	ori	r22, 0x21	; 33
 c50:	65 6c       	ori	r22, 0xC5	; 197
 c52:	2f 55       	subi	r18, 0x5F	; 95
 c54:	62 75       	andi	r22, 0x52	; 82
 c56:	6e 74       	andi	r22, 0x4E	; 78
 c58:	75 31       	cpi	r23, 0x15	; 21
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c5a:	34 2e       	mov	r3, r20
 c5c:	30 34       	cpi	r19, 0x40	; 64
 c5e:	78 36       	cpi	r23, 0x68	; 104
 c60:	34 2d       	mov	r19, r4
 c62:	6d 69       	ori	r22, 0x9D	; 157
 c64:	6e 67       	ori	r22, 0x7E	; 126
 c66:	77 33       	cpi	r23, 0x37	; 55
 c68:	32 2f       	mov	r19, r18
 c6a:	67 63       	ori	r22, 0x37	; 55
 c6c:	63 2d       	mov	r22, r3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c6e:	62 75       	andi	r22, 0x52	; 82
 c70:	69 6c       	ori	r22, 0xC9	; 201
 c72:	64 2f       	mov	r22, r20
 c74:	61 76       	andi	r22, 0x61	; 97
 c76:	72 2f       	mov	r23, r18
 c78:	61 76       	andi	r22, 0x61	; 97
 c7a:	72 35       	cpi	r23, 0x52	; 82
 c7c:	2f 6c       	ori	r18, 0xCF	; 207
 c7e:	69 62       	ori	r22, 0x29	; 41
 c80:	67 63       	ori	r22, 0x37	; 55
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c82:	63 00       	.word	0x0063	; ????
 c84:	47 4e       	sbci	r20, 0xE7	; 231
 c86:	55 20       	and	r5, r5
 c88:	41 53       	subi	r20, 0x31	; 49
 c8a:	20 32       	cpi	r18, 0x20	; 32
 c8c:	2e 32       	cpi	r18, 0x2E	; 46
 c8e:	36 00       	.word	0x0036	; ????
 c90:	01 80       	ldd	r0, Z+1	; 0x01
 c92:	b7 00       	.word	0x00b7	; ????
 c94:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 c96:	02 00       	.word	0x0002	; ????
 c98:	9f 07       	cpc	r25, r31
 c9a:	00 00       	nop
 c9c:	04 01       	movw	r0, r8
 c9e:	c0 07       	cpc	r28, r16
 ca0:	00 00       	nop
 ca2:	c4 00       	.word	0x00c4	; ????
 ca4:	00 00       	nop
 ca6:	d4 00       	.word	0x00d4	; ????
 ca8:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 caa:	2e 2e       	mov	r2, r30
 cac:	2f 2e       	mov	r2, r31
 cae:	2e 2f       	mov	r18, r30
 cb0:	2e 2e       	mov	r2, r30
 cb2:	2f 2e       	mov	r2, r31
 cb4:	2e 2f       	mov	r18, r30
 cb6:	67 63       	ori	r22, 0x37	; 55
 cb8:	63 2f       	mov	r22, r19
 cba:	6c 69       	ori	r22, 0x9C	; 156
 cbc:	62 67       	ori	r22, 0x72	; 114
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 cbe:	63 63       	ori	r22, 0x33	; 51
 cc0:	2f 63       	ori	r18, 0x3F	; 63
 cc2:	6f 6e       	ori	r22, 0xEF	; 239
 cc4:	66 69       	ori	r22, 0x96	; 150
 cc6:	67 2f       	mov	r22, r23
 cc8:	61 76       	andi	r22, 0x61	; 97
 cca:	72 2f       	mov	r23, r18
 ccc:	6c 69       	ori	r22, 0x9C	; 156
 cce:	62 31       	cpi	r22, 0x12	; 18
 cd0:	66 75       	andi	r22, 0x56	; 86
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 cd2:	6e 63       	ori	r22, 0x3E	; 62
 cd4:	73 2e       	mov	r7, r19
 cd6:	53 00       	.word	0x0053	; ????
 cd8:	2f 68       	ori	r18, 0x8F	; 143
 cda:	6f 6d       	ori	r22, 0xDF	; 223
 cdc:	65 2f       	mov	r22, r21
 cde:	6a 65       	ori	r22, 0x5A	; 90
 ce0:	6e 6b       	ori	r22, 0xBE	; 190
 ce2:	69 6e       	ori	r22, 0xE9	; 233
 ce4:	73 2d       	mov	r23, r3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 ce6:	6d 69       	ori	r22, 0x9D	; 157
 ce8:	6e 67       	ori	r22, 0x7E	; 126
 cea:	77 33       	cpi	r23, 0x37	; 55
 cec:	32 2f       	mov	r19, r18
 cee:	77 6f       	ori	r23, 0xF7	; 247
 cf0:	72 6b       	ori	r23, 0xB2	; 178
 cf2:	73 70       	andi	r23, 0x03	; 3
 cf4:	61 63       	ori	r22, 0x31	; 49
 cf6:	65 2f       	mov	r22, r21
 cf8:	61 76       	andi	r22, 0x61	; 97
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 cfa:	72 2d       	mov	r23, r2
 cfc:	67 63       	ori	r22, 0x37	; 55
 cfe:	63 2d       	mov	r22, r3
 d00:	73 74       	andi	r23, 0x43	; 67
 d02:	61 67       	ori	r22, 0x71	; 113
 d04:	69 6e       	ori	r22, 0xE9	; 233
 d06:	67 2f       	mov	r22, r23
 d08:	6c 61       	ori	r22, 0x1C	; 28
 d0a:	62 65       	ori	r22, 0x52	; 82
 d0c:	6c 2f       	mov	r22, r28
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 d0e:	55 62       	ori	r21, 0x25	; 37
 d10:	75 6e       	ori	r23, 0xE5	; 229
 d12:	74 75       	andi	r23, 0x54	; 84
 d14:	31 34       	cpi	r19, 0x41	; 65
 d16:	2e 30       	cpi	r18, 0x0E	; 14
 d18:	34 78       	andi	r19, 0x84	; 132
 d1a:	36 34       	cpi	r19, 0x46	; 70
 d1c:	2d 6d       	ori	r18, 0xDD	; 221
 d1e:	69 6e       	ori	r22, 0xE9	; 233
 d20:	67 77       	andi	r22, 0x77	; 119
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 d22:	33 32       	cpi	r19, 0x23	; 35
 d24:	2f 67       	ori	r18, 0x7F	; 127
 d26:	63 63       	ori	r22, 0x33	; 51
 d28:	2d 62       	ori	r18, 0x2D	; 45
 d2a:	75 69       	ori	r23, 0x95	; 149
 d2c:	6c 64       	ori	r22, 0x4C	; 76
 d2e:	2f 61       	ori	r18, 0x1F	; 31
 d30:	76 72       	andi	r23, 0x26	; 38
 d32:	2f 61       	ori	r18, 0x1F	; 31
 d34:	76 72       	andi	r23, 0x26	; 38
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 d36:	35 2f       	mov	r19, r21
 d38:	6c 69       	ori	r22, 0x9C	; 156
 d3a:	62 67       	ori	r22, 0x72	; 114
 d3c:	63 63       	ori	r22, 0x33	; 51
 d3e:	00 47       	sbci	r16, 0x70	; 112
 d40:	4e 55       	subi	r20, 0x5E	; 94
 d42:	20 41       	sbci	r18, 0x10	; 16
 d44:	53 20       	and	r5, r3
 d46:	32 2e       	mov	r3, r18
 d48:	32 36       	cpi	r19, 0x62	; 98
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 d4a:	00 01       	movw	r0, r0
 d4c:	80 00       	Address 0x00000d4c is out of bounds.
.word	0xffff	; ????

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	01 11       	cpse	r16, r1
   2:	01 25       	eor	r16, r1
   4:	0e 10       	cpse	r0, r14
   6:	06 00       	.word	0x0006	; ????
   8:	00 02       	muls	r16, r16
   a:	24 00       	.word	0x0024	; ????
   c:	03 0e       	add	r0, r19
   e:	0b 0b       	sbc	r16, r27
  10:	3e 0b       	sbc	r19, r30
  12:	00 00       	nop
  14:	03 24       	eor	r0, r3
  16:	00 03       	mulsu	r16, r16
  18:	0e 0b       	sbc	r16, r30
  1a:	0b 3e       	cpi	r16, 0xEB	; 235
  1c:	0b 00       	.word	0x000b	; ????
  1e:	00 04       	cpc	r0, r0
  20:	01 01       	movw	r0, r2
  22:	49 13       	cpse	r20, r25
  24:	00 00       	nop
  26:	05 21       	and	r16, r5
  28:	00 49       	sbci	r16, 0x90	; 144
  2a:	13 2f       	mov	r17, r19
  2c:	05 00       	.word	0x0005	; ????
  2e:	00 06       	cpc	r0, r16
  30:	34 00       	.word	0x0034	; ????
  32:	03 0e       	add	r0, r19
  34:	3a 0b       	sbc	r19, r26
  36:	3b 0b       	sbc	r19, r27
  38:	49 13       	cpse	r20, r25
  3a:	3f 0c       	add	r3, r15
  3c:	02 0a       	sbc	r0, r18
  3e:	00 00       	nop
  40:	07 34       	cpi	r16, 0x47	; 71
  42:	00 03       	mulsu	r16, r16
  44:	0e 3a       	cpi	r16, 0xAE	; 174
  46:	0b 3b       	cpi	r16, 0xBB	; 187
  48:	0b 49       	sbci	r16, 0x9B	; 155
  4a:	13 3f       	cpi	r17, 0xF3	; 243
  4c:	0c 02       	muls	r16, r28
  4e:	0a 00       	.word	0x000a	; ????
  50:	00 08       	sbc	r0, r0
  52:	34 00       	.word	0x0034	; ????
  54:	03 0e       	add	r0, r19
  56:	3a 0b       	sbc	r19, r26
  58:	3b 0b       	sbc	r19, r27
  5a:	49 13       	cpse	r20, r25
  5c:	3f 0c       	add	r3, r15
  5e:	02 0a       	sbc	r0, r18
  60:	00 00       	nop
  62:	09 34       	cpi	r16, 0x49	; 73
  64:	00 03       	mulsu	r16, r16
  66:	0e 3a       	cpi	r16, 0xAE	; 174
  68:	0b 3b       	cpi	r16, 0xBB	; 187
  6a:	0b 49       	sbci	r16, 0x9B	; 155
  6c:	13 3f       	cpi	r17, 0xF3	; 243
  6e:	0c 02       	muls	r16, r28
  70:	0a 00       	.word	0x000a	; ????
  72:	00 0a       	sbc	r0, r16
  74:	34 00       	.word	0x0034	; ????
  76:	03 0e       	add	r0, r19
  78:	3a 0b       	sbc	r19, r26
  7a:	3b 0b       	sbc	r19, r27
  7c:	49 13       	cpse	r20, r25
  7e:	3f 0c       	add	r3, r15
  80:	02 0a       	sbc	r0, r18
  82:	00 00       	nop
  84:	0b 34       	cpi	r16, 0x4B	; 75
  86:	00 03       	mulsu	r16, r16
  88:	0e 3a       	cpi	r16, 0xAE	; 174
  8a:	0b 3b       	cpi	r16, 0xBB	; 187
  8c:	0b 49       	sbci	r16, 0x9B	; 155
  8e:	13 3f       	cpi	r17, 0xF3	; 243
  90:	0c 02       	muls	r16, r28
  92:	0a 00       	.word	0x000a	; ????
  94:	00 0c       	add	r0, r0
  96:	34 00       	.word	0x0034	; ????
  98:	03 0e       	add	r0, r19
  9a:	3a 0b       	sbc	r19, r26
  9c:	3b 0b       	sbc	r19, r27
  9e:	49 13       	cpse	r20, r25
  a0:	3f 0c       	add	r3, r15
  a2:	02 0a       	sbc	r0, r18
  a4:	00 00       	nop
  a6:	0d 34       	cpi	r16, 0x4D	; 77
  a8:	00 03       	mulsu	r16, r16
  aa:	0e 3a       	cpi	r16, 0xAE	; 174
  ac:	0b 3b       	cpi	r16, 0xBB	; 187
  ae:	0b 49       	sbci	r16, 0x9B	; 155
  b0:	13 3f       	cpi	r17, 0xF3	; 243
  b2:	0c 02       	muls	r16, r28
  b4:	0a 00       	.word	0x000a	; ????
  b6:	00 0e       	add	r0, r16
  b8:	34 00       	.word	0x0034	; ????
  ba:	03 0e       	add	r0, r19
  bc:	3a 0b       	sbc	r19, r26
  be:	3b 0b       	sbc	r19, r27
  c0:	49 13       	cpse	r20, r25
  c2:	3f 0c       	add	r3, r15
  c4:	02 0a       	sbc	r0, r18
  c6:	00 00       	nop
  c8:	0f 34       	cpi	r16, 0x4F	; 79
  ca:	00 03       	mulsu	r16, r16
  cc:	0e 3a       	cpi	r16, 0xAE	; 174
  ce:	0b 3b       	cpi	r16, 0xBB	; 187
  d0:	0b 49       	sbci	r16, 0x9B	; 155
  d2:	13 3f       	cpi	r17, 0xF3	; 243
  d4:	0c 02       	muls	r16, r28
  d6:	0a 00       	.word	0x000a	; ????
  d8:	00 10       	cpse	r0, r0
  da:	34 00       	.word	0x0034	; ????
  dc:	03 0e       	add	r0, r19
  de:	3a 0b       	sbc	r19, r26
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	3b 0b       	sbc	r19, r27
  e2:	49 13       	cpse	r20, r25
  e4:	3f 0c       	add	r3, r15
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	02 0a       	sbc	r0, r18
  e8:	00 00       	nop
  ea:	11 34       	cpi	r17, 0x41	; 65
	uint8_t port = digitalPinToPort(pin);
  ec:	00 03       	mulsu	r16, r16
  ee:	0e 3a       	cpi	r16, 0xAE	; 174
  f0:	0b 3b       	cpi	r16, 0xBB	; 187
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	0b 49       	sbci	r16, 0x9B	; 155
  f4:	13 3f       	cpi	r17, 0xF3	; 243

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	0c 02       	muls	r16, r28
  f8:	0a 00       	.word	0x000a	; ????
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 12       	cpse	r0, r16
  fc:	34 00       	.word	0x0034	; ????
  fe:	03 0e       	add	r0, r19
 100:	3a 0b       	sbc	r19, r26
 102:	3b 0b       	sbc	r19, r27
 104:	49 13       	cpse	r20, r25
 106:	3f 0c       	add	r3, r15

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	02 0a       	sbc	r0, r18
 10a:	00 00       	nop
 10c:	13 34       	cpi	r17, 0x43	; 67
 10e:	00 03       	mulsu	r16, r16
 110:	0e 3a       	cpi	r16, 0xAE	; 174
 112:	0b 3b       	cpi	r16, 0xBB	; 187
 114:	0b 49       	sbci	r16, 0x9B	; 155

	uint8_t oldSREG = SREG;
 116:	13 3f       	cpi	r17, 0xF3	; 243
	cli();
 118:	0c 02       	muls	r16, r28

	if (val == LOW) {
		*out &= ~bit;
 11a:	0a 00       	.word	0x000a	; ????
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 14       	cp	r0, r0
 11e:	34 00       	.word	0x0034	; ????
		*out &= ~bit;
 120:	03 0e       	add	r0, r19
 122:	3a 0b       	sbc	r19, r26
	} else {
		*out |= bit;
 124:	3b 0b       	sbc	r19, r27
	}

	SREG = oldSREG;
 126:	49 13       	cpse	r20, r25
}
 128:	3f 0c       	add	r3, r15
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	02 0a       	sbc	r0, r18
 12c:	00 00       	nop
 12e:	15 34       	cpi	r17, 0x45	; 69
 130:	00 03       	mulsu	r16, r16
 132:	0e 3a       	cpi	r16, 0xAE	; 174
 134:	0b 3b       	cpi	r16, 0xBB	; 187
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	0b 49       	sbci	r16, 0x9B	; 155
 138:	13 3f       	cpi	r17, 0xF3	; 243
 13a:	0c 02       	muls	r16, r28
 13c:	0a 00       	.word	0x000a	; ????
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	00 16       	cp	r0, r16
 140:	34 00       	.word	0x0034	; ????
 142:	03 0e       	add	r0, r19
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	3a 0b       	sbc	r19, r26
 146:	3b 0b       	sbc	r19, r27
 148:	49 13       	cpse	r20, r25
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	3f 0c       	add	r3, r15
 14c:	02 0a       	sbc	r0, r18
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	00 00       	nop
 150:	17 34       	cpi	r17, 0x47	; 71
 152:	00 03       	mulsu	r16, r16
 154:	0e 3a       	cpi	r16, 0xAE	; 174
 156:	0b 3b       	cpi	r16, 0xBB	; 187
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	0b 49       	sbci	r16, 0x9B	; 155
 15a:	13 3f       	cpi	r17, 0xF3	; 243
 15c:	0c 02       	muls	r16, r28
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	0a 00       	.word	0x000a	; ????
 160:	00 18       	sub	r0, r0
 162:	34 00       	.word	0x0034	; ????
 164:	03 0e       	add	r0, r19
 166:	3a 0b       	sbc	r19, r26
 168:	3b 0b       	sbc	r19, r27
 16a:	49 13       	cpse	r20, r25
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	3f 0c       	add	r3, r15
 16e:	02 0a       	sbc	r0, r18
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 00       	nop
 172:	19 34       	cpi	r17, 0x49	; 73
 174:	00 03       	mulsu	r16, r16
 176:	0e 3a       	cpi	r16, 0xAE	; 174
 178:	0b 3b       	cpi	r16, 0xBB	; 187
 17a:	0b 49       	sbci	r16, 0x9B	; 155
 17c:	13 3f       	cpi	r17, 0xF3	; 243
 17e:	0c 02       	muls	r16, r28
 180:	0a 00       	.word	0x000a	; ????
 182:	00 1a       	sub	r0, r16
 184:	34 00       	.word	0x0034	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	03 0e       	add	r0, r19
 188:	3a 0b       	sbc	r19, r26
 18a:	3b 0b       	sbc	r19, r27
 18c:	49 13       	cpse	r20, r25
 18e:	3f 0c       	add	r3, r15
 190:	02 0a       	sbc	r0, r18
 192:	00 00       	nop
 194:	1b 34       	cpi	r17, 0x4B	; 75
	unsigned char f = timer0_fract;
 196:	00 03       	mulsu	r16, r16
 198:	0e 3a       	cpi	r16, 0xAE	; 174

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	0b 3b       	cpi	r16, 0xBB	; 187
 19c:	0b 49       	sbci	r16, 0x9B	; 155
	if (f >= FRACT_MAX) {
 19e:	13 3f       	cpi	r17, 0xF3	; 243
 1a0:	0c 02       	muls	r16, r28
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	0a 00       	.word	0x000a	; ????
 1a4:	00 1c       	adc	r0, r0
 1a6:	34 00       	.word	0x0034	; ????
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	03 0e       	add	r0, r19
 1aa:	3a 0b       	sbc	r19, r26
	timer0_millis = m;
 1ac:	3b 0b       	sbc	r19, r27
 1ae:	49 13       	cpse	r20, r25
 1b0:	3f 0c       	add	r3, r15
 1b2:	02 0a       	sbc	r0, r18
 1b4:	00 00       	nop
 1b6:	1d 34       	cpi	r17, 0x4D	; 77
 1b8:	00 03       	mulsu	r16, r16
 1ba:	0e 3a       	cpi	r16, 0xAE	; 174
	timer0_overflow_count++;
 1bc:	0b 3b       	cpi	r16, 0xBB	; 187
 1be:	0b 49       	sbci	r16, 0x9B	; 155
 1c0:	13 3f       	cpi	r17, 0xF3	; 243
 1c2:	0c 02       	muls	r16, r28
 1c4:	0a 00       	.word	0x000a	; ????
 1c6:	00 1e       	adc	r0, r16
 1c8:	34 00       	.word	0x0034	; ????
 1ca:	03 0e       	add	r0, r19
 1cc:	3a 0b       	sbc	r19, r26
 1ce:	3b 0b       	sbc	r19, r27
 1d0:	49 13       	cpse	r20, r25
 1d2:	3f 0c       	add	r3, r15
 1d4:	02 0a       	sbc	r0, r18
 1d6:	00 00       	nop
 1d8:	1f 34       	cpi	r17, 0x4F	; 79
 1da:	00 03       	mulsu	r16, r16
 1dc:	0e 3a       	cpi	r16, 0xAE	; 174
 1de:	0b 3b       	cpi	r16, 0xBB	; 187
 1e0:	0b 49       	sbci	r16, 0x9B	; 155
}
 1e2:	13 3f       	cpi	r17, 0xF3	; 243
 1e4:	0c 02       	muls	r16, r28
 1e6:	0a 00       	.word	0x000a	; ????
 1e8:	00 20       	and	r0, r0
 1ea:	34 00       	.word	0x0034	; ????
 1ec:	03 0e       	add	r0, r19
 1ee:	3a 0b       	sbc	r19, r26
 1f0:	3b 0b       	sbc	r19, r27
 1f2:	49 13       	cpse	r20, r25
 1f4:	3f 0c       	add	r3, r15
 1f6:	02 0a       	sbc	r0, r18
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 00       	nop
 1fa:	21 34       	cpi	r18, 0x41	; 65
		m += 1;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	0e 3a       	cpi	r16, 0xAE	; 174
 200:	0b 3b       	cpi	r16, 0xBB	; 187
 202:	0b 49       	sbci	r16, 0x9B	; 155

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	13 3f       	cpi	r17, 0xF3	; 243
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	0c 02       	muls	r16, r28
 208:	0a 00       	.word	0x000a	; ????
 20a:	00 22       	and	r0, r16
	sbi(TCCR0A, WGM00);
 20c:	34 00       	.word	0x0034	; ????
 20e:	03 0e       	add	r0, r19
 210:	3a 0b       	sbc	r19, r26
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	3b 0b       	sbc	r19, r27
 214:	49 13       	cpse	r20, r25
 216:	3f 0c       	add	r3, r15
	sbi(TCCR0B, CS00);
 218:	02 0a       	sbc	r0, r18
 21a:	00 00       	nop
 21c:	23 34       	cpi	r18, 0x43	; 67

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 03       	mulsu	r16, r16
 220:	0e 3a       	cpi	r16, 0xAE	; 174
 222:	0b 3b       	cpi	r16, 0xBB	; 187
 224:	0b 49       	sbci	r16, 0x9B	; 155
 226:	13 3f       	cpi	r17, 0xF3	; 243
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	0c 02       	muls	r16, r28
 22a:	0a 00       	.word	0x000a	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	00 24       	eor	r0, r0
 22e:	34 00       	.word	0x0034	; ????
 230:	03 0e       	add	r0, r19
 232:	3a 0b       	sbc	r19, r26
 234:	3b 0b       	sbc	r19, r27
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	49 13       	cpse	r20, r25
 238:	3f 0c       	add	r3, r15
 23a:	02 0a       	sbc	r0, r18
 23c:	00 00       	nop
 23e:	25 34       	cpi	r18, 0x45	; 69
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	00 03       	mulsu	r16, r16
 242:	0e 3a       	cpi	r16, 0xAE	; 174
 244:	0b 3b       	cpi	r16, 0xBB	; 187
 246:	0b 49       	sbci	r16, 0x9B	; 155
 248:	13 3f       	cpi	r17, 0xF3	; 243

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	0c 02       	muls	r16, r28
 24c:	0a 00       	.word	0x000a	; ????
 24e:	00 26       	eor	r0, r16
 250:	34 00       	.word	0x0034	; ????
 252:	03 0e       	add	r0, r19

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	3a 0b       	sbc	r19, r26
 256:	3b 0b       	sbc	r19, r27
 258:	49 13       	cpse	r20, r25
 25a:	3f 0c       	add	r3, r15
 25c:	02 0a       	sbc	r0, r18
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 00       	nop
 260:	27 34       	cpi	r18, 0x47	; 71
 262:	00 03       	mulsu	r16, r16
 264:	0e 3a       	cpi	r16, 0xAE	; 174
 266:	0b 3b       	cpi	r16, 0xBB	; 187
		sbi(ADCSRA, ADPS1);
 268:	0b 49       	sbci	r16, 0x9B	; 155
 26a:	13 3f       	cpi	r17, 0xF3	; 243
 26c:	0c 02       	muls	r16, r28
 26e:	0a 00       	.word	0x000a	; ????
 270:	00 28       	or	r0, r0
		sbi(ADCSRA, ADPS0);
 272:	34 00       	.word	0x0034	; ????
 274:	03 0e       	add	r0, r19
 276:	3a 0b       	sbc	r19, r26
 278:	3b 0b       	sbc	r19, r27
 27a:	49 13       	cpse	r20, r25
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	3f 0c       	add	r3, r15
 27e:	02 0a       	sbc	r0, r18
 280:	00 00       	nop
 282:	29 34       	cpi	r18, 0x49	; 73
 284:	00 03       	mulsu	r16, r16
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	0e 3a       	cpi	r16, 0xAE	; 174
 288:	0b 3b       	cpi	r16, 0xBB	; 187
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	0b 49       	sbci	r16, 0x9B	; 155
 28c:	13 3f       	cpi	r17, 0xF3	; 243
 28e:	0c 02       	muls	r16, r28
	uint8_t port = digitalPinToPort(pin);
 290:	0a 00       	.word	0x000a	; ????
 292:	00 2a       	or	r0, r16
 294:	34 00       	.word	0x0034	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	03 0e       	add	r0, r19
 298:	3a 0b       	sbc	r19, r26

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	3b 0b       	sbc	r19, r27
 29c:	49 13       	cpse	r20, r25
 29e:	3f 0c       	add	r3, r15
 2a0:	02 0a       	sbc	r0, r18
 2a2:	00 00       	nop
 2a4:	2b 34       	cpi	r18, 0x4B	; 75
 2a6:	00 03       	mulsu	r16, r16
 2a8:	0e 3a       	cpi	r16, 0xAE	; 174
	out = portOutputRegister(port);
 2aa:	0b 3b       	cpi	r16, 0xBB	; 187
 2ac:	0b 49       	sbci	r16, 0x9B	; 155
 2ae:	13 3f       	cpi	r17, 0xF3	; 243
 2b0:	0c 02       	muls	r16, r28
 2b2:	0a 00       	.word	0x000a	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	00 2c       	mov	r0, r0
                cli();
 2b6:	34 00       	.word	0x0034	; ????
		*reg |= bit;
 2b8:	03 0e       	add	r0, r19
 2ba:	3a 0b       	sbc	r19, r26
 2bc:	3b 0b       	sbc	r19, r27
		SREG = oldSREG;
 2be:	49 13       	cpse	r20, r25
 2c0:	3f 0c       	add	r3, r15
 2c2:	02 0a       	sbc	r0, r18
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	00 00       	nop
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	2d 34       	cpi	r18, 0x4D	; 77
 2c8:	00 03       	mulsu	r16, r16
 2ca:	0e 3a       	cpi	r16, 0xAE	; 174
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	0b 3b       	cpi	r16, 0xBB	; 187
 2ce:	0b 49       	sbci	r16, 0x9B	; 155
 2d0:	13 3f       	cpi	r17, 0xF3	; 243
  
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2d2:	0c 02       	muls	r16, r28
 2d4:	0a 00       	.word	0x000a	; ????
 2d6:	00 2e       	mov	r0, r16
 2d8:	34 00       	.word	0x0034	; ????
 2da:	03 0e       	add	r0, r19
 2dc:	3a 0b       	sbc	r19, r26
 2de:	3b 0b       	sbc	r19, r27
 2e0:	49 13       	cpse	r20, r25
 2e2:	3f 0c       	add	r3, r15
 2e4:	02 0a       	sbc	r0, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2e6:	00 00       	nop
 2e8:	2f 34       	cpi	r18, 0x4F	; 79
 2ea:	00 03       	mulsu	r16, r16
 2ec:	0e 3a       	cpi	r16, 0xAE	; 174
 2ee:	0b 3b       	cpi	r16, 0xBB	; 187
 2f0:	0b 49       	sbci	r16, 0x9B	; 155
 2f2:	13 3f       	cpi	r17, 0xF3	; 243
 2f4:	0c 02       	muls	r16, r28
 2f6:	0a 00       	.word	0x000a	; ????
 2f8:	00 30       	cpi	r16, 0x00	; 0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2fa:	34 00       	.word	0x0034	; ????
 2fc:	03 0e       	add	r0, r19
 2fe:	3a 0b       	sbc	r19, r26
 300:	3b 0b       	sbc	r19, r27
 302:	49 13       	cpse	r20, r25
 304:	3f 0c       	add	r3, r15
 306:	02 0a       	sbc	r0, r18
 308:	00 00       	nop
 30a:	31 34       	cpi	r19, 0x41	; 65
 30c:	00 03       	mulsu	r16, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 30e:	0e 3a       	cpi	r16, 0xAE	; 174
 310:	0b 3b       	cpi	r16, 0xBB	; 187
 312:	0b 49       	sbci	r16, 0x9B	; 155
 314:	13 3f       	cpi	r17, 0xF3	; 243
 316:	0c 02       	muls	r16, r28
 318:	0a 00       	.word	0x000a	; ????
 31a:	00 32       	cpi	r16, 0x20	; 32
 31c:	34 00       	.word	0x0034	; ????
 31e:	03 0e       	add	r0, r19
 320:	3a 0b       	sbc	r19, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 322:	3b 0b       	sbc	r19, r27
 324:	49 13       	cpse	r20, r25
 326:	3f 0c       	add	r3, r15
 328:	02 0a       	sbc	r0, r18
 32a:	00 00       	nop
 32c:	33 34       	cpi	r19, 0x43	; 67
 32e:	00 03       	mulsu	r16, r16
 330:	0e 3a       	cpi	r16, 0xAE	; 174
 332:	0b 3b       	cpi	r16, 0xBB	; 187
 334:	0b 49       	sbci	r16, 0x9B	; 155
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 336:	13 3f       	cpi	r17, 0xF3	; 243
 338:	0c 02       	muls	r16, r28
 33a:	0a 00       	.word	0x000a	; ????
 33c:	00 34       	cpi	r16, 0x40	; 64
 33e:	34 00       	.word	0x0034	; ????
 340:	03 0e       	add	r0, r19
 342:	3a 0b       	sbc	r19, r26
 344:	3b 0b       	sbc	r19, r27
 346:	49 13       	cpse	r20, r25
 348:	3f 0c       	add	r3, r15
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 34a:	02 0a       	sbc	r0, r18
 34c:	00 00       	nop
 34e:	35 34       	cpi	r19, 0x45	; 69
 350:	00 03       	mulsu	r16, r16
 352:	0e 3a       	cpi	r16, 0xAE	; 174
 354:	0b 3b       	cpi	r16, 0xBB	; 187
 356:	0b 49       	sbci	r16, 0x9B	; 155
 358:	13 3f       	cpi	r17, 0xF3	; 243
 35a:	0c 02       	muls	r16, r28
 35c:	0a 00       	.word	0x000a	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 35e:	00 36       	cpi	r16, 0x60	; 96
 360:	34 00       	.word	0x0034	; ????
 362:	03 0e       	add	r0, r19
 364:	3a 0b       	sbc	r19, r26
 366:	3b 0b       	sbc	r19, r27
 368:	49 13       	cpse	r20, r25
 36a:	3f 0c       	add	r3, r15
 36c:	02 0a       	sbc	r0, r18
 36e:	00 00       	nop
 370:	37 34       	cpi	r19, 0x47	; 71
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 372:	00 03       	mulsu	r16, r16
 374:	0e 3a       	cpi	r16, 0xAE	; 174
 376:	0b 3b       	cpi	r16, 0xBB	; 187
 378:	0b 49       	sbci	r16, 0x9B	; 155
 37a:	13 3f       	cpi	r17, 0xF3	; 243
 37c:	0c 02       	muls	r16, r28
 37e:	0a 00       	.word	0x000a	; ????
 380:	00 38       	cpi	r16, 0x80	; 128
 382:	34 00       	.word	0x0034	; ????
 384:	03 0e       	add	r0, r19
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 386:	3a 0b       	sbc	r19, r26
 388:	3b 0b       	sbc	r19, r27
 38a:	49 13       	cpse	r20, r25
 38c:	3f 0c       	add	r3, r15
 38e:	02 0a       	sbc	r0, r18
 390:	00 00       	nop
 392:	39 34       	cpi	r19, 0x49	; 73
 394:	00 03       	mulsu	r16, r16
 396:	0e 3a       	cpi	r16, 0xAE	; 174
 398:	0b 3b       	cpi	r16, 0xBB	; 187
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 39a:	0b 49       	sbci	r16, 0x9B	; 155
 39c:	13 3f       	cpi	r17, 0xF3	; 243
 39e:	0c 02       	muls	r16, r28
 3a0:	0a 00       	.word	0x000a	; ????
 3a2:	00 3a       	cpi	r16, 0xA0	; 160
 3a4:	34 00       	.word	0x0034	; ????
 3a6:	03 0e       	add	r0, r19
 3a8:	3a 0b       	sbc	r19, r26
 3aa:	3b 0b       	sbc	r19, r27
 3ac:	49 13       	cpse	r20, r25
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ae:	3f 0c       	add	r3, r15
 3b0:	02 0a       	sbc	r0, r18
 3b2:	00 00       	nop
 3b4:	3b 34       	cpi	r19, 0x4B	; 75
 3b6:	00 03       	mulsu	r16, r16
 3b8:	0e 3a       	cpi	r16, 0xAE	; 174
 3ba:	0b 3b       	cpi	r16, 0xBB	; 187
 3bc:	0b 49       	sbci	r16, 0x9B	; 155
 3be:	13 3f       	cpi	r17, 0xF3	; 243
 3c0:	0c 02       	muls	r16, r28
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3c2:	0a 00       	.word	0x000a	; ????
 3c4:	00 3c       	cpi	r16, 0xC0	; 192
 3c6:	34 00       	.word	0x0034	; ????
 3c8:	03 0e       	add	r0, r19
 3ca:	3a 0b       	sbc	r19, r26
 3cc:	3b 0b       	sbc	r19, r27
 3ce:	49 13       	cpse	r20, r25
 3d0:	3f 0c       	add	r3, r15
 3d2:	02 0a       	sbc	r0, r18
 3d4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3d6:	3d 34       	cpi	r19, 0x4D	; 77
 3d8:	00 03       	mulsu	r16, r16
 3da:	0e 3a       	cpi	r16, 0xAE	; 174
 3dc:	0b 3b       	cpi	r16, 0xBB	; 187
 3de:	0b 49       	sbci	r16, 0x9B	; 155
 3e0:	13 3f       	cpi	r17, 0xF3	; 243
 3e2:	0c 02       	muls	r16, r28
 3e4:	0a 00       	.word	0x000a	; ????
 3e6:	00 3e       	cpi	r16, 0xE0	; 224
 3e8:	34 00       	.word	0x0034	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ea:	03 0e       	add	r0, r19
 3ec:	3a 0b       	sbc	r19, r26
 3ee:	3b 0b       	sbc	r19, r27
 3f0:	49 13       	cpse	r20, r25
 3f2:	3f 0c       	add	r3, r15
 3f4:	02 0a       	sbc	r0, r18
 3f6:	00 00       	nop
 3f8:	3f 34       	cpi	r19, 0x4F	; 79
 3fa:	00 03       	mulsu	r16, r16
 3fc:	0e 3a       	cpi	r16, 0xAE	; 174
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3fe:	0b 3b       	cpi	r16, 0xBB	; 187
 400:	0b 49       	sbci	r16, 0x9B	; 155
 402:	13 3f       	cpi	r17, 0xF3	; 243
 404:	0c 02       	muls	r16, r28
 406:	0a 00       	.word	0x000a	; ????
 408:	00 40       	sbci	r16, 0x00	; 0
 40a:	34 00       	.word	0x0034	; ????
 40c:	03 0e       	add	r0, r19
 40e:	3a 0b       	sbc	r19, r26
 410:	3b 0b       	sbc	r19, r27
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 412:	49 13       	cpse	r20, r25
 414:	3f 0c       	add	r3, r15
 416:	02 0a       	sbc	r0, r18
 418:	00 00       	nop
 41a:	41 34       	cpi	r20, 0x41	; 65
 41c:	00 03       	mulsu	r16, r16
 41e:	0e 3a       	cpi	r16, 0xAE	; 174
 420:	0b 3b       	cpi	r16, 0xBB	; 187
 422:	0b 49       	sbci	r16, 0x9B	; 155
 424:	13 3f       	cpi	r17, 0xF3	; 243
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 426:	0c 02       	muls	r16, r28
 428:	0a 00       	.word	0x000a	; ????
 42a:	00 42       	sbci	r16, 0x20	; 32
 42c:	34 00       	.word	0x0034	; ????
 42e:	03 0e       	add	r0, r19
 430:	3a 0b       	sbc	r19, r26
 432:	3b 0b       	sbc	r19, r27
 434:	49 13       	cpse	r20, r25
 436:	3f 0c       	add	r3, r15
 438:	02 0a       	sbc	r0, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 43a:	00 00       	nop
 43c:	43 34       	cpi	r20, 0x43	; 67
 43e:	00 03       	mulsu	r16, r16
 440:	0e 3a       	cpi	r16, 0xAE	; 174
 442:	0b 3b       	cpi	r16, 0xBB	; 187
 444:	0b 49       	sbci	r16, 0x9B	; 155
 446:	13 3f       	cpi	r17, 0xF3	; 243
 448:	0c 02       	muls	r16, r28
 44a:	0a 00       	.word	0x000a	; ????
 44c:	00 44       	sbci	r16, 0x40	; 64
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 44e:	34 00       	.word	0x0034	; ????
 450:	03 0e       	add	r0, r19
 452:	3a 0b       	sbc	r19, r26
 454:	3b 0b       	sbc	r19, r27
 456:	49 13       	cpse	r20, r25
 458:	3f 0c       	add	r3, r15
 45a:	02 0a       	sbc	r0, r18
 45c:	00 00       	nop
 45e:	45 34       	cpi	r20, 0x45	; 69
 460:	00 03       	mulsu	r16, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 462:	0e 3a       	cpi	r16, 0xAE	; 174
 464:	0b 3b       	cpi	r16, 0xBB	; 187
 466:	0b 49       	sbci	r16, 0x9B	; 155
 468:	13 3f       	cpi	r17, 0xF3	; 243
 46a:	0c 02       	muls	r16, r28
 46c:	0a 00       	.word	0x000a	; ????
 46e:	00 46       	sbci	r16, 0x60	; 96
 470:	34 00       	.word	0x0034	; ????
 472:	03 0e       	add	r0, r19
 474:	3a 0b       	sbc	r19, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 476:	3b 0b       	sbc	r19, r27
 478:	49 13       	cpse	r20, r25
 47a:	3f 0c       	add	r3, r15
 47c:	02 0a       	sbc	r0, r18
 47e:	00 00       	nop
 480:	47 34       	cpi	r20, 0x47	; 71
 482:	00 03       	mulsu	r16, r16
 484:	0e 3a       	cpi	r16, 0xAE	; 174
 486:	0b 3b       	cpi	r16, 0xBB	; 187
 488:	0b 49       	sbci	r16, 0x9B	; 155
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 48a:	13 3f       	cpi	r17, 0xF3	; 243
 48c:	0c 02       	muls	r16, r28
 48e:	0a 00       	.word	0x000a	; ????
 490:	00 48       	sbci	r16, 0x80	; 128
 492:	34 00       	.word	0x0034	; ????
 494:	03 0e       	add	r0, r19
 496:	3a 0b       	sbc	r19, r26
 498:	3b 0b       	sbc	r19, r27
 49a:	49 13       	cpse	r20, r25
 49c:	3f 0c       	add	r3, r15
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 49e:	02 0a       	sbc	r0, r18
 4a0:	00 00       	nop
 4a2:	49 34       	cpi	r20, 0x49	; 73
 4a4:	00 03       	mulsu	r16, r16
 4a6:	0e 3a       	cpi	r16, 0xAE	; 174
 4a8:	0b 3b       	cpi	r16, 0xBB	; 187
 4aa:	0b 49       	sbci	r16, 0x9B	; 155
 4ac:	13 3f       	cpi	r17, 0xF3	; 243
 4ae:	0c 02       	muls	r16, r28
 4b0:	0a 00       	.word	0x000a	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4b2:	00 4a       	sbci	r16, 0xA0	; 160
 4b4:	34 00       	.word	0x0034	; ????
 4b6:	03 0e       	add	r0, r19
 4b8:	3a 0b       	sbc	r19, r26
 4ba:	3b 0b       	sbc	r19, r27
 4bc:	49 13       	cpse	r20, r25
 4be:	3f 0c       	add	r3, r15
 4c0:	02 0a       	sbc	r0, r18
 4c2:	00 00       	nop
 4c4:	4b 34       	cpi	r20, 0x4B	; 75
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4c6:	00 03       	mulsu	r16, r16
 4c8:	0e 3a       	cpi	r16, 0xAE	; 174
 4ca:	0b 3b       	cpi	r16, 0xBB	; 187
 4cc:	0b 49       	sbci	r16, 0x9B	; 155
 4ce:	13 3f       	cpi	r17, 0xF3	; 243
 4d0:	0c 02       	muls	r16, r28
 4d2:	0a 00       	.word	0x000a	; ????
 4d4:	00 4c       	sbci	r16, 0xC0	; 192
 4d6:	34 00       	.word	0x0034	; ????
 4d8:	03 0e       	add	r0, r19
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4da:	3a 0b       	sbc	r19, r26
 4dc:	3b 0b       	sbc	r19, r27
 4de:	49 13       	cpse	r20, r25
 4e0:	3f 0c       	add	r3, r15
 4e2:	02 0a       	sbc	r0, r18
 4e4:	00 00       	nop
 4e6:	4d 34       	cpi	r20, 0x4D	; 77
 4e8:	00 03       	mulsu	r16, r16
 4ea:	0e 3a       	cpi	r16, 0xAE	; 174
 4ec:	0b 3b       	cpi	r16, 0xBB	; 187
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4ee:	0b 49       	sbci	r16, 0x9B	; 155
 4f0:	13 3f       	cpi	r17, 0xF3	; 243
 4f2:	0c 02       	muls	r16, r28
 4f4:	0a 00       	.word	0x000a	; ????
 4f6:	00 4e       	sbci	r16, 0xE0	; 224
 4f8:	34 00       	.word	0x0034	; ????
 4fa:	03 0e       	add	r0, r19
 4fc:	3a 0b       	sbc	r19, r26
 4fe:	3b 0b       	sbc	r19, r27
 500:	49 13       	cpse	r20, r25
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 502:	3f 0c       	add	r3, r15
 504:	02 0a       	sbc	r0, r18
 506:	00 00       	nop
 508:	4f 34       	cpi	r20, 0x4F	; 79
 50a:	00 03       	mulsu	r16, r16
 50c:	0e 3a       	cpi	r16, 0xAE	; 174
 50e:	0b 3b       	cpi	r16, 0xBB	; 187
 510:	0b 49       	sbci	r16, 0x9B	; 155
 512:	13 3f       	cpi	r17, 0xF3	; 243
 514:	0c 02       	muls	r16, r28
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 516:	0a 00       	.word	0x000a	; ????
 518:	00 50       	subi	r16, 0x00	; 0
 51a:	34 00       	.word	0x0034	; ????
 51c:	03 0e       	add	r0, r19
 51e:	3a 0b       	sbc	r19, r26
 520:	3b 0b       	sbc	r19, r27
 522:	49 13       	cpse	r20, r25
 524:	3f 0c       	add	r3, r15
 526:	02 0a       	sbc	r0, r18
 528:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 52a:	51 34       	cpi	r21, 0x41	; 65
 52c:	00 03       	mulsu	r16, r16
 52e:	0e 3a       	cpi	r16, 0xAE	; 174
 530:	0b 3b       	cpi	r16, 0xBB	; 187
 532:	0b 49       	sbci	r16, 0x9B	; 155
 534:	13 3f       	cpi	r17, 0xF3	; 243
 536:	0c 02       	muls	r16, r28
 538:	0a 00       	.word	0x000a	; ????
 53a:	00 52       	subi	r16, 0x20	; 32
 53c:	34 00       	.word	0x0034	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 53e:	03 0e       	add	r0, r19
 540:	3a 0b       	sbc	r19, r26
 542:	3b 0b       	sbc	r19, r27
 544:	49 13       	cpse	r20, r25
 546:	3f 0c       	add	r3, r15
 548:	02 0a       	sbc	r0, r18
 54a:	00 00       	nop
 54c:	53 34       	cpi	r21, 0x43	; 67
 54e:	00 03       	mulsu	r16, r16
 550:	0e 3a       	cpi	r16, 0xAE	; 174
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 552:	0b 3b       	cpi	r16, 0xBB	; 187
 554:	0b 49       	sbci	r16, 0x9B	; 155
 556:	13 3f       	cpi	r17, 0xF3	; 243
 558:	0c 02       	muls	r16, r28
 55a:	0a 00       	.word	0x000a	; ????
 55c:	00 54       	subi	r16, 0x40	; 64
 55e:	34 00       	.word	0x0034	; ????
 560:	03 0e       	add	r0, r19
 562:	3a 0b       	sbc	r19, r26
 564:	3b 0b       	sbc	r19, r27
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 566:	49 13       	cpse	r20, r25
 568:	3f 0c       	add	r3, r15
 56a:	02 0a       	sbc	r0, r18
 56c:	00 00       	nop
 56e:	55 34       	cpi	r21, 0x45	; 69
 570:	00 03       	mulsu	r16, r16
 572:	0e 3a       	cpi	r16, 0xAE	; 174
 574:	0b 3b       	cpi	r16, 0xBB	; 187
 576:	0b 49       	sbci	r16, 0x9B	; 155
 578:	13 3f       	cpi	r17, 0xF3	; 243
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 57a:	0c 02       	muls	r16, r28
 57c:	0a 00       	.word	0x000a	; ????
 57e:	00 56       	subi	r16, 0x60	; 96
 580:	34 00       	.word	0x0034	; ????
 582:	03 0e       	add	r0, r19
 584:	3a 0b       	sbc	r19, r26
 586:	3b 0b       	sbc	r19, r27
 588:	49 13       	cpse	r20, r25
 58a:	3f 0c       	add	r3, r15
 58c:	02 0a       	sbc	r0, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 58e:	00 00       	nop
 590:	57 34       	cpi	r21, 0x47	; 71
 592:	00 03       	mulsu	r16, r16
 594:	0e 3a       	cpi	r16, 0xAE	; 174
 596:	0b 3b       	cpi	r16, 0xBB	; 187
 598:	0b 49       	sbci	r16, 0x9B	; 155
 59a:	13 3f       	cpi	r17, 0xF3	; 243
 59c:	0c 02       	muls	r16, r28
 59e:	0a 00       	.word	0x000a	; ????
 5a0:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5a2:	01 11       	cpse	r16, r1
 5a4:	01 25       	eor	r16, r1
 5a6:	0e 13       	cpse	r16, r30
 5a8:	0b 03       	fmul	r16, r19
 5aa:	0e 1b       	sub	r16, r30
 5ac:	0e 55       	subi	r16, 0x5E	; 94
 5ae:	06 11       	cpse	r16, r6
 5b0:	01 52       	subi	r16, 0x21	; 33
 5b2:	01 10       	cpse	r0, r1
 5b4:	06 00       	.word	0x0006	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5b6:	00 02       	muls	r16, r16
 5b8:	16 00       	.word	0x0016	; ????
 5ba:	03 0e       	add	r0, r19
 5bc:	3a 0b       	sbc	r19, r26
 5be:	3b 0b       	sbc	r19, r27
 5c0:	49 13       	cpse	r20, r25
 5c2:	00 00       	nop
 5c4:	03 24       	eor	r0, r3
 5c6:	00 0b       	sbc	r16, r16
 5c8:	0b 3e       	cpi	r16, 0xEB	; 235
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5ca:	0b 03       	fmul	r16, r19
 5cc:	0e 00       	.word	0x000e	; ????
 5ce:	00 04       	cpc	r0, r0
 5d0:	26 00       	.word	0x0026	; ????
 5d2:	49 13       	cpse	r20, r25
 5d4:	00 00       	nop
 5d6:	05 2e       	mov	r0, r21
 5d8:	01 03       	mulsu	r16, r17
 5da:	0e 3a       	cpi	r16, 0xAE	; 174
 5dc:	0b 3b       	cpi	r16, 0xBB	; 187
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5de:	0b 20       	and	r0, r11
 5e0:	0b 01       	movw	r0, r22
 5e2:	13 00       	.word	0x0013	; ????
 5e4:	00 06       	cpc	r0, r16
 5e6:	05 00       	.word	0x0005	; ????
 5e8:	03 08       	sbc	r0, r3
 5ea:	3a 0b       	sbc	r19, r26
 5ec:	3b 0b       	sbc	r19, r27
 5ee:	49 13       	cpse	r20, r25
 5f0:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5f2:	07 05       	cpc	r16, r7
 5f4:	00 03       	mulsu	r16, r16
 5f6:	0e 3a       	cpi	r16, 0xAE	; 174
 5f8:	0b 3b       	cpi	r16, 0xBB	; 187
 5fa:	0b 49       	sbci	r16, 0x9B	; 155
 5fc:	13 00       	.word	0x0013	; ????
 5fe:	00 08       	sbc	r0, r0
 600:	34 00       	.word	0x0034	; ????
 602:	03 08       	sbc	r0, r3
 604:	3a 0b       	sbc	r19, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 606:	3b 0b       	sbc	r19, r27
 608:	49 13       	cpse	r20, r25
 60a:	00 00       	nop
 60c:	09 34       	cpi	r16, 0x49	; 73
 60e:	00 03       	mulsu	r16, r16
 610:	0e 3a       	cpi	r16, 0xAE	; 174
 612:	0b 3b       	cpi	r16, 0xBB	; 187
 614:	0b 49       	sbci	r16, 0x9B	; 155
 616:	13 00       	.word	0x0013	; ????
 618:	00 0a       	sbc	r0, r16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 61a:	0b 01       	movw	r0, r22
 61c:	01 13       	cpse	r16, r17
 61e:	00 00       	nop
 620:	0b 0b       	sbc	r16, r27
 622:	01 00       	.word	0x0001	; ????
 624:	00 0c       	add	r0, r0
 626:	0f 00       	.word	0x000f	; ????
 628:	0b 0b       	sbc	r16, r27
 62a:	49 13       	cpse	r20, r25
 62c:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 62e:	0d 35       	cpi	r16, 0x5D	; 93
 630:	00 49       	sbci	r16, 0x90	; 144
 632:	13 00       	.word	0x0013	; ????
 634:	00 0e       	add	r0, r16
 636:	2e 01       	movw	r4, r28
 638:	03 0e       	add	r0, r19
 63a:	34 0c       	add	r3, r4
 63c:	20 0b       	sbc	r18, r16
 63e:	01 13       	cpse	r16, r17
 640:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 642:	0f 2e       	mov	r0, r31
 644:	01 31       	cpi	r16, 0x11	; 17
 646:	13 11       	cpse	r17, r3
 648:	01 12       	cpse	r0, r17
 64a:	01 40       	sbci	r16, 0x01	; 1
 64c:	0a 97       	sbiw	r24, 0x0a	; 10
 64e:	42 0c       	add	r4, r2
 650:	01 13       	cpse	r16, r17
 652:	00 00       	nop
 654:	10 05       	cpc	r17, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 656:	00 31       	cpi	r16, 0x10	; 16
 658:	13 02       	muls	r17, r19
 65a:	0a 00       	.word	0x000a	; ????
 65c:	00 11       	cpse	r16, r0
 65e:	34 00       	.word	0x0034	; ????
 660:	31 13       	cpse	r19, r17
 662:	02 06       	cpc	r0, r18
 664:	00 00       	nop
 666:	12 05       	cpc	r17, r2
 668:	00 31       	cpi	r16, 0x10	; 16
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 66a:	13 1c       	adc	r1, r3
 66c:	0b 00       	.word	0x000b	; ????
 66e:	00 13       	cpse	r16, r16
 670:	0b 01       	movw	r0, r22
 672:	31 13       	cpse	r19, r17
 674:	11 01       	movw	r2, r2
 676:	12 01       	movw	r2, r4
 678:	01 13       	cpse	r16, r17
 67a:	00 00       	nop
 67c:	14 1d       	adc	r17, r4
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 67e:	01 31       	cpi	r16, 0x11	; 17
 680:	13 52       	subi	r17, 0x23	; 35
 682:	01 55       	subi	r16, 0x51	; 81
 684:	06 58       	subi	r16, 0x86	; 134
 686:	0b 59       	subi	r16, 0x9B	; 155
 688:	0b 01       	movw	r0, r22
 68a:	13 00       	.word	0x0013	; ????
 68c:	00 15       	cp	r16, r0
 68e:	05 00       	.word	0x0005	; ????
 690:	31 13       	cpse	r19, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 692:	02 06       	cpc	r0, r18
 694:	00 00       	nop
 696:	16 0b       	sbc	r17, r22
 698:	01 11       	cpse	r16, r1
 69a:	01 12       	cpse	r0, r17
 69c:	01 00       	.word	0x0001	; ????
 69e:	00 17       	cp	r16, r16
 6a0:	34 00       	.word	0x0034	; ????
 6a2:	31 13       	cpse	r19, r17
 6a4:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6a6:	18 0b       	sbc	r17, r24
 6a8:	01 31       	cpi	r16, 0x11	; 17
 6aa:	13 11       	cpse	r17, r3
 6ac:	01 12       	cpse	r0, r17
 6ae:	01 00       	.word	0x0001	; ????
 6b0:	00 19       	sub	r16, r0
 6b2:	2e 01       	movw	r4, r28
 6b4:	3f 0c       	add	r3, r15
 6b6:	03 0e       	add	r0, r19
 6b8:	3a 0b       	sbc	r19, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ba:	3b 0b       	sbc	r19, r27
 6bc:	11 01       	movw	r2, r2
 6be:	12 01       	movw	r2, r4
 6c0:	40 06       	cpc	r4, r16
 6c2:	97 42       	sbci	r25, 0x27	; 39
 6c4:	0c 01       	movw	r0, r24
 6c6:	13 00       	.word	0x0013	; ????
 6c8:	00 1a       	sub	r0, r16
 6ca:	34 00       	.word	0x0034	; ????
 6cc:	03 08       	sbc	r0, r3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ce:	3a 0b       	sbc	r19, r26
 6d0:	3b 0b       	sbc	r19, r27
 6d2:	49 13       	cpse	r20, r25
 6d4:	02 06       	cpc	r0, r18
 6d6:	00 00       	nop
 6d8:	1b 2e       	mov	r1, r27
 6da:	00 03       	mulsu	r16, r16
 6dc:	0e 3a       	cpi	r16, 0xAE	; 174
 6de:	0b 3b       	cpi	r16, 0xBB	; 187
 6e0:	0b 20       	and	r0, r11
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6e2:	0b 00       	.word	0x000b	; ????
 6e4:	00 1c       	adc	r0, r0
 6e6:	2e 01       	movw	r4, r28
 6e8:	3f 0c       	add	r3, r15
 6ea:	03 0e       	add	r0, r19
 6ec:	3a 0b       	sbc	r19, r26
 6ee:	3b 0b       	sbc	r19, r27
 6f0:	49 13       	cpse	r20, r25
 6f2:	87 01       	movw	r16, r14
 6f4:	0c 11       	cpse	r16, r12
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6f6:	01 12       	cpse	r0, r17
 6f8:	01 40       	sbci	r16, 0x01	; 1
 6fa:	0a 97       	sbiw	r24, 0x0a	; 10
 6fc:	42 0c       	add	r4, r2
 6fe:	01 13       	cpse	r16, r17
 700:	00 00       	nop
 702:	1d 1d       	adc	r17, r13
 704:	00 31       	cpi	r16, 0x10	; 16
 706:	13 11       	cpse	r17, r3
 708:	01 12       	cpse	r0, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 70a:	01 58       	subi	r16, 0x81	; 129
 70c:	0b 59       	subi	r16, 0x9B	; 155
 70e:	0b 00       	.word	0x000b	; ????
 710:	00 1e       	adc	r0, r16
 712:	1d 01       	movw	r2, r26
 714:	31 13       	cpse	r19, r17
 716:	11 01       	movw	r2, r2
 718:	12 01       	movw	r2, r4
 71a:	58 0b       	sbc	r21, r24
 71c:	59 0b       	sbc	r21, r25
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 71e:	01 13       	cpse	r16, r17
 720:	00 00       	nop
 722:	1f 1d       	adc	r17, r15
 724:	01 31       	cpi	r16, 0x11	; 17
 726:	13 11       	cpse	r17, r3
 728:	01 12       	cpse	r0, r17
 72a:	01 58       	subi	r16, 0x81	; 129
 72c:	0b 59       	subi	r16, 0x9B	; 155
 72e:	0b 00       	.word	0x000b	; ????
 730:	00 20       	and	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 732:	89 82       	std	Y+1, r8	; 0x01
 734:	01 01       	movw	r0, r2
 736:	11 01       	movw	r2, r2
 738:	31 13       	cpse	r19, r17
 73a:	01 13       	cpse	r16, r17
 73c:	00 00       	nop
 73e:	21 8a       	std	Z+17, r2	; 0x11
 740:	82 01       	movw	r16, r4
 742:	00 02       	muls	r16, r16
 744:	0a 91       	ld	r16, -Y
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 746:	42 0a       	sbc	r4, r18
 748:	00 00       	nop
 74a:	22 89       	ldd	r18, Z+18	; 0x12
 74c:	82 01       	movw	r16, r4
 74e:	01 11       	cpse	r16, r1
 750:	01 31       	cpi	r16, 0x11	; 17
 752:	13 00       	.word	0x0013	; ????
 754:	00 23       	and	r16, r16
 756:	89 82       	std	Y+1, r8	; 0x01
 758:	01 00       	.word	0x0001	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 75a:	11 01       	movw	r2, r2
 75c:	00 00       	nop
 75e:	24 24       	eor	r2, r4
 760:	00 0b       	sbc	r16, r16
 762:	0b 3e       	cpi	r16, 0xEB	; 235
 764:	0b 03       	fmul	r16, r19
 766:	08 00       	.word	0x0008	; ????
 768:	00 25       	eor	r16, r0
 76a:	01 01       	movw	r0, r2
 76c:	49 13       	cpse	r20, r25
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 76e:	01 13       	cpse	r16, r17
 770:	00 00       	nop
 772:	26 21       	and	r18, r6
 774:	00 49       	sbci	r16, 0x90	; 144
 776:	13 2f       	mov	r17, r19
 778:	0b 00       	.word	0x000b	; ????
 77a:	00 27       	eor	r16, r16
 77c:	34 00       	.word	0x0034	; ????
 77e:	03 0e       	add	r0, r19
 780:	3a 0b       	sbc	r19, r26
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 782:	3b 0b       	sbc	r19, r27
 784:	49 13       	cpse	r20, r25
 786:	02 0a       	sbc	r0, r18
 788:	00 00       	nop
 78a:	00 01       	movw	r0, r0
 78c:	11 00       	.word	0x0011	; ????
 78e:	10 06       	cpc	r1, r16
 790:	11 01       	movw	r2, r2
 792:	12 01       	movw	r2, r4
 794:	03 08       	sbc	r0, r3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 796:	1b 08       	sbc	r1, r11
 798:	25 08       	sbc	r2, r5
 79a:	13 05       	cpc	r17, r3
 79c:	00 00       	nop
 79e:	00 01       	movw	r0, r0
 7a0:	11 00       	.word	0x0011	; ????
 7a2:	10 06       	cpc	r1, r16
 7a4:	11 01       	movw	r2, r2
 7a6:	12 01       	movw	r2, r4
 7a8:	03 08       	sbc	r0, r3
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7aa:	1b 08       	sbc	r1, r11
 7ac:	25 08       	sbc	r2, r5
 7ae:	13 05       	cpc	r17, r3
 7b0:	00 00       	nop
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
   0:	16 00       	.word	0x0016	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	10 00       	.word	0x0010	; ????
   8:	00 00       	nop
   a:	02 01       	movw	r0, r4
   c:	fb 0e       	add	r15, r27
   e:	0a 00       	.word	0x000a	; ????
  10:	01 01       	movw	r0, r2
  12:	01 01       	movw	r0, r2
  14:	00 00       	nop
  16:	00 01       	movw	r0, r0
  18:	00 00       	nop
  1a:	40 07       	cpc	r20, r16
  1c:	00 00       	nop
  1e:	02 00       	.word	0x0002	; ????
  20:	ac 01       	movw	r20, r24
  22:	00 00       	nop
  24:	02 01       	movw	r0, r4
  26:	fb 0e       	add	r15, r27
  28:	0a 00       	.word	0x000a	; ????
  2a:	01 01       	movw	r0, r2
  2c:	01 01       	movw	r0, r2
  2e:	00 00       	nop
  30:	00 01       	movw	r0, r0
  32:	43 3a       	cpi	r20, 0xA3	; 163
  34:	5c 50       	subi	r21, 0x0C	; 12
  36:	72 6f       	ori	r23, 0xF2	; 242
  38:	67 72       	andi	r22, 0x27	; 39
  3a:	61 6d       	ori	r22, 0xD1	; 209
  3c:	20 46       	sbci	r18, 0x60	; 96
  3e:	69 6c       	ori	r22, 0xC9	; 201
  40:	65 73       	andi	r22, 0x35	; 53
  42:	20 28       	or	r2, r0
  44:	78 38       	cpi	r23, 0x88	; 136
  46:	36 29       	or	r19, r6
  48:	5c 41       	sbci	r21, 0x1C	; 28
  4a:	72 64       	ori	r23, 0x42	; 66
  4c:	75 69       	ori	r23, 0x95	; 149
  4e:	6e 6f       	ori	r22, 0xFE	; 254
  50:	5c 68       	ori	r21, 0x8C	; 140
  52:	61 72       	andi	r22, 0x21	; 33
  54:	64 77       	andi	r22, 0x74	; 116
  56:	61 72       	andi	r22, 0x21	; 33
  58:	65 5c       	subi	r22, 0xC5	; 197
  5a:	61 72       	andi	r22, 0x21	; 33
  5c:	64 75       	andi	r22, 0x54	; 84
  5e:	69 6e       	ori	r22, 0xE9	; 233
  60:	6f 5c       	subi	r22, 0xCF	; 207
  62:	61 76       	andi	r22, 0x61	; 97
  64:	72 5c       	subi	r23, 0xC2	; 194
  66:	63 6f       	ori	r22, 0xF3	; 243
  68:	72 65       	ori	r23, 0x52	; 82
  6a:	73 5c       	subi	r23, 0xC3	; 195
  6c:	61 72       	andi	r22, 0x21	; 33
  6e:	64 75       	andi	r22, 0x54	; 84
  70:	69 6e       	ori	r22, 0xE9	; 233
  72:	6f 00       	.word	0x006f	; ????
  74:	43 3a       	cpi	r20, 0xA3	; 163
  76:	5c 55       	subi	r21, 0x5C	; 92
  78:	73 65       	ori	r23, 0x53	; 83
  7a:	72 73       	andi	r23, 0x32	; 50
  7c:	5c 52       	subi	r21, 0x2C	; 44
  7e:	59 77       	andi	r21, 0x79	; 121
  80:	6f 72       	andi	r22, 0x2F	; 47
  82:	6b 5c       	subi	r22, 0xCB	; 203
  84:	44 65       	ori	r20, 0x54	; 84
  86:	73 6b       	ori	r23, 0xB3	; 179
  88:	74 6f       	ori	r23, 0xF4	; 244
  8a:	70 5c       	subi	r23, 0xC0	; 192
  8c:	53 70       	andi	r21, 0x03	; 3
  8e:	72 69       	ori	r23, 0x92	; 146
  90:	6e 67       	ori	r22, 0x7E	; 126
  92:	20 31       	cpi	r18, 0x10	; 16
  94:	39 5c       	subi	r19, 0xC9	; 201
  96:	61 73       	andi	r22, 0x31	; 49
  98:	73 69       	ori	r23, 0x93	; 147
  9a:	67 6e       	ori	r22, 0xE7	; 231
  9c:	6d 65       	ori	r22, 0x5D	; 93
  9e:	6e 74       	andi	r22, 0x4E	; 78
  a0:	34 5c       	subi	r19, 0xC4	; 196
  a2:	41 72       	andi	r20, 0x21	; 33
  a4:	64 75       	andi	r22, 0x54	; 84
  a6:	69 6e       	ori	r22, 0xE9	; 233
  a8:	6f 41       	sbci	r22, 0x1F	; 31
  aa:	73 73       	andi	r23, 0x33	; 51
  ac:	65 6d       	ori	r22, 0xD5	; 213
  ae:	62 6c       	ori	r22, 0xC2	; 194
  b0:	79 50       	subi	r23, 0x09	; 9
  b2:	61 72       	andi	r22, 0x21	; 33
  b4:	73 65       	ori	r23, 0x53	; 83
  b6:	72 5c       	subi	r23, 0xC2	; 194
  b8:	50 61       	ori	r21, 0x10	; 16
  ba:	72 73       	andi	r23, 0x32	; 50
  bc:	65 72       	andi	r22, 0x25	; 37
  be:	49 6e       	ori	r20, 0xE9	; 233
  c0:	70 75       	andi	r23, 0x50	; 80
  c2:	74 46       	sbci	r23, 0x64	; 100
  c4:	69 6c       	ori	r22, 0xC9	; 201
  c6:	65 73       	andi	r22, 0x35	; 53
  c8:	5c 52       	subi	r21, 0x2C	; 44
  ca:	61 77       	andi	r22, 0x71	; 113
  cc:	41 72       	andi	r20, 0x21	; 33
  ce:	64 75       	andi	r22, 0x54	; 84
  d0:	69 6e       	ori	r22, 0xE9	; 233
  d2:	6f 46       	sbci	r22, 0x6F	; 111
  d4:	69 6c       	ori	r22, 0xC9	; 201
  d6:	65 73       	andi	r22, 0x35	; 53
  d8:	5c 4c       	sbci	r21, 0xCC	; 204
  da:	41 44       	sbci	r20, 0x41	; 65
  dc:	53 5f       	subi	r21, 0xF3	; 243
  de:	53 6c       	ori	r21, 0xC3	; 195
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	65 65       	ori	r22, 0x55	; 85
  e2:	70 5f       	subi	r23, 0xF0	; 240
  e4:	6c 6f       	ori	r22, 0xFC	; 252
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	6f 70       	andi	r22, 0x0F	; 15
  e8:	00 63       	ori	r16, 0x30	; 48
  ea:	3a 5c       	subi	r19, 0xCA	; 202
	uint8_t port = digitalPinToPort(pin);
  ec:	70 72       	andi	r23, 0x20	; 32
  ee:	6f 67       	ori	r22, 0x7F	; 127
  f0:	72 61       	ori	r23, 0x12	; 18
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	6d 20       	and	r6, r13
  f4:	66 69       	ori	r22, 0x96	; 150

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	6c 65       	ori	r22, 0x5C	; 92
  f8:	73 20       	and	r7, r3
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	28 78       	andi	r18, 0x88	; 136
  fc:	38 36       	cpi	r19, 0x68	; 104
  fe:	29 5c       	subi	r18, 0xC9	; 201
 100:	61 72       	andi	r22, 0x21	; 33
 102:	64 75       	andi	r22, 0x54	; 84
 104:	69 6e       	ori	r22, 0xE9	; 233
 106:	6f 5c       	subi	r22, 0xCF	; 207

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	68 61       	ori	r22, 0x18	; 24
 10a:	72 64       	ori	r23, 0x42	; 66
 10c:	77 61       	ori	r23, 0x17	; 23
 10e:	72 65       	ori	r23, 0x52	; 82
 110:	5c 74       	andi	r21, 0x4C	; 76
 112:	6f 6f       	ori	r22, 0xFF	; 255
 114:	6c 73       	andi	r22, 0x3C	; 60

	uint8_t oldSREG = SREG;
 116:	5c 61       	ori	r21, 0x1C	; 28
	cli();
 118:	76 72       	andi	r23, 0x26	; 38

	if (val == LOW) {
		*out &= ~bit;
 11a:	5c 61       	ori	r21, 0x1C	; 28
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	76 72       	andi	r23, 0x26	; 38
 11e:	5c 69       	ori	r21, 0x9C	; 156
		*out &= ~bit;
 120:	6e 63       	ori	r22, 0x3E	; 62
 122:	6c 75       	andi	r22, 0x5C	; 92
	} else {
		*out |= bit;
 124:	64 65       	ori	r22, 0x54	; 84
	}

	SREG = oldSREG;
 126:	00 43       	sbci	r16, 0x30	; 48
}
 128:	3a 5c       	subi	r19, 0xCA	; 202
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	50 72       	andi	r21, 0x20	; 32
 12c:	6f 67       	ori	r22, 0x7F	; 127
 12e:	72 61       	ori	r23, 0x12	; 18
 130:	6d 20       	and	r6, r13
 132:	46 69       	ori	r20, 0x96	; 150
 134:	6c 65       	ori	r22, 0x5C	; 92
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	73 20       	and	r7, r3
 138:	28 78       	andi	r18, 0x88	; 136
 13a:	38 36       	cpi	r19, 0x68	; 104
 13c:	29 5c       	subi	r18, 0xC9	; 201
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	41 72       	andi	r20, 0x21	; 33
 140:	64 75       	andi	r22, 0x54	; 84
 142:	69 6e       	ori	r22, 0xE9	; 233
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	6f 5c       	subi	r22, 0xCF	; 207
 146:	68 61       	ori	r22, 0x18	; 24
 148:	72 64       	ori	r23, 0x42	; 66
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	77 61       	ori	r23, 0x17	; 23
 14c:	72 65       	ori	r23, 0x52	; 82
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	5c 61       	ori	r21, 0x1C	; 28
 150:	72 64       	ori	r23, 0x42	; 66
 152:	75 69       	ori	r23, 0x95	; 149
 154:	6e 6f       	ori	r22, 0xFE	; 254
 156:	5c 61       	ori	r21, 0x1C	; 28
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	76 72       	andi	r23, 0x26	; 38
 15a:	5c 76       	andi	r21, 0x6C	; 108
 15c:	61 72       	andi	r22, 0x21	; 33
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	69 61       	ori	r22, 0x19	; 25
 160:	6e 74       	andi	r22, 0x4E	; 78
 162:	73 5c       	subi	r23, 0xC3	; 195
 164:	73 74       	andi	r23, 0x43	; 67
 166:	61 6e       	ori	r22, 0xE1	; 225
 168:	64 61       	ori	r22, 0x14	; 20
 16a:	72 64       	ori	r23, 0x42	; 66
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	00 00       	nop
 16e:	77 69       	ori	r23, 0x97	; 151
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	72 69       	ori	r23, 0x92	; 146
 172:	6e 67       	ori	r22, 0x7E	; 126
 174:	5f 64       	ori	r21, 0x4F	; 79
 176:	69 67       	ori	r22, 0x79	; 121
 178:	69 74       	andi	r22, 0x49	; 73
 17a:	61 6c       	ori	r22, 0xC1	; 193
 17c:	2e 63       	ori	r18, 0x3E	; 62
 17e:	00 01       	movw	r0, r0
 180:	00 00       	nop
 182:	77 69       	ori	r23, 0x97	; 151
 184:	72 69       	ori	r23, 0x92	; 146
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	6e 67       	ori	r22, 0x7E	; 126
 188:	2e 63       	ori	r18, 0x3E	; 62
 18a:	00 01       	movw	r0, r0
 18c:	00 00       	nop
 18e:	6d 61       	ori	r22, 0x1D	; 29
 190:	69 6e       	ori	r22, 0xE9	; 233
 192:	2e 63       	ori	r18, 0x3E	; 62
 194:	70 70       	andi	r23, 0x00	; 0
	unsigned char f = timer0_fract;
 196:	00 01       	movw	r0, r0
 198:	00 00       	nop

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	4c 41       	sbci	r20, 0x1C	; 28
 19c:	44 53       	subi	r20, 0x34	; 52
	if (f >= FRACT_MAX) {
 19e:	5f 53       	subi	r21, 0x3F	; 63
 1a0:	6c 65       	ori	r22, 0x5C	; 92
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	65 70       	andi	r22, 0x05	; 5
 1a4:	5f 6c       	ori	r21, 0xCF	; 207
 1a6:	6f 6f       	ori	r22, 0xFF	; 255
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	70 2e       	mov	r7, r16
 1aa:	69 6e       	ori	r22, 0xE9	; 233
	timer0_millis = m;
 1ac:	6f 00       	.word	0x006f	; ????
 1ae:	02 00       	.word	0x0002	; ????
 1b0:	00 73       	andi	r16, 0x30	; 48
 1b2:	74 64       	ori	r23, 0x44	; 68
 1b4:	69 6e       	ori	r22, 0xE9	; 233
 1b6:	74 2e       	mov	r7, r20
 1b8:	68 00       	.word	0x0068	; ????
 1ba:	03 00       	.word	0x0003	; ????
	timer0_overflow_count++;
 1bc:	00 70       	andi	r16, 0x00	; 0
 1be:	69 6e       	ori	r22, 0xE9	; 233
 1c0:	73 5f       	subi	r23, 0xF3	; 243
 1c2:	61 72       	andi	r22, 0x21	; 33
 1c4:	64 75       	andi	r22, 0x54	; 84
 1c6:	69 6e       	ori	r22, 0xE9	; 233
 1c8:	6f 2e       	mov	r6, r31
 1ca:	68 00       	.word	0x0068	; ????
 1cc:	04 00       	.word	0x0004	; ????
 1ce:	00 00       	nop
 1d0:	00 05       	cpc	r16, r0
 1d2:	02 e0       	ldi	r16, 0x02	; 2
 1d4:	00 00       	nop
 1d6:	00 03       	mulsu	r16, r16
 1d8:	89 01       	movw	r16, r18
 1da:	01 03       	mulsu	r16, r17
 1dc:	02 09       	sbc	r16, r2
 1de:	00 00       	nop
 1e0:	01 03       	mulsu	r16, r17
}
 1e2:	01 09       	sbc	r16, r1
 1e4:	06 00       	.word	0x0006	; ????
 1e6:	01 03       	mulsu	r16, r17
 1e8:	01 09       	sbc	r16, r1
 1ea:	06 00       	.word	0x0006	; ????
 1ec:	01 03       	mulsu	r16, r17
 1ee:	03 09       	sbc	r16, r3
 1f0:	06 00       	.word	0x0006	; ????
 1f2:	01 03       	mulsu	r16, r17
 1f4:	04 09       	sbc	r16, r4
 1f6:	04 00       	.word	0x0004	; ????
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	01 03       	mulsu	r16, r17
 1fa:	b8 7f       	andi	r27, 0xF8	; 248
		m += 1;
 1fc:	09 04       	cpc	r0, r9
 1fe:	00 01       	movw	r0, r0
 200:	03 ca       	rjmp	.-3066   	; 0xfffff608 <__eeprom_end+0xff7ef608>
 202:	00 09       	sbc	r16, r0

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	0e 00       	.word	0x000e	; ????
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	01 03       	mulsu	r16, r17
 208:	02 09       	sbc	r16, r2
 20a:	0e 00       	.word	0x000e	; ????
	sbi(TCCR0A, WGM00);
 20c:	01 03       	mulsu	r16, r17
 20e:	01 09       	sbc	r16, r1
 210:	02 00       	.word	0x0002	; ????
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	01 03       	mulsu	r16, r17
 214:	03 09       	sbc	r16, r3
 216:	02 00       	.word	0x0002	; ????
	sbi(TCCR0B, CS00);
 218:	01 03       	mulsu	r16, r17
 21a:	7f 09       	sbc	r23, r15
 21c:	02 00       	.word	0x0002	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	01 03       	mulsu	r16, r17
 220:	01 09       	sbc	r16, r1
 222:	04 00       	.word	0x0004	; ????
 224:	01 03       	mulsu	r16, r17
 226:	02 09       	sbc	r16, r2
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	04 00       	.word	0x0004	; ????
 22a:	01 03       	mulsu	r16, r17

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	03 09       	sbc	r16, r3
 22e:	02 00       	.word	0x0002	; ????
 230:	01 03       	mulsu	r16, r17
 232:	01 09       	sbc	r16, r1
 234:	02 00       	.word	0x0002	; ????
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	01 03       	mulsu	r16, r17
 238:	aa 7f       	andi	r26, 0xFA	; 250
 23a:	09 02       	muls	r16, r25
 23c:	00 01       	movw	r0, r0
 23e:	03 06       	cpc	r0, r19
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	09 0c       	add	r0, r9
 242:	00 01       	movw	r0, r0
 244:	03 7d       	andi	r16, 0xD3	; 211
 246:	09 08       	sbc	r0, r9
 248:	00 01       	movw	r0, r0

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	03 03       	mulsu	r16, r19
 24c:	09 06       	cpc	r0, r25
 24e:	00 01       	movw	r0, r0
 250:	03 0b       	sbc	r16, r19
 252:	09 06       	cpc	r0, r25

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	00 01       	movw	r0, r0
 256:	03 04       	cpc	r0, r3
 258:	09 04       	cpc	r0, r9
 25a:	00 01       	movw	r0, r0
 25c:	03 03       	mulsu	r16, r19
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	09 0a       	sbc	r0, r25
 260:	00 01       	movw	r0, r0
 262:	03 03       	mulsu	r16, r19
 264:	09 06       	cpc	r0, r25
 266:	00 01       	movw	r0, r0
		sbi(ADCSRA, ADPS1);
 268:	03 37       	cpi	r16, 0x73	; 115
 26a:	09 0e       	add	r0, r25
 26c:	00 01       	movw	r0, r0
 26e:	04 02       	muls	r16, r20
 270:	03 90       	.word	0x9003	; ????
		sbi(ADCSRA, ADPS0);
 272:	7f 09       	sbc	r23, r15
 274:	04 00       	.word	0x0004	; ????
 276:	01 03       	mulsu	r16, r17
 278:	03 09       	sbc	r16, r3
 27a:	16 00       	.word	0x0016	; ????
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	01 03       	mulsu	r16, r17
 27e:	01 09       	sbc	r16, r1
 280:	10 00       	.word	0x0010	; ????
 282:	01 03       	mulsu	r16, r17
 284:	03 09       	sbc	r16, r3
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	04 00       	.word	0x0004	; ????
 288:	01 03       	mulsu	r16, r17
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	01 09       	sbc	r16, r1
 28c:	04 00       	.word	0x0004	; ????
 28e:	01 03       	mulsu	r16, r17
	uint8_t port = digitalPinToPort(pin);
 290:	7e 09       	sbc	r23, r14
 292:	04 00       	.word	0x0004	; ????
 294:	01 03       	mulsu	r16, r17
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	07 09       	sbc	r16, r7
 298:	06 00       	.word	0x0006	; ????

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	01 03       	mulsu	r16, r17
 29c:	01 09       	sbc	r16, r1
 29e:	04 00       	.word	0x0004	; ????
 2a0:	01 03       	mulsu	r16, r17
 2a2:	01 09       	sbc	r16, r1
 2a4:	10 00       	.word	0x0010	; ????
 2a6:	01 03       	mulsu	r16, r17
 2a8:	01 09       	sbc	r16, r1
	out = portOutputRegister(port);
 2aa:	26 00       	.word	0x0026	; ????
 2ac:	01 03       	mulsu	r16, r17
 2ae:	79 09       	sbc	r23, r9
 2b0:	16 00       	.word	0x0016	; ????
 2b2:	01 03       	mulsu	r16, r17
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	01 09       	sbc	r16, r1
                cli();
 2b6:	04 00       	.word	0x0004	; ????
		*reg |= bit;
 2b8:	01 09       	sbc	r16, r1
 2ba:	08 00       	.word	0x0008	; ????
 2bc:	00 01       	movw	r0, r0
		SREG = oldSREG;
 2be:	01 04       	cpc	r0, r1
 2c0:	03 00       	.word	0x0003	; ????
 2c2:	05 02       	muls	r16, r21
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	04 02       	muls	r16, r20
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	00 00       	nop
 2c8:	03 21       	and	r16, r3
 2ca:	01 04       	cpc	r0, r1
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	02 03       	mulsu	r16, r18
 2ce:	d3 01       	movw	r26, r6
 2d0:	09 00       	.word	0x0009	; ????
  
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2d2:	00 01       	movw	r0, r0
 2d4:	03 06       	cpc	r0, r19
 2d6:	09 02       	muls	r16, r25
 2d8:	00 01       	movw	r0, r0
 2da:	03 01       	movw	r0, r6
 2dc:	09 06       	cpc	r0, r25
 2de:	00 01       	movw	r0, r0
 2e0:	03 0d       	add	r16, r3
 2e2:	09 06       	cpc	r0, r25
 2e4:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2e6:	03 01       	movw	r0, r6
 2e8:	09 06       	cpc	r0, r25
 2ea:	00 01       	movw	r0, r0
 2ec:	03 0d       	add	r16, r3
 2ee:	09 06       	cpc	r0, r25
 2f0:	00 01       	movw	r0, r0
 2f2:	03 0b       	sbc	r16, r19
 2f4:	09 0a       	sbc	r0, r25
 2f6:	00 01       	movw	r0, r0
 2f8:	03 03       	mulsu	r16, r19
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2fa:	09 04       	cpc	r0, r9
 2fc:	00 01       	movw	r0, r0
 2fe:	03 02       	muls	r16, r19
 300:	09 0a       	sbc	r0, r25
 302:	00 01       	movw	r0, r0
 304:	03 0a       	sbc	r0, r19
 306:	09 0a       	sbc	r0, r25
 308:	00 01       	movw	r0, r0
 30a:	03 07       	cpc	r16, r19
 30c:	09 0a       	sbc	r0, r25
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 30e:	00 01       	movw	r0, r0
 310:	03 09       	sbc	r16, r3
 312:	09 0a       	sbc	r0, r25
 314:	00 01       	movw	r0, r0
 316:	03 23       	and	r16, r19
 318:	09 0a       	sbc	r0, r25
 31a:	00 01       	movw	r0, r0
 31c:	03 01       	movw	r0, r6
 31e:	09 0a       	sbc	r0, r25
 320:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 322:	03 01       	movw	r0, r6
 324:	09 0a       	sbc	r0, r25
 326:	00 01       	movw	r0, r0
 328:	03 17       	cp	r16, r19
 32a:	09 0a       	sbc	r0, r25
 32c:	00 01       	movw	r0, r0
 32e:	03 09       	sbc	r16, r3
 330:	09 0a       	sbc	r0, r25
 332:	00 01       	movw	r0, r0
 334:	04 01       	movw	r0, r8
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 336:	03 99       	sbic	0x00, 3	; 0
 338:	7d 09       	sbc	r23, r13
 33a:	04 00       	.word	0x0004	; ????
 33c:	01 03       	mulsu	r16, r17
 33e:	01 09       	sbc	r16, r1
 340:	06 00       	.word	0x0006	; ????
 342:	01 03       	mulsu	r16, r17
 344:	03 09       	sbc	r16, r3
 346:	06 00       	.word	0x0006	; ????
 348:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 34a:	03 09       	sbc	r16, r3
 34c:	04 00       	.word	0x0004	; ????
 34e:	01 03       	mulsu	r16, r17
 350:	01 09       	sbc	r16, r1
 352:	10 00       	.word	0x0010	; ????
 354:	01 03       	mulsu	r16, r17
 356:	0f 09       	sbc	r16, r15
 358:	0a 00       	.word	0x000a	; ????
 35a:	01 03       	mulsu	r16, r17
 35c:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 35e:	02 00       	.word	0x0002	; ????
 360:	01 03       	mulsu	r16, r17
 362:	01 09       	sbc	r16, r1
 364:	02 00       	.word	0x0002	; ????
 366:	01 03       	mulsu	r16, r17
 368:	01 09       	sbc	r16, r1
 36a:	06 00       	.word	0x0006	; ????
 36c:	01 04       	cpc	r0, r1
 36e:	03 03       	mulsu	r16, r19
 370:	76 09       	sbc	r23, r6
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 372:	02 00       	.word	0x0002	; ????
 374:	01 04       	cpc	r0, r1
 376:	04 03       	mulsu	r16, r20
 378:	61 09       	sbc	r22, r1
 37a:	04 00       	.word	0x0004	; ????
 37c:	01 03       	mulsu	r16, r17
 37e:	01 09       	sbc	r16, r1
 380:	02 00       	.word	0x0002	; ????
 382:	01 03       	mulsu	r16, r17
 384:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 386:	06 00       	.word	0x0006	; ????
 388:	01 03       	mulsu	r16, r17
 38a:	02 09       	sbc	r16, r2
 38c:	06 00       	.word	0x0006	; ????
 38e:	01 03       	mulsu	r16, r17
 390:	01 09       	sbc	r16, r1
 392:	14 00       	.word	0x0014	; ????
 394:	01 03       	mulsu	r16, r17
 396:	01 09       	sbc	r16, r1
 398:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 39a:	01 03       	mulsu	r16, r17
 39c:	01 09       	sbc	r16, r1
 39e:	14 00       	.word	0x0014	; ????
 3a0:	01 03       	mulsu	r16, r17
 3a2:	01 09       	sbc	r16, r1
 3a4:	14 00       	.word	0x0014	; ????
 3a6:	01 03       	mulsu	r16, r17
 3a8:	01 09       	sbc	r16, r1
 3aa:	14 00       	.word	0x0014	; ????
 3ac:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ae:	01 09       	sbc	r16, r1
 3b0:	14 00       	.word	0x0014	; ????
 3b2:	01 03       	mulsu	r16, r17
 3b4:	01 09       	sbc	r16, r1
 3b6:	14 00       	.word	0x0014	; ????
 3b8:	01 03       	mulsu	r16, r17
 3ba:	01 09       	sbc	r16, r1
 3bc:	14 00       	.word	0x0014	; ????
 3be:	01 03       	mulsu	r16, r17
 3c0:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3c2:	14 00       	.word	0x0014	; ????
 3c4:	01 03       	mulsu	r16, r17
 3c6:	01 09       	sbc	r16, r1
 3c8:	14 00       	.word	0x0014	; ????
 3ca:	01 03       	mulsu	r16, r17
 3cc:	01 09       	sbc	r16, r1
 3ce:	14 00       	.word	0x0014	; ????
 3d0:	01 03       	mulsu	r16, r17
 3d2:	01 09       	sbc	r16, r1
 3d4:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3d6:	01 03       	mulsu	r16, r17
 3d8:	01 09       	sbc	r16, r1
 3da:	14 00       	.word	0x0014	; ????
 3dc:	01 03       	mulsu	r16, r17
 3de:	01 09       	sbc	r16, r1
 3e0:	14 00       	.word	0x0014	; ????
 3e2:	01 03       	mulsu	r16, r17
 3e4:	01 09       	sbc	r16, r1
 3e6:	14 00       	.word	0x0014	; ????
 3e8:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ea:	01 09       	sbc	r16, r1
 3ec:	14 00       	.word	0x0014	; ????
 3ee:	01 03       	mulsu	r16, r17
 3f0:	01 09       	sbc	r16, r1
 3f2:	14 00       	.word	0x0014	; ????
 3f4:	01 03       	mulsu	r16, r17
 3f6:	01 09       	sbc	r16, r1
 3f8:	14 00       	.word	0x0014	; ????
 3fa:	01 03       	mulsu	r16, r17
 3fc:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3fe:	14 00       	.word	0x0014	; ????
 400:	01 03       	mulsu	r16, r17
 402:	01 09       	sbc	r16, r1
 404:	14 00       	.word	0x0014	; ????
 406:	01 03       	mulsu	r16, r17
 408:	01 09       	sbc	r16, r1
 40a:	14 00       	.word	0x0014	; ????
 40c:	01 03       	mulsu	r16, r17
 40e:	01 09       	sbc	r16, r1
 410:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 412:	01 03       	mulsu	r16, r17
 414:	01 09       	sbc	r16, r1
 416:	14 00       	.word	0x0014	; ????
 418:	01 03       	mulsu	r16, r17
 41a:	01 09       	sbc	r16, r1
 41c:	14 00       	.word	0x0014	; ????
 41e:	01 03       	mulsu	r16, r17
 420:	01 09       	sbc	r16, r1
 422:	14 00       	.word	0x0014	; ????
 424:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 426:	01 09       	sbc	r16, r1
 428:	14 00       	.word	0x0014	; ????
 42a:	01 03       	mulsu	r16, r17
 42c:	01 09       	sbc	r16, r1
 42e:	14 00       	.word	0x0014	; ????
 430:	01 03       	mulsu	r16, r17
 432:	01 09       	sbc	r16, r1
 434:	14 00       	.word	0x0014	; ????
 436:	01 03       	mulsu	r16, r17
 438:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 43a:	14 00       	.word	0x0014	; ????
 43c:	01 03       	mulsu	r16, r17
 43e:	01 09       	sbc	r16, r1
 440:	14 00       	.word	0x0014	; ????
 442:	01 03       	mulsu	r16, r17
 444:	01 09       	sbc	r16, r1
 446:	14 00       	.word	0x0014	; ????
 448:	01 03       	mulsu	r16, r17
 44a:	01 09       	sbc	r16, r1
 44c:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 44e:	01 03       	mulsu	r16, r17
 450:	01 09       	sbc	r16, r1
 452:	14 00       	.word	0x0014	; ????
 454:	01 03       	mulsu	r16, r17
 456:	01 09       	sbc	r16, r1
 458:	14 00       	.word	0x0014	; ????
 45a:	01 03       	mulsu	r16, r17
 45c:	01 09       	sbc	r16, r1
 45e:	14 00       	.word	0x0014	; ????
 460:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 462:	01 09       	sbc	r16, r1
 464:	14 00       	.word	0x0014	; ????
 466:	01 03       	mulsu	r16, r17
 468:	01 09       	sbc	r16, r1
 46a:	14 00       	.word	0x0014	; ????
 46c:	01 03       	mulsu	r16, r17
 46e:	01 09       	sbc	r16, r1
 470:	14 00       	.word	0x0014	; ????
 472:	01 03       	mulsu	r16, r17
 474:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 476:	14 00       	.word	0x0014	; ????
 478:	01 03       	mulsu	r16, r17
 47a:	01 09       	sbc	r16, r1
 47c:	14 00       	.word	0x0014	; ????
 47e:	01 03       	mulsu	r16, r17
 480:	01 09       	sbc	r16, r1
 482:	14 00       	.word	0x0014	; ????
 484:	01 03       	mulsu	r16, r17
 486:	01 09       	sbc	r16, r1
 488:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 48a:	01 03       	mulsu	r16, r17
 48c:	01 09       	sbc	r16, r1
 48e:	14 00       	.word	0x0014	; ????
 490:	01 03       	mulsu	r16, r17
 492:	01 09       	sbc	r16, r1
 494:	14 00       	.word	0x0014	; ????
 496:	01 03       	mulsu	r16, r17
 498:	01 09       	sbc	r16, r1
 49a:	14 00       	.word	0x0014	; ????
 49c:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 49e:	01 09       	sbc	r16, r1
 4a0:	14 00       	.word	0x0014	; ????
 4a2:	01 03       	mulsu	r16, r17
 4a4:	01 09       	sbc	r16, r1
 4a6:	14 00       	.word	0x0014	; ????
 4a8:	01 03       	mulsu	r16, r17
 4aa:	01 09       	sbc	r16, r1
 4ac:	14 00       	.word	0x0014	; ????
 4ae:	01 03       	mulsu	r16, r17
 4b0:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4b2:	14 00       	.word	0x0014	; ????
 4b4:	01 03       	mulsu	r16, r17
 4b6:	01 09       	sbc	r16, r1
 4b8:	14 00       	.word	0x0014	; ????
 4ba:	01 03       	mulsu	r16, r17
 4bc:	01 09       	sbc	r16, r1
 4be:	14 00       	.word	0x0014	; ????
 4c0:	01 03       	mulsu	r16, r17
 4c2:	01 09       	sbc	r16, r1
 4c4:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4c6:	01 03       	mulsu	r16, r17
 4c8:	01 09       	sbc	r16, r1
 4ca:	14 00       	.word	0x0014	; ????
 4cc:	01 03       	mulsu	r16, r17
 4ce:	01 09       	sbc	r16, r1
 4d0:	14 00       	.word	0x0014	; ????
 4d2:	01 03       	mulsu	r16, r17
 4d4:	01 09       	sbc	r16, r1
 4d6:	14 00       	.word	0x0014	; ????
 4d8:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4da:	01 09       	sbc	r16, r1
 4dc:	14 00       	.word	0x0014	; ????
 4de:	01 03       	mulsu	r16, r17
 4e0:	01 09       	sbc	r16, r1
 4e2:	14 00       	.word	0x0014	; ????
 4e4:	01 03       	mulsu	r16, r17
 4e6:	01 09       	sbc	r16, r1
 4e8:	14 00       	.word	0x0014	; ????
 4ea:	01 03       	mulsu	r16, r17
 4ec:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4ee:	14 00       	.word	0x0014	; ????
 4f0:	01 03       	mulsu	r16, r17
 4f2:	01 09       	sbc	r16, r1
 4f4:	14 00       	.word	0x0014	; ????
 4f6:	01 03       	mulsu	r16, r17
 4f8:	01 09       	sbc	r16, r1
 4fa:	14 00       	.word	0x0014	; ????
 4fc:	01 03       	mulsu	r16, r17
 4fe:	01 09       	sbc	r16, r1
 500:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 502:	01 03       	mulsu	r16, r17
 504:	01 09       	sbc	r16, r1
 506:	14 00       	.word	0x0014	; ????
 508:	01 03       	mulsu	r16, r17
 50a:	01 09       	sbc	r16, r1
 50c:	14 00       	.word	0x0014	; ????
 50e:	01 03       	mulsu	r16, r17
 510:	01 09       	sbc	r16, r1
 512:	14 00       	.word	0x0014	; ????
 514:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 516:	01 09       	sbc	r16, r1
 518:	14 00       	.word	0x0014	; ????
 51a:	01 03       	mulsu	r16, r17
 51c:	01 09       	sbc	r16, r1
 51e:	14 00       	.word	0x0014	; ????
 520:	01 03       	mulsu	r16, r17
 522:	01 09       	sbc	r16, r1
 524:	14 00       	.word	0x0014	; ????
 526:	01 03       	mulsu	r16, r17
 528:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 52a:	14 00       	.word	0x0014	; ????
 52c:	01 03       	mulsu	r16, r17
 52e:	01 09       	sbc	r16, r1
 530:	14 00       	.word	0x0014	; ????
 532:	01 03       	mulsu	r16, r17
 534:	01 09       	sbc	r16, r1
 536:	14 00       	.word	0x0014	; ????
 538:	01 03       	mulsu	r16, r17
 53a:	01 09       	sbc	r16, r1
 53c:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 53e:	01 03       	mulsu	r16, r17
 540:	01 09       	sbc	r16, r1
 542:	14 00       	.word	0x0014	; ????
 544:	01 03       	mulsu	r16, r17
 546:	01 09       	sbc	r16, r1
 548:	14 00       	.word	0x0014	; ????
 54a:	01 03       	mulsu	r16, r17
 54c:	01 09       	sbc	r16, r1
 54e:	14 00       	.word	0x0014	; ????
 550:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 552:	01 09       	sbc	r16, r1
 554:	14 00       	.word	0x0014	; ????
 556:	01 03       	mulsu	r16, r17
 558:	01 09       	sbc	r16, r1
 55a:	14 00       	.word	0x0014	; ????
 55c:	01 03       	mulsu	r16, r17
 55e:	01 09       	sbc	r16, r1
 560:	14 00       	.word	0x0014	; ????
 562:	01 03       	mulsu	r16, r17
 564:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 566:	14 00       	.word	0x0014	; ????
 568:	01 03       	mulsu	r16, r17
 56a:	01 09       	sbc	r16, r1
 56c:	14 00       	.word	0x0014	; ????
 56e:	01 03       	mulsu	r16, r17
 570:	01 09       	sbc	r16, r1
 572:	14 00       	.word	0x0014	; ????
 574:	01 03       	mulsu	r16, r17
 576:	01 09       	sbc	r16, r1
 578:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 57a:	01 03       	mulsu	r16, r17
 57c:	01 09       	sbc	r16, r1
 57e:	14 00       	.word	0x0014	; ????
 580:	01 03       	mulsu	r16, r17
 582:	01 09       	sbc	r16, r1
 584:	14 00       	.word	0x0014	; ????
 586:	01 03       	mulsu	r16, r17
 588:	01 09       	sbc	r16, r1
 58a:	14 00       	.word	0x0014	; ????
 58c:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 58e:	01 09       	sbc	r16, r1
 590:	14 00       	.word	0x0014	; ????
 592:	01 03       	mulsu	r16, r17
 594:	01 09       	sbc	r16, r1
 596:	14 00       	.word	0x0014	; ????
 598:	01 03       	mulsu	r16, r17
 59a:	01 09       	sbc	r16, r1
 59c:	14 00       	.word	0x0014	; ????
 59e:	01 03       	mulsu	r16, r17
 5a0:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5a2:	14 00       	.word	0x0014	; ????
 5a4:	01 03       	mulsu	r16, r17
 5a6:	01 09       	sbc	r16, r1
 5a8:	14 00       	.word	0x0014	; ????
 5aa:	01 03       	mulsu	r16, r17
 5ac:	01 09       	sbc	r16, r1
 5ae:	14 00       	.word	0x0014	; ????
 5b0:	01 03       	mulsu	r16, r17
 5b2:	01 09       	sbc	r16, r1
 5b4:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5b6:	01 03       	mulsu	r16, r17
 5b8:	01 09       	sbc	r16, r1
 5ba:	14 00       	.word	0x0014	; ????
 5bc:	01 03       	mulsu	r16, r17
 5be:	01 09       	sbc	r16, r1
 5c0:	14 00       	.word	0x0014	; ????
 5c2:	01 03       	mulsu	r16, r17
 5c4:	01 09       	sbc	r16, r1
 5c6:	14 00       	.word	0x0014	; ????
 5c8:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5ca:	01 09       	sbc	r16, r1
 5cc:	14 00       	.word	0x0014	; ????
 5ce:	01 03       	mulsu	r16, r17
 5d0:	01 09       	sbc	r16, r1
 5d2:	14 00       	.word	0x0014	; ????
 5d4:	01 03       	mulsu	r16, r17
 5d6:	01 09       	sbc	r16, r1
 5d8:	14 00       	.word	0x0014	; ????
 5da:	01 03       	mulsu	r16, r17
 5dc:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5de:	14 00       	.word	0x0014	; ????
 5e0:	01 03       	mulsu	r16, r17
 5e2:	01 09       	sbc	r16, r1
 5e4:	14 00       	.word	0x0014	; ????
 5e6:	01 03       	mulsu	r16, r17
 5e8:	01 09       	sbc	r16, r1
 5ea:	14 00       	.word	0x0014	; ????
 5ec:	01 03       	mulsu	r16, r17
 5ee:	01 09       	sbc	r16, r1
 5f0:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 5f2:	01 03       	mulsu	r16, r17
 5f4:	01 09       	sbc	r16, r1
 5f6:	14 00       	.word	0x0014	; ????
 5f8:	01 03       	mulsu	r16, r17
 5fa:	01 09       	sbc	r16, r1
 5fc:	14 00       	.word	0x0014	; ????
 5fe:	01 03       	mulsu	r16, r17
 600:	01 09       	sbc	r16, r1
 602:	14 00       	.word	0x0014	; ????
 604:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 606:	01 09       	sbc	r16, r1
 608:	14 00       	.word	0x0014	; ????
 60a:	01 03       	mulsu	r16, r17
 60c:	01 09       	sbc	r16, r1
 60e:	14 00       	.word	0x0014	; ????
 610:	01 03       	mulsu	r16, r17
 612:	01 09       	sbc	r16, r1
 614:	14 00       	.word	0x0014	; ????
 616:	01 03       	mulsu	r16, r17
 618:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 61a:	14 00       	.word	0x0014	; ????
 61c:	01 03       	mulsu	r16, r17
 61e:	01 09       	sbc	r16, r1
 620:	14 00       	.word	0x0014	; ????
 622:	01 03       	mulsu	r16, r17
 624:	01 09       	sbc	r16, r1
 626:	14 00       	.word	0x0014	; ????
 628:	01 03       	mulsu	r16, r17
 62a:	01 09       	sbc	r16, r1
 62c:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 62e:	01 03       	mulsu	r16, r17
 630:	01 09       	sbc	r16, r1
 632:	14 00       	.word	0x0014	; ????
 634:	01 03       	mulsu	r16, r17
 636:	01 09       	sbc	r16, r1
 638:	14 00       	.word	0x0014	; ????
 63a:	01 03       	mulsu	r16, r17
 63c:	01 09       	sbc	r16, r1
 63e:	14 00       	.word	0x0014	; ????
 640:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 642:	01 09       	sbc	r16, r1
 644:	14 00       	.word	0x0014	; ????
 646:	01 03       	mulsu	r16, r17
 648:	01 09       	sbc	r16, r1
 64a:	14 00       	.word	0x0014	; ????
 64c:	01 03       	mulsu	r16, r17
 64e:	01 09       	sbc	r16, r1
 650:	14 00       	.word	0x0014	; ????
 652:	01 03       	mulsu	r16, r17
 654:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 656:	14 00       	.word	0x0014	; ????
 658:	01 03       	mulsu	r16, r17
 65a:	01 09       	sbc	r16, r1
 65c:	14 00       	.word	0x0014	; ????
 65e:	01 03       	mulsu	r16, r17
 660:	01 09       	sbc	r16, r1
 662:	14 00       	.word	0x0014	; ????
 664:	01 03       	mulsu	r16, r17
 666:	01 09       	sbc	r16, r1
 668:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 66a:	01 03       	mulsu	r16, r17
 66c:	01 09       	sbc	r16, r1
 66e:	14 00       	.word	0x0014	; ????
 670:	01 03       	mulsu	r16, r17
 672:	01 09       	sbc	r16, r1
 674:	14 00       	.word	0x0014	; ????
 676:	01 03       	mulsu	r16, r17
 678:	01 09       	sbc	r16, r1
 67a:	14 00       	.word	0x0014	; ????
 67c:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 67e:	01 09       	sbc	r16, r1
 680:	14 00       	.word	0x0014	; ????
 682:	01 03       	mulsu	r16, r17
 684:	01 09       	sbc	r16, r1
 686:	14 00       	.word	0x0014	; ????
 688:	01 03       	mulsu	r16, r17
 68a:	01 09       	sbc	r16, r1
 68c:	14 00       	.word	0x0014	; ????
 68e:	01 03       	mulsu	r16, r17
 690:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 692:	14 00       	.word	0x0014	; ????
 694:	01 03       	mulsu	r16, r17
 696:	01 09       	sbc	r16, r1
 698:	14 00       	.word	0x0014	; ????
 69a:	01 03       	mulsu	r16, r17
 69c:	01 09       	sbc	r16, r1
 69e:	14 00       	.word	0x0014	; ????
 6a0:	01 03       	mulsu	r16, r17
 6a2:	01 09       	sbc	r16, r1
 6a4:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6a6:	01 03       	mulsu	r16, r17
 6a8:	01 09       	sbc	r16, r1
 6aa:	14 00       	.word	0x0014	; ????
 6ac:	01 03       	mulsu	r16, r17
 6ae:	01 09       	sbc	r16, r1
 6b0:	14 00       	.word	0x0014	; ????
 6b2:	01 03       	mulsu	r16, r17
 6b4:	01 09       	sbc	r16, r1
 6b6:	14 00       	.word	0x0014	; ????
 6b8:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ba:	01 09       	sbc	r16, r1
 6bc:	14 00       	.word	0x0014	; ????
 6be:	01 03       	mulsu	r16, r17
 6c0:	01 09       	sbc	r16, r1
 6c2:	14 00       	.word	0x0014	; ????
 6c4:	01 03       	mulsu	r16, r17
 6c6:	01 09       	sbc	r16, r1
 6c8:	14 00       	.word	0x0014	; ????
 6ca:	01 03       	mulsu	r16, r17
 6cc:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6ce:	14 00       	.word	0x0014	; ????
 6d0:	01 03       	mulsu	r16, r17
 6d2:	01 09       	sbc	r16, r1
 6d4:	14 00       	.word	0x0014	; ????
 6d6:	01 03       	mulsu	r16, r17
 6d8:	01 09       	sbc	r16, r1
 6da:	14 00       	.word	0x0014	; ????
 6dc:	01 03       	mulsu	r16, r17
 6de:	01 09       	sbc	r16, r1
 6e0:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6e2:	01 03       	mulsu	r16, r17
 6e4:	01 09       	sbc	r16, r1
 6e6:	14 00       	.word	0x0014	; ????
 6e8:	01 03       	mulsu	r16, r17
 6ea:	01 09       	sbc	r16, r1
 6ec:	14 00       	.word	0x0014	; ????
 6ee:	01 03       	mulsu	r16, r17
 6f0:	01 09       	sbc	r16, r1
 6f2:	14 00       	.word	0x0014	; ????
 6f4:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 6f6:	01 09       	sbc	r16, r1
 6f8:	14 00       	.word	0x0014	; ????
 6fa:	01 03       	mulsu	r16, r17
 6fc:	01 09       	sbc	r16, r1
 6fe:	14 00       	.word	0x0014	; ????
 700:	01 03       	mulsu	r16, r17
 702:	01 09       	sbc	r16, r1
 704:	14 00       	.word	0x0014	; ????
 706:	01 03       	mulsu	r16, r17
 708:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 70a:	14 00       	.word	0x0014	; ????
 70c:	01 03       	mulsu	r16, r17
 70e:	01 09       	sbc	r16, r1
 710:	14 00       	.word	0x0014	; ????
 712:	01 03       	mulsu	r16, r17
 714:	01 09       	sbc	r16, r1
 716:	14 00       	.word	0x0014	; ????
 718:	01 03       	mulsu	r16, r17
 71a:	01 09       	sbc	r16, r1
 71c:	14 00       	.word	0x0014	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 71e:	01 03       	mulsu	r16, r17
 720:	01 09       	sbc	r16, r1
 722:	14 00       	.word	0x0014	; ????
 724:	01 03       	mulsu	r16, r17
 726:	01 09       	sbc	r16, r1
 728:	14 00       	.word	0x0014	; ????
 72a:	01 03       	mulsu	r16, r17
 72c:	01 09       	sbc	r16, r1
 72e:	14 00       	.word	0x0014	; ????
 730:	01 03       	mulsu	r16, r17
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 732:	01 09       	sbc	r16, r1
 734:	14 00       	.word	0x0014	; ????
 736:	01 03       	mulsu	r16, r17
 738:	01 09       	sbc	r16, r1
 73a:	14 00       	.word	0x0014	; ????
 73c:	01 03       	mulsu	r16, r17
 73e:	01 09       	sbc	r16, r1
 740:	14 00       	.word	0x0014	; ????
 742:	01 03       	mulsu	r16, r17
 744:	01 09       	sbc	r16, r1
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 746:	14 00       	.word	0x0014	; ????
 748:	01 03       	mulsu	r16, r17
 74a:	02 09       	sbc	r16, r2
 74c:	14 00       	.word	0x0014	; ????
 74e:	01 04       	cpc	r0, r1
 750:	03 03       	mulsu	r16, r19
 752:	fa 7e       	andi	r31, 0xEA	; 234
 754:	09 02       	muls	r16, r25
 756:	00 01       	movw	r0, r0
 758:	09 10       	cpse	r0, r9
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 75a:	00 00       	nop
 75c:	01 01       	movw	r0, r2
 75e:	5e 00       	.word	0x005e	; ????
 760:	00 00       	nop
 762:	02 00       	.word	0x0002	; ????
 764:	41 00       	.word	0x0041	; ????
 766:	00 00       	nop
 768:	02 01       	movw	r0, r4
 76a:	fb 0e       	add	r15, r27
 76c:	0a 00       	.word	0x000a	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 76e:	01 01       	movw	r0, r2
 770:	01 01       	movw	r0, r2
 772:	00 00       	nop
 774:	00 01       	movw	r0, r0
 776:	2e 2e       	mov	r2, r30
 778:	2f 2e       	mov	r2, r31
 77a:	2e 2f       	mov	r18, r30
 77c:	2e 2e       	mov	r2, r30
 77e:	2f 2e       	mov	r2, r31
 780:	2e 2f       	mov	r18, r30
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 782:	67 63       	ori	r22, 0x37	; 55
 784:	63 2f       	mov	r22, r19
 786:	6c 69       	ori	r22, 0x9C	; 156
 788:	62 67       	ori	r22, 0x72	; 114
 78a:	63 63       	ori	r22, 0x33	; 51
 78c:	2f 63       	ori	r18, 0x3F	; 63
 78e:	6f 6e       	ori	r22, 0xEF	; 239
 790:	66 69       	ori	r22, 0x96	; 150
 792:	67 2f       	mov	r22, r23
 794:	61 76       	andi	r22, 0x61	; 97
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 796:	72 00       	.word	0x0072	; ????
 798:	00 6c       	ori	r16, 0xC0	; 192
 79a:	69 62       	ori	r22, 0x29	; 41
 79c:	31 66       	ori	r19, 0x61	; 97
 79e:	75 6e       	ori	r23, 0xE5	; 229
 7a0:	63 73       	andi	r22, 0x33	; 51
 7a2:	2e 53       	subi	r18, 0x3E	; 62
 7a4:	00 01       	movw	r0, r0
 7a6:	00 00       	nop
 7a8:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7aa:	05 02       	muls	r16, r21
 7ac:	64 0f       	add	r22, r20
 7ae:	00 00       	nop
 7b0:	03 e5       	ldi	r16, 0x53	; 83
 7b2:	11 01       	movw	r2, r2
 7b4:	03 02       	muls	r16, r19
 7b6:	09 02       	muls	r16, r25
 7b8:	00 01       	movw	r0, r0
 7ba:	09 02       	muls	r16, r25
 7bc:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7be:	01 01       	movw	r0, r2
 7c0:	82 00       	.word	0x0082	; ????
 7c2:	00 00       	nop
 7c4:	02 00       	.word	0x0002	; ????
 7c6:	41 00       	.word	0x0041	; ????
 7c8:	00 00       	nop
 7ca:	02 01       	movw	r0, r4
 7cc:	fb 0e       	add	r15, r27
 7ce:	0a 00       	.word	0x000a	; ????
 7d0:	01 01       	movw	r0, r2
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7d2:	01 01       	movw	r0, r2
 7d4:	00 00       	nop
 7d6:	00 01       	movw	r0, r0
 7d8:	2e 2e       	mov	r2, r30
 7da:	2f 2e       	mov	r2, r31
 7dc:	2e 2f       	mov	r18, r30
 7de:	2e 2e       	mov	r2, r30
 7e0:	2f 2e       	mov	r2, r31
 7e2:	2e 2f       	mov	r18, r30
 7e4:	67 63       	ori	r22, 0x37	; 55
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7e6:	63 2f       	mov	r22, r19
 7e8:	6c 69       	ori	r22, 0x9C	; 156
 7ea:	62 67       	ori	r22, 0x72	; 114
 7ec:	63 63       	ori	r22, 0x33	; 51
 7ee:	2f 63       	ori	r18, 0x3F	; 63
 7f0:	6f 6e       	ori	r22, 0xEF	; 239
 7f2:	66 69       	ori	r22, 0x96	; 150
 7f4:	67 2f       	mov	r22, r23
 7f6:	61 76       	andi	r22, 0x61	; 97
 7f8:	72 00       	.word	0x0072	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 7fa:	00 6c       	ori	r16, 0xC0	; 192
 7fc:	69 62       	ori	r22, 0x29	; 41
 7fe:	31 66       	ori	r19, 0x61	; 97
 800:	75 6e       	ori	r23, 0xE5	; 229
 802:	63 73       	andi	r22, 0x33	; 51
 804:	2e 53       	subi	r18, 0x3E	; 62
 806:	00 01       	movw	r0, r0
 808:	00 00       	nop
 80a:	00 00       	nop
 80c:	05 02       	muls	r16, r21
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 80e:	c4 00       	.word	0x00c4	; ????
 810:	00 00       	nop
 812:	03 88       	ldd	r0, Z+19	; 0x13
 814:	13 01       	movw	r2, r6
 816:	03 01       	movw	r0, r6
 818:	09 02       	muls	r16, r25
 81a:	00 01       	movw	r0, r0
 81c:	03 01       	movw	r0, r6
 81e:	09 02       	muls	r16, r25
 820:	00 01       	movw	r0, r0
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 822:	03 01       	movw	r0, r6
 824:	09 02       	muls	r16, r25
 826:	00 01       	movw	r0, r0
 828:	03 02       	muls	r16, r19
 82a:	09 02       	muls	r16, r25
 82c:	00 01       	movw	r0, r0
 82e:	03 02       	muls	r16, r19
 830:	09 02       	muls	r16, r25
 832:	00 01       	movw	r0, r0
 834:	03 01       	movw	r0, r6
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 836:	09 02       	muls	r16, r25
 838:	00 01       	movw	r0, r0
 83a:	03 01       	movw	r0, r6
 83c:	09 02       	muls	r16, r25
 83e:	00 01       	movw	r0, r0
 840:	09 02       	muls	r16, r25
 842:	00 00       	nop
 844:	01 01       	movw	r0, r2

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	10 00       	.word	0x0010	; ????
   2:	00 00       	nop
   4:	ff ff       	.word	0xffff	; ????
   6:	ff ff       	.word	0xffff	; ????
   8:	01 00       	.word	0x0001	; ????
   a:	02 7f       	andi	r16, 0xF2	; 242
   c:	24 0c       	add	r2, r4
   e:	20 02       	muls	r18, r16
  10:	a4 01       	movw	r20, r8
  12:	00 00       	nop
  14:	0c 00       	.word	0x000c	; ????
  16:	00 00       	nop
  18:	00 00       	nop
  1a:	00 00       	nop
  1c:	e0 00       	.word	0x00e0	; ????
  1e:	00 00       	nop
  20:	90 00       	.word	0x0090	; ????
  22:	00 00       	nop
  24:	34 00       	.word	0x0034	; ????
  26:	00 00       	nop
  28:	00 00       	nop
  2a:	00 00       	nop
  2c:	70 01       	movw	r14, r0
  2e:	00 00       	nop
  30:	94 00       	.word	0x0094	; ????
  32:	00 00       	nop
  34:	41 0e       	add	r4, r17
  36:	03 81       	ldd	r16, Z+3	; 0x03
  38:	02 41       	sbci	r16, 0x12	; 18
  3a:	0e 04       	cpc	r0, r14
  3c:	80 03       	fmuls	r16, r16
  3e:	44 0e       	add	r4, r20
  40:	05 92       	las	Z, r0
  42:	04 41       	sbci	r16, 0x14	; 20
  44:	0e 06       	cpc	r0, r30
  46:	93 05       	cpc	r25, r3
  48:	41 0e       	add	r4, r17
  4a:	07 98       	cbi	0x00, 7	; 0
  4c:	06 41       	sbci	r16, 0x16	; 22
  4e:	0e 08       	sbc	r0, r14
  50:	99 07       	cpc	r25, r25
  52:	41 0e       	add	r4, r17
  54:	09 9a       	sbi	0x01, 1	; 1
  56:	08 41       	sbci	r16, 0x18	; 24
  58:	0e 0a       	sbc	r0, r30
  5a:	9b 09       	sbc	r25, r11
  5c:	0c 00       	.word	0x000c	; ????
  5e:	00 00       	nop
  60:	00 00       	nop
  62:	00 00       	nop
  64:	04 02       	muls	r16, r20
  66:	00 00       	nop
  68:	60 0d       	add	r22, r0
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	61 76       	andi	r22, 0x61	; 97
   2:	72 2d       	mov	r23, r2
   4:	6c 69       	ori	r22, 0x9C	; 156
   6:	62 63       	ori	r22, 0x32	; 50
   8:	20 32       	cpi	r18, 0x20	; 32
   a:	2e 30       	cpi	r18, 0x0E	; 14
   c:	2e 30       	cpi	r18, 0x0E	; 14
   e:	00 75       	andi	r16, 0x50	; 80
  10:	69 6e       	ori	r22, 0xE9	; 233
  12:	74 38       	cpi	r23, 0x84	; 132
  14:	5f 74       	andi	r21, 0x4F	; 79
  16:	00 75       	andi	r16, 0x50	; 80
  18:	69 6e       	ori	r22, 0xE9	; 233
  1a:	74 31       	cpi	r23, 0x14	; 20
  1c:	36 5f       	subi	r19, 0xF6	; 246
  1e:	74 00       	.word	0x0074	; ????
  20:	5f 5f       	subi	r21, 0xFF	; 255
  22:	65 65       	ori	r22, 0x55	; 85
  24:	70 72       	andi	r23, 0x20	; 32
  26:	6f 6d       	ori	r22, 0xDF	; 223
  28:	00 55       	subi	r16, 0x50	; 80
  2a:	44 52       	subi	r20, 0x24	; 36
  2c:	30 00       	.word	0x0030	; ????
  2e:	55 43       	sbci	r21, 0x35	; 53
  30:	53 52       	subi	r21, 0x23	; 35
  32:	30 41       	sbci	r19, 0x10	; 16
  34:	00 55       	subi	r16, 0x50	; 80
  36:	43 53       	subi	r20, 0x33	; 51
  38:	52 30       	cpi	r21, 0x02	; 2
  3a:	42 00       	.word	0x0042	; ????
  3c:	55 43       	sbci	r21, 0x35	; 53
  3e:	53 52       	subi	r21, 0x23	; 35
  40:	30 43       	sbci	r19, 0x30	; 48
  42:	00 55       	subi	r16, 0x50	; 80
  44:	42 52       	subi	r20, 0x22	; 34
  46:	52 30       	cpi	r21, 0x02	; 2
  48:	00 54       	subi	r16, 0x40	; 64
  4a:	57 41       	sbci	r21, 0x17	; 23
  4c:	4d 52       	subi	r20, 0x2D	; 45
  4e:	00 54       	subi	r16, 0x40	; 64
  50:	57 42       	sbci	r21, 0x27	; 39
  52:	52 00       	.word	0x0052	; ????
  54:	54 57       	subi	r21, 0x74	; 116
  56:	43 52       	subi	r20, 0x23	; 35
  58:	00 54       	subi	r16, 0x40	; 64
  5a:	57 53       	subi	r21, 0x37	; 55
  5c:	52 00       	.word	0x0052	; ????
  5e:	54 57       	subi	r21, 0x74	; 116
  60:	44 52       	subi	r20, 0x24	; 36
  62:	00 54       	subi	r16, 0x40	; 64
  64:	57 41       	sbci	r21, 0x17	; 23
  66:	52 00       	.word	0x0052	; ????
  68:	54 49       	sbci	r21, 0x94	; 148
  6a:	4d 53       	subi	r20, 0x3D	; 61
  6c:	4b 31       	cpi	r20, 0x1B	; 27
  6e:	00 54       	subi	r16, 0x40	; 64
  70:	49 46       	sbci	r20, 0x69	; 105
  72:	52 31       	cpi	r21, 0x12	; 18
  74:	00 54       	subi	r16, 0x40	; 64
  76:	43 43       	sbci	r20, 0x33	; 51
  78:	52 31       	cpi	r21, 0x12	; 18
  7a:	41 00       	.word	0x0041	; ????
  7c:	54 43       	sbci	r21, 0x34	; 52
  7e:	43 52       	subi	r20, 0x23	; 35
  80:	31 42       	sbci	r19, 0x21	; 33
  82:	00 54       	subi	r16, 0x40	; 64
  84:	43 43       	sbci	r20, 0x33	; 51
  86:	52 31       	cpi	r21, 0x12	; 18
  88:	43 00       	.word	0x0043	; ????
  8a:	54 43       	sbci	r21, 0x34	; 52
  8c:	4e 54       	subi	r20, 0x4E	; 78
  8e:	31 00       	.word	0x0031	; ????
  90:	4f 43       	sbci	r20, 0x3F	; 63
  92:	52 31       	cpi	r21, 0x12	; 18
  94:	41 00       	.word	0x0041	; ????
  96:	4f 43       	sbci	r20, 0x3F	; 63
  98:	52 31       	cpi	r21, 0x12	; 18
  9a:	42 00       	.word	0x0042	; ????
  9c:	49 43       	sbci	r20, 0x39	; 57
  9e:	52 31       	cpi	r21, 0x12	; 18
  a0:	00 47       	sbci	r16, 0x70	; 112
  a2:	54 43       	sbci	r21, 0x34	; 52
  a4:	43 52       	subi	r20, 0x23	; 35
  a6:	00 54       	subi	r16, 0x40	; 64
  a8:	49 4d       	sbci	r20, 0xD9	; 217
  aa:	53 4b       	sbci	r21, 0xB3	; 179
  ac:	32 00       	.word	0x0032	; ????
  ae:	54 49       	sbci	r21, 0x94	; 148
  b0:	46 52       	subi	r20, 0x26	; 38
  b2:	32 00       	.word	0x0032	; ????
  b4:	54 43       	sbci	r21, 0x34	; 52
  b6:	43 52       	subi	r20, 0x23	; 35
  b8:	32 41       	sbci	r19, 0x12	; 18
  ba:	00 54       	subi	r16, 0x40	; 64
  bc:	43 43       	sbci	r20, 0x33	; 51
  be:	52 32       	cpi	r21, 0x22	; 34
  c0:	42 00       	.word	0x0042	; ????
  c2:	54 43       	sbci	r21, 0x34	; 52
  c4:	4e 54       	subi	r20, 0x4E	; 78
  c6:	32 00       	.word	0x0032	; ????
  c8:	4f 43       	sbci	r20, 0x3F	; 63
  ca:	52 32       	cpi	r21, 0x22	; 34
  cc:	42 00       	.word	0x0042	; ????
  ce:	4f 43       	sbci	r20, 0x3F	; 63
  d0:	52 32       	cpi	r21, 0x22	; 34
  d2:	41 00       	.word	0x0041	; ????
  d4:	41 53       	subi	r20, 0x31	; 49
  d6:	53 52       	subi	r21, 0x23	; 35
  d8:	00 47       	sbci	r16, 0x70	; 112
  da:	54 43       	sbci	r21, 0x34	; 52
  dc:	43 52       	subi	r20, 0x23	; 35
  de:	00 41       	sbci	r16, 0x10	; 16
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	44 4d       	sbci	r20, 0xD4	; 212
  e2:	55 58       	subi	r21, 0x85	; 133
  e4:	00 41       	sbci	r16, 0x10	; 16
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	44 43       	sbci	r20, 0x34	; 52
  e8:	00 41       	sbci	r16, 0x10	; 16
  ea:	44 43       	sbci	r20, 0x34	; 52
	uint8_t port = digitalPinToPort(pin);
  ec:	53 52       	subi	r21, 0x23	; 35
  ee:	41 00       	.word	0x0041	; ????
  f0:	41 44       	sbci	r20, 0x41	; 65
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	43 53       	subi	r20, 0x33	; 51
  f4:	52 42       	sbci	r21, 0x22	; 34

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	00 44       	sbci	r16, 0x40	; 64
  f8:	49 44       	sbci	r20, 0x49	; 73
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	52 30       	cpi	r21, 0x02	; 2
  fc:	00 41       	sbci	r16, 0x10	; 16
  fe:	43 53       	subi	r20, 0x33	; 51
 100:	52 00       	.word	0x0052	; ????
 102:	44 49       	sbci	r20, 0x94	; 148
 104:	44 52       	subi	r20, 0x24	; 36
 106:	31 00       	.word	0x0031	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	50 4f       	sbci	r21, 0xF0	; 240
 10a:	52 54       	subi	r21, 0x42	; 66
 10c:	42 00       	.word	0x0042	; ????
 10e:	44 44       	sbci	r20, 0x44	; 68
 110:	52 42       	sbci	r21, 0x22	; 34
 112:	00 50       	subi	r16, 0x00	; 0
 114:	49 4e       	sbci	r20, 0xE9	; 233

	uint8_t oldSREG = SREG;
 116:	42 00       	.word	0x0042	; ????
	cli();
 118:	50 4f       	sbci	r21, 0xF0	; 240

	if (val == LOW) {
		*out &= ~bit;
 11a:	52 54       	subi	r21, 0x42	; 66
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	43 00       	.word	0x0043	; ????
 11e:	44 44       	sbci	r20, 0x44	; 68
		*out &= ~bit;
 120:	52 43       	sbci	r21, 0x32	; 50
 122:	00 50       	subi	r16, 0x00	; 0
	} else {
		*out |= bit;
 124:	49 4e       	sbci	r20, 0xE9	; 233
	}

	SREG = oldSREG;
 126:	43 00       	.word	0x0043	; ????
}
 128:	50 4f       	sbci	r21, 0xF0	; 240
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	52 54       	subi	r21, 0x42	; 66
 12c:	44 00       	.word	0x0044	; ????
 12e:	44 44       	sbci	r20, 0x44	; 68
 130:	52 44       	sbci	r21, 0x42	; 66
 132:	00 50       	subi	r16, 0x00	; 0
 134:	49 4e       	sbci	r20, 0xE9	; 233
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	44 00       	.word	0x0044	; ????
 138:	4f 43       	sbci	r20, 0x3F	; 63
 13a:	52 30       	cpi	r21, 0x02	; 2
 13c:	42 00       	.word	0x0042	; ????
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	4f 43       	sbci	r20, 0x3F	; 63
 140:	52 30       	cpi	r21, 0x02	; 2
 142:	41 00       	.word	0x0041	; ????
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	54 43       	sbci	r21, 0x34	; 52
 146:	4e 54       	subi	r20, 0x4E	; 78
 148:	30 00       	.word	0x0030	; ????
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	54 43       	sbci	r21, 0x34	; 52
 14c:	43 52       	subi	r20, 0x23	; 35
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	30 42       	sbci	r19, 0x20	; 32
 150:	00 54       	subi	r16, 0x40	; 64
 152:	43 43       	sbci	r20, 0x33	; 51
 154:	52 30       	cpi	r21, 0x02	; 2
 156:	41 00       	.word	0x0041	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	54 49       	sbci	r21, 0x94	; 148
 15a:	4d 53       	subi	r20, 0x3D	; 61
 15c:	4b 30       	cpi	r20, 0x0B	; 11
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	00 54       	subi	r16, 0x40	; 64
 160:	49 46       	sbci	r20, 0x69	; 105
 162:	52 30       	cpi	r21, 0x02	; 2
 164:	00 47       	sbci	r16, 0x70	; 112
 166:	54 43       	sbci	r21, 0x34	; 52
 168:	43 52       	subi	r20, 0x23	; 35
 16a:	00 45       	sbci	r16, 0x50	; 80
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	49 43       	sbci	r20, 0x39	; 57
 16e:	52 41       	sbci	r21, 0x12	; 18
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	00 45       	sbci	r16, 0x50	; 80
 172:	49 4d       	sbci	r20, 0xD9	; 217
 174:	53 4b       	sbci	r21, 0xB3	; 179
 176:	00 45       	sbci	r16, 0x50	; 80
 178:	49 46       	sbci	r20, 0x69	; 105
 17a:	52 00       	.word	0x0052	; ????
 17c:	50 43       	sbci	r21, 0x30	; 48
 17e:	49 43       	sbci	r20, 0x39	; 57
 180:	52 00       	.word	0x0052	; ????
 182:	50 43       	sbci	r21, 0x30	; 48
 184:	4d 53       	subi	r20, 0x3D	; 61
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	4b 32       	cpi	r20, 0x2B	; 43
 188:	00 50       	subi	r16, 0x00	; 0
 18a:	43 4d       	sbci	r20, 0xD3	; 211
 18c:	53 4b       	sbci	r21, 0xB3	; 179
 18e:	31 00       	.word	0x0031	; ????
 190:	50 43       	sbci	r21, 0x30	; 48
 192:	4d 53       	subi	r20, 0x3D	; 61
 194:	4b 30       	cpi	r20, 0x0B	; 11
	unsigned char f = timer0_fract;
 196:	00 50       	subi	r16, 0x00	; 0
 198:	43 49       	sbci	r20, 0x93	; 147

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	46 52       	subi	r20, 0x26	; 38
 19c:	00 53       	subi	r16, 0x30	; 48
	if (f >= FRACT_MAX) {
 19e:	50 44       	sbci	r21, 0x40	; 64
 1a0:	52 00       	.word	0x0052	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	53 50       	subi	r21, 0x03	; 3
 1a4:	53 52       	subi	r21, 0x23	; 35
 1a6:	00 53       	subi	r16, 0x30	; 48
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	50 43       	sbci	r21, 0x30	; 48
 1aa:	52 00       	.word	0x0052	; ????
	timer0_millis = m;
 1ac:	57 44       	sbci	r21, 0x47	; 71
 1ae:	54 43       	sbci	r21, 0x34	; 52
 1b0:	53 52       	subi	r21, 0x23	; 35
 1b2:	00 50       	subi	r16, 0x00	; 0
 1b4:	52 52       	subi	r21, 0x22	; 34
 1b6:	00 4f       	sbci	r16, 0xF0	; 240
 1b8:	53 43       	sbci	r21, 0x33	; 51
 1ba:	43 41       	sbci	r20, 0x13	; 19
	timer0_overflow_count++;
 1bc:	4c 00       	.word	0x004c	; ????
 1be:	43 4c       	sbci	r20, 0xC3	; 195
 1c0:	4b 50       	subi	r20, 0x0B	; 11
 1c2:	52 00       	.word	0x0052	; ????
 1c4:	53 52       	subi	r21, 0x23	; 35
 1c6:	45 47       	sbci	r20, 0x75	; 117
 1c8:	00 53       	subi	r16, 0x30	; 48
 1ca:	50 00       	.word	0x0050	; ????
 1cc:	53 50       	subi	r21, 0x03	; 3
 1ce:	4d 43       	sbci	r20, 0x3D	; 61
 1d0:	53 52       	subi	r21, 0x23	; 35
 1d2:	00 4d       	sbci	r16, 0xD0	; 208
 1d4:	43 55       	subi	r20, 0x53	; 83
 1d6:	43 52       	subi	r20, 0x23	; 35
 1d8:	00 4d       	sbci	r16, 0xD0	; 208
 1da:	43 55       	subi	r20, 0x53	; 83
 1dc:	53 52       	subi	r21, 0x23	; 35
 1de:	00 53       	subi	r16, 0x30	; 48
 1e0:	4d 43       	sbci	r20, 0x3D	; 61
}
 1e2:	52 00       	.word	0x0052	; ????
 1e4:	47 50       	subi	r20, 0x07	; 7
 1e6:	49 4f       	sbci	r20, 0xF9	; 249
 1e8:	52 32       	cpi	r21, 0x22	; 34
 1ea:	00 47       	sbci	r16, 0x70	; 112
 1ec:	50 49       	sbci	r21, 0x90	; 144
 1ee:	4f 52       	subi	r20, 0x2F	; 47
 1f0:	31 00       	.word	0x0031	; ????
 1f2:	47 50       	subi	r20, 0x07	; 7
 1f4:	49 4f       	sbci	r20, 0xF9	; 249
 1f6:	52 30       	cpi	r21, 0x02	; 2
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 45       	sbci	r16, 0x50	; 80
 1fa:	45 41       	sbci	r20, 0x15	; 21
		m += 1;
 1fc:	52 00       	.word	0x0052	; ????
 1fe:	45 45       	sbci	r20, 0x55	; 85
 200:	44 52       	subi	r20, 0x24	; 36
 202:	00 45       	sbci	r16, 0x50	; 80

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	45 43       	sbci	r20, 0x35	; 53
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	52 00       	.word	0x0052	; ????
 208:	64 69       	ori	r22, 0x94	; 148
 20a:	67 69       	ori	r22, 0x97	; 151
	sbi(TCCR0A, WGM00);
 20c:	74 61       	ori	r23, 0x14	; 20
 20e:	6c 57       	subi	r22, 0x7C	; 124
 210:	72 69       	ori	r23, 0x92	; 146
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	74 65       	ori	r23, 0x54	; 84
 214:	00 69       	ori	r16, 0x90	; 144
 216:	6e 69       	ori	r22, 0x9E	; 158
	sbi(TCCR0B, CS00);
 218:	74 00       	.word	0x0074	; ????
 21a:	6d 6f       	ori	r22, 0xFD	; 253
 21c:	64 65       	ori	r22, 0x54	; 84

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 64       	ori	r16, 0x40	; 64
 220:	69 67       	ori	r22, 0x79	; 121
 222:	69 74       	andi	r22, 0x49	; 73
 224:	61 6c       	ori	r22, 0xC1	; 193
 226:	5f 70       	andi	r21, 0x0F	; 15
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	69 6e       	ori	r22, 0xE9	; 233
 22a:	5f 74       	andi	r21, 0x4F	; 79

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	6f 5f       	subi	r22, 0xFF	; 255
 22e:	70 6f       	ori	r23, 0xF0	; 240
 230:	72 74       	andi	r23, 0x42	; 66
 232:	5f 50       	subi	r21, 0x0F	; 15
 234:	47 4d       	sbci	r20, 0xD7	; 215
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 73       	andi	r16, 0x30	; 48
 238:	65 74       	andi	r22, 0x45	; 69
 23a:	75 70       	andi	r23, 0x05	; 5
 23c:	00 69       	ori	r16, 0x90	; 144
 23e:	6e 69       	ori	r22, 0x9E	; 158
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	74 56       	subi	r23, 0x64	; 100
 242:	61 72       	andi	r22, 0x21	; 33
 244:	69 61       	ori	r22, 0x19	; 25
 246:	6e 74       	andi	r22, 0x4E	; 78
 248:	00 74       	andi	r16, 0x40	; 64

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	69 6d       	ori	r22, 0xD9	; 217
 24c:	65 72       	andi	r22, 0x25	; 37
 24e:	30 5f       	subi	r19, 0xF0	; 240
 250:	6f 76       	andi	r22, 0x6F	; 111
 252:	65 72       	andi	r22, 0x25	; 37

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	66 6c       	ori	r22, 0xC6	; 198
 256:	6f 77       	andi	r22, 0x7F	; 127
 258:	5f 63       	ori	r21, 0x3F	; 63
 25a:	6f 75       	andi	r22, 0x5F	; 95
 25c:	6e 74       	andi	r22, 0x4E	; 78
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 70       	andi	r16, 0x00	; 0
 260:	6f 72       	andi	r22, 0x2F	; 47
 262:	74 5f       	subi	r23, 0xF4	; 244
 264:	74 6f       	ori	r23, 0xF4	; 244
 266:	5f 6f       	ori	r21, 0xFF	; 255
		sbi(ADCSRA, ADPS1);
 268:	75 74       	andi	r23, 0x45	; 69
 26a:	70 75       	andi	r23, 0x50	; 80
 26c:	74 5f       	subi	r23, 0xF4	; 244
 26e:	50 47       	sbci	r21, 0x70	; 112
 270:	4d 00       	.word	0x004d	; ????
		sbi(ADCSRA, ADPS0);
 272:	3c 61       	ori	r19, 0x1C	; 28
 274:	72 74       	andi	r23, 0x42	; 66
 276:	69 66       	ori	r22, 0x69	; 105
 278:	69 63       	ori	r22, 0x39	; 57
 27a:	69 61       	ori	r22, 0x19	; 25
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	6c 3e       	cpi	r22, 0xEC	; 236
 27e:	00 5f       	subi	r16, 0xF0	; 240
 280:	5f 61       	ori	r21, 0x1F	; 31
 282:	64 64       	ori	r22, 0x44	; 68
 284:	72 31       	cpi	r23, 0x12	; 18
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 286:	36 00       	.word	0x0036	; ????
 288:	70 6f       	ori	r23, 0xF0	; 240
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	72 74       	andi	r23, 0x42	; 66
 28c:	00 74       	andi	r16, 0x40	; 64
 28e:	75 72       	andi	r23, 0x25	; 37
	uint8_t port = digitalPinToPort(pin);
 290:	6e 4f       	sbci	r22, 0xFE	; 254
 292:	66 66       	ori	r22, 0x66	; 102
 294:	50 57       	subi	r21, 0x70	; 112
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	4d 2e       	mov	r4, r29
 298:	70 61       	ori	r23, 0x10	; 16

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	72 74       	andi	r23, 0x42	; 66
 29c:	2e 30       	cpi	r18, 0x0E	; 14
 29e:	00 74       	andi	r16, 0x40	; 64
 2a0:	69 6d       	ori	r22, 0xD9	; 217
 2a2:	65 72       	andi	r22, 0x25	; 37
 2a4:	30 5f       	subi	r19, 0xF0	; 240
 2a6:	66 72       	andi	r22, 0x26	; 38
 2a8:	61 63       	ori	r22, 0x31	; 49
	out = portOutputRegister(port);
 2aa:	74 00       	.word	0x0074	; ????
 2ac:	75 69       	ori	r23, 0x95	; 149
 2ae:	6e 74       	andi	r22, 0x4E	; 78
 2b0:	38 5f       	subi	r19, 0xF8	; 248
 2b2:	74 00       	.word	0x0074	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	75 6e       	ori	r23, 0xE5	; 229
                cli();
 2b6:	73 69       	ori	r23, 0x93	; 147
		*reg |= bit;
 2b8:	67 6e       	ori	r22, 0xE7	; 231
 2ba:	65 64       	ori	r22, 0x45	; 69
 2bc:	20 63       	ori	r18, 0x30	; 48
		SREG = oldSREG;
 2be:	68 61       	ori	r22, 0x18	; 24
 2c0:	72 00       	.word	0x0072	; ????
 2c2:	6d 61       	ori	r22, 0x1D	; 29
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	69 6e       	ori	r22, 0xE9	; 233
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	00 5f       	subi	r16, 0xF0	; 240
 2c8:	5f 76       	andi	r21, 0x6F	; 111
 2ca:	65 63       	ori	r22, 0x35	; 53
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	74 6f       	ori	r23, 0xF4	; 244
 2ce:	72 5f       	subi	r23, 0xF2	; 242
 2d0:	31 36       	cpi	r19, 0x61	; 97
  
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2d2:	00 47       	sbci	r16, 0x70	; 112
 2d4:	4e 55       	subi	r20, 0x5E	; 94
 2d6:	20 47       	sbci	r18, 0x70	; 112
 2d8:	49 4d       	sbci	r20, 0xD9	; 217
 2da:	50 4c       	sbci	r21, 0xC0	; 192
 2dc:	45 20       	and	r4, r5
 2de:	37 2e       	mov	r3, r23
 2e0:	33 2e       	mov	r3, r19
 2e2:	30 20       	and	r3, r0
 2e4:	2d 6d       	ori	r18, 0xDD	; 221
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2e6:	6e 2d       	mov	r22, r14
 2e8:	66 6c       	ori	r22, 0xC6	; 198
 2ea:	61 73       	andi	r22, 0x31	; 49
 2ec:	68 3d       	cpi	r22, 0xD8	; 216
 2ee:	31 20       	and	r3, r1
 2f0:	2d 6d       	ori	r18, 0xDD	; 221
 2f2:	6d 63       	ori	r22, 0x3D	; 61
 2f4:	75 3d       	cpi	r23, 0xD5	; 213
 2f6:	61 76       	andi	r22, 0x61	; 97
 2f8:	72 35       	cpi	r23, 0x52	; 82
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2fa:	20 2d       	mov	r18, r0
 2fc:	6d 6e       	ori	r22, 0xED	; 237
 2fe:	2d 66       	ori	r18, 0x6D	; 109
 300:	6c 61       	ori	r22, 0x1C	; 28
 302:	73 68       	ori	r23, 0x83	; 131
 304:	3d 31       	cpi	r19, 0x1D	; 29
 306:	20 2d       	mov	r18, r0
 308:	6d 6e       	ori	r22, 0xED	; 237
 30a:	6f 2d       	mov	r22, r15
 30c:	73 6b       	ori	r23, 0xB3	; 179
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 30e:	69 70       	andi	r22, 0x09	; 9
 310:	2d 62       	ori	r18, 0x2D	; 45
 312:	75 67       	ori	r23, 0x75	; 117
 314:	20 2d       	mov	r18, r0
 316:	6d 6d       	ori	r22, 0xDD	; 221
 318:	63 75       	andi	r22, 0x53	; 83
 31a:	3d 61       	ori	r19, 0x1D	; 29
 31c:	76 72       	andi	r23, 0x26	; 38
 31e:	35 20       	and	r3, r5
 320:	2d 67       	ori	r18, 0x7D	; 125
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 322:	20 2d       	mov	r18, r0
 324:	4f 73       	andi	r20, 0x3F	; 63
 326:	20 2d       	mov	r18, r0
 328:	4f 73       	andi	r20, 0x3F	; 63
 32a:	20 2d       	mov	r18, r0
 32c:	66 6d       	ori	r22, 0xD6	; 214
 32e:	61 74       	andi	r22, 0x41	; 65
 330:	68 2d       	mov	r22, r8
 332:	65 72       	andi	r22, 0x25	; 37
 334:	72 6e       	ori	r23, 0xE2	; 226
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 336:	6f 20       	and	r6, r15
 338:	2d 66       	ori	r18, 0x6D	; 109
 33a:	73 69       	ori	r23, 0x93	; 147
 33c:	67 6e       	ori	r22, 0xE7	; 231
 33e:	65 64       	ori	r22, 0x45	; 69
 340:	2d 7a       	andi	r18, 0xAD	; 173
 342:	65 72       	andi	r22, 0x25	; 37
 344:	6f 73       	andi	r22, 0x3F	; 63
 346:	20 2d       	mov	r18, r0
 348:	66 74       	andi	r22, 0x46	; 70
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 34a:	72 61       	ori	r23, 0x12	; 18
 34c:	70 70       	andi	r23, 0x00	; 0
 34e:	69 6e       	ori	r22, 0xE9	; 233
 350:	67 2d       	mov	r22, r7
 352:	6d 61       	ori	r22, 0x1D	; 29
 354:	74 68       	ori	r23, 0x84	; 132
 356:	20 2d       	mov	r18, r0
 358:	66 6e       	ori	r22, 0xE6	; 230
 35a:	6f 2d       	mov	r22, r15
 35c:	74 72       	andi	r23, 0x24	; 36
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 35e:	61 70       	andi	r22, 0x01	; 1
 360:	76 20       	and	r7, r6
 362:	2d 66       	ori	r18, 0x6D	; 109
 364:	6e 6f       	ori	r22, 0xFE	; 254
 366:	2d 6f       	ori	r18, 0xFD	; 253
 368:	70 65       	ori	r23, 0x50	; 80
 36a:	6e 6d       	ori	r22, 0xDE	; 222
 36c:	70 20       	and	r7, r0
 36e:	2d 66       	ori	r18, 0x6D	; 109
 370:	6e 6f       	ori	r22, 0xFE	; 254
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 372:	2d 6f       	ori	r18, 0xFD	; 253
 374:	70 65       	ori	r23, 0x50	; 80
 376:	6e 61       	ori	r22, 0x1E	; 30
 378:	63 63       	ori	r22, 0x33	; 51
 37a:	20 2d       	mov	r18, r0
 37c:	66 6e       	ori	r22, 0xE6	; 230
 37e:	6f 2d       	mov	r22, r15
 380:	65 78       	andi	r22, 0x85	; 133
 382:	63 65       	ori	r22, 0x53	; 83
 384:	70 74       	andi	r23, 0x40	; 64
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 386:	69 6f       	ori	r22, 0xF9	; 249
 388:	6e 73       	andi	r22, 0x3E	; 62
 38a:	20 2d       	mov	r18, r0
 38c:	66 75       	andi	r22, 0x56	; 86
 38e:	73 65       	ori	r23, 0x53	; 83
 390:	2d 6c       	ori	r18, 0xCD	; 205
 392:	69 6e       	ori	r22, 0xE9	; 233
 394:	6b 65       	ori	r22, 0x5B	; 91
 396:	72 2d       	mov	r23, r2
 398:	70 6c       	ori	r23, 0xC0	; 192
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 39a:	75 67       	ori	r23, 0x75	; 117
 39c:	69 6e       	ori	r22, 0xE9	; 233
 39e:	20 2d       	mov	r18, r0
 3a0:	66 6c       	ori	r22, 0xC6	; 198
 3a2:	74 72       	andi	r23, 0x24	; 36
 3a4:	61 6e       	ori	r22, 0xE1	; 225
 3a6:	73 00       	.word	0x0073	; ????
 3a8:	64 69       	ori	r22, 0x94	; 148
 3aa:	67 69       	ori	r22, 0x97	; 151
 3ac:	74 61       	ori	r23, 0x14	; 20
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ae:	6c 5f       	subi	r22, 0xFC	; 252
 3b0:	70 69       	ori	r23, 0x90	; 144
 3b2:	6e 5f       	subi	r22, 0xFE	; 254
 3b4:	74 6f       	ori	r23, 0xF4	; 244
 3b6:	5f 62       	ori	r21, 0x2F	; 47
 3b8:	69 74       	andi	r22, 0x49	; 73
 3ba:	5f 6d       	ori	r21, 0xDF	; 223
 3bc:	61 73       	andi	r22, 0x31	; 49
 3be:	6b 5f       	subi	r22, 0xFB	; 251
 3c0:	50 47       	sbci	r21, 0x70	; 112
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3c2:	4d 00       	.word	0x004d	; ????
 3c4:	74 69       	ori	r23, 0x94	; 148
 3c6:	6d 65       	ori	r22, 0x5D	; 93
 3c8:	72 30       	cpi	r23, 0x02	; 2
 3ca:	5f 6d       	ori	r21, 0xDF	; 223
 3cc:	69 6c       	ori	r22, 0xC9	; 201
 3ce:	6c 69       	ori	r22, 0x9C	; 156
 3d0:	73 00       	.word	0x0073	; ????
 3d2:	6c 6f       	ori	r22, 0xFC	; 252
 3d4:	6e 67       	ori	r22, 0x7E	; 126
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3d6:	20 75       	andi	r18, 0x50	; 80
 3d8:	6e 73       	andi	r22, 0x3E	; 62
 3da:	69 67       	ori	r22, 0x79	; 121
 3dc:	6e 65       	ori	r22, 0x5E	; 94
 3de:	64 20       	and	r6, r4
 3e0:	69 6e       	ori	r22, 0xE9	; 233
 3e2:	74 00       	.word	0x0074	; ????
 3e4:	74 75       	andi	r23, 0x54	; 84
 3e6:	72 6e       	ori	r23, 0xE2	; 226
 3e8:	4f 66       	ori	r20, 0x6F	; 111
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3ea:	66 50       	subi	r22, 0x06	; 6
 3ec:	57 4d       	sbci	r21, 0xD7	; 215
 3ee:	00 64       	ori	r16, 0x40	; 64
 3f0:	69 67       	ori	r22, 0x79	; 121
 3f2:	69 74       	andi	r22, 0x49	; 73
 3f4:	61 6c       	ori	r22, 0xC1	; 193
 3f6:	5f 70       	andi	r21, 0x0F	; 15
 3f8:	69 6e       	ori	r22, 0xE9	; 233
 3fa:	5f 74       	andi	r21, 0x4F	; 79
 3fc:	6f 5f       	subi	r22, 0xFF	; 255
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 3fe:	74 69       	ori	r23, 0x94	; 148
 400:	6d 65       	ori	r22, 0x5D	; 93
 402:	72 5f       	subi	r23, 0xF2	; 242
 404:	50 47       	sbci	r21, 0x70	; 112
 406:	4d 00       	.word	0x004d	; ????
 408:	5f 5f       	subi	r21, 0xFF	; 255
 40a:	72 65       	ori	r23, 0x52	; 82
 40c:	73 75       	andi	r23, 0x53	; 83
 40e:	6c 74       	andi	r22, 0x4C	; 76
 410:	00 43       	sbci	r16, 0x30	; 48
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 412:	3a 5c       	subi	r19, 0xCA	; 202
 414:	55 73       	andi	r21, 0x35	; 53
 416:	65 72       	andi	r22, 0x25	; 37
 418:	73 5c       	subi	r23, 0xC3	; 195
 41a:	52 59       	subi	r21, 0x92	; 146
 41c:	77 6f       	ori	r23, 0xF7	; 247
 41e:	72 6b       	ori	r23, 0xB2	; 178
 420:	5c 44       	sbci	r21, 0x4C	; 76
 422:	65 73       	andi	r22, 0x35	; 53
 424:	6b 74       	andi	r22, 0x4B	; 75
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 426:	6f 70       	andi	r22, 0x0F	; 15
 428:	5c 53       	subi	r21, 0x3C	; 60
 42a:	70 72       	andi	r23, 0x20	; 32
 42c:	69 6e       	ori	r22, 0xE9	; 233
 42e:	67 20       	and	r6, r7
 430:	31 39       	cpi	r19, 0x91	; 145
 432:	5c 61       	ori	r21, 0x1C	; 28
 434:	73 73       	andi	r23, 0x33	; 51
 436:	69 67       	ori	r22, 0x79	; 121
 438:	6e 6d       	ori	r22, 0xDE	; 222
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 43a:	65 6e       	ori	r22, 0xE5	; 229
 43c:	74 34       	cpi	r23, 0x44	; 68
 43e:	5c 41       	sbci	r21, 0x1C	; 28
 440:	72 64       	ori	r23, 0x42	; 66
 442:	75 69       	ori	r23, 0x95	; 149
 444:	6e 6f       	ori	r22, 0xFE	; 254
 446:	41 73       	andi	r20, 0x31	; 49
 448:	73 65       	ori	r23, 0x53	; 83
 44a:	6d 62       	ori	r22, 0x2D	; 45
 44c:	6c 79       	andi	r22, 0x9C	; 156
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 44e:	50 61       	ori	r21, 0x10	; 16
 450:	72 73       	andi	r23, 0x32	; 50
 452:	65 72       	andi	r22, 0x25	; 37
 454:	5c 50       	subi	r21, 0x0C	; 12
 456:	61 72       	andi	r22, 0x21	; 33
 458:	73 65       	ori	r23, 0x53	; 83
 45a:	72 49       	sbci	r23, 0x92	; 146
 45c:	6e 70       	andi	r22, 0x0E	; 14
 45e:	75 74       	andi	r23, 0x45	; 69
 460:	46 69       	ori	r20, 0x96	; 150
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 462:	6c 65       	ori	r22, 0x5C	; 92
 464:	73 5c       	subi	r23, 0xC3	; 195
 466:	52 61       	ori	r21, 0x12	; 18
 468:	77 41       	sbci	r23, 0x17	; 23
 46a:	72 64       	ori	r23, 0x42	; 66
 46c:	75 69       	ori	r23, 0x95	; 149
 46e:	6e 6f       	ori	r22, 0xFE	; 254
 470:	46 69       	ori	r20, 0x96	; 150
 472:	6c 65       	ori	r22, 0x5C	; 92
 474:	73 5c       	subi	r23, 0xC3	; 195
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 476:	4c 41       	sbci	r20, 0x1C	; 28
 478:	44 53       	subi	r20, 0x34	; 52
 47a:	5f 53       	subi	r21, 0x3F	; 63
 47c:	6c 65       	ori	r22, 0x5C	; 92
 47e:	65 70       	andi	r22, 0x05	; 5
 480:	5f 6c       	ori	r21, 0xCF	; 207
 482:	6f 6f       	ori	r22, 0xFF	; 255
 484:	70 00       	.word	0x0070	; ????
 486:	75 69       	ori	r23, 0x95	; 149
 488:	6e 74       	andi	r22, 0x4E	; 78
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 48a:	31 36       	cpi	r19, 0x61	; 97
 48c:	5f 74       	andi	r21, 0x4F	; 79
 48e:	00 70       	andi	r16, 0x00	; 0
 490:	6f 72       	andi	r22, 0x2F	; 47
 492:	74 5f       	subi	r23, 0xF4	; 244
 494:	74 6f       	ori	r23, 0xF4	; 244
 496:	5f 6d       	ori	r21, 0xDF	; 223
 498:	6f 64       	ori	r22, 0x4F	; 79
 49a:	65 5f       	subi	r22, 0xF5	; 245
 49c:	50 47       	sbci	r21, 0x70	; 112
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 49e:	4d 00       	.word	0x004d	; ????
 4a0:	74 69       	ori	r23, 0x94	; 148
 4a2:	6d 65       	ori	r22, 0x5D	; 93
 4a4:	72 00       	.word	0x0072	; ????
 4a6:	70 69       	ori	r23, 0x90	; 144
 4a8:	6e 4d       	sbci	r22, 0xDE	; 222
 4aa:	6f 64       	ori	r22, 0x4F	; 79
 4ac:	65 00       	.word	0x0065	; ????
 4ae:	6f 6c       	ori	r22, 0xCF	; 207
 4b0:	64 53       	subi	r22, 0x34	; 52
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 4b2:	52 45       	sbci	r21, 0x52	; 82
 4b4:	47 00       	.word	0x0047	; ????

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
   0:	e6 00       	.word	0x00e6	; ????
   2:	00 00       	nop
   4:	08 01       	movw	r0, r16
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	62 2a       	or	r6, r18
   c:	01 00       	.word	0x0001	; ????
   e:	00 3a       	cpi	r16, 0xA0	; 160
  10:	01 00       	.word	0x0001	; ????
  12:	00 01       	movw	r0, r0
  14:	00 62       	ori	r16, 0x20	; 32
  16:	3e 01       	movw	r6, r28
  18:	00 00       	nop
  1a:	42 01       	movw	r8, r4
  1c:	00 00       	nop
  1e:	01 00       	.word	0x0001	; ????
  20:	62 4a       	sbci	r22, 0xA2	; 162
  22:	01 00       	.word	0x0001	; ????
  24:	00 4c       	sbci	r16, 0xC0	; 192
  26:	01 00       	.word	0x0001	; ????
  28:	00 01       	movw	r0, r0
  2a:	00 62       	ori	r16, 0x20	; 32
  2c:	52 01       	movw	r10, r4
  2e:	00 00       	nop
  30:	54 01       	movw	r10, r8
  32:	00 00       	nop
  34:	01 00       	.word	0x0001	; ????
  36:	62 58       	subi	r22, 0x82	; 130
  38:	01 00       	.word	0x0001	; ????
  3a:	00 5c       	subi	r16, 0xC0	; 192
  3c:	01 00       	.word	0x0001	; ????
  3e:	00 01       	movw	r0, r0
  40:	00 62       	ori	r16, 0x20	; 32
  42:	64 01       	movw	r12, r8
  44:	00 00       	nop
  46:	68 01       	movw	r12, r16
  48:	00 00       	nop
  4a:	01 00       	.word	0x0001	; ????
  4c:	62 00       	.word	0x0062	; ????
  4e:	00 00       	nop
  50:	00 00       	nop
  52:	00 00       	nop
  54:	00 ec       	ldi	r16, 0xC0	; 192
  56:	00 00       	nop
  58:	00 22       	and	r0, r16
  5a:	01 00       	.word	0x0001	; ????
  5c:	00 01       	movw	r0, r0
  5e:	00 69       	ori	r16, 0x90	; 144
  60:	22 01       	movw	r4, r4
  62:	00 00       	nop
  64:	24 01       	movw	r4, r8
  66:	00 00       	nop
  68:	04 00       	.word	0x0004	; ????
  6a:	89 00       	.word	0x0089	; ????
  6c:	20 9f       	mul	r18, r16
  6e:	2a 01       	movw	r4, r20
  70:	00 00       	nop
  72:	6e 01       	movw	r12, r28
  74:	00 00       	nop
  76:	01 00       	.word	0x0001	; ????
  78:	69 00       	.word	0x0069	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	00 f2       	brcs	.-128    	; 0x2 <__zero_reg__+0x1>
  82:	00 00       	nop
  84:	00 0e       	add	r0, r16
  86:	01 00       	.word	0x0001	; ????
  88:	00 01       	movw	r0, r0
  8a:	00 6e       	ori	r16, 0xE0	; 224
  8c:	2a 01       	movw	r4, r20
  8e:	00 00       	nop
  90:	6c 01       	movw	r12, r24
  92:	00 00       	nop
  94:	01 00       	.word	0x0001	; ????
  96:	6e 00       	.word	0x006e	; ????
  98:	00 00       	nop
  9a:	00 00       	nop
  9c:	00 00       	nop
  9e:	00 16       	cp	r0, r16
  a0:	01 00       	.word	0x0001	; ????
  a2:	00 28       	or	r0, r0
  a4:	01 00       	.word	0x0001	; ????
  a6:	00 06       	cpc	r0, r16
  a8:	00 6a       	ori	r16, 0xA0	; 160
  aa:	93 01       	movw	r18, r6
  ac:	6b 93       	.word	0x936b	; ????
  ae:	01 6c       	ori	r16, 0xC1	; 193
  b0:	01 00       	.word	0x0001	; ????
  b2:	00 70       	andi	r16, 0x00	; 0
  b4:	01 00       	.word	0x0001	; ????
  b6:	00 06       	cpc	r0, r16
  b8:	00 6a       	ori	r16, 0xA0	; 160
  ba:	93 01       	movw	r18, r6
  bc:	6b 93       	.word	0x936b	; ????
  be:	01 00       	.word	0x0001	; ????
  c0:	00 00       	nop
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	00 18       	sub	r0, r0
  c8:	01 00       	.word	0x0001	; ????
  ca:	00 28       	or	r0, r0
  cc:	01 00       	.word	0x0001	; ????
  ce:	00 01       	movw	r0, r0
  d0:	00 62       	ori	r16, 0x20	; 32
  d2:	6c 01       	movw	r12, r24
  d4:	00 00       	nop
  d6:	70 01       	movw	r14, r0
  d8:	00 00       	nop
  da:	01 00       	.word	0x0001	; ????
  dc:	62 00       	.word	0x0062	; ????
  de:	00 00       	nop
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
  e0:	00 00       	nop
  e2:	00 00       	nop
  e4:	00 e4       	ldi	r16, 0x40	; 64
	uint8_t bit = digitalPinToBitMask(pin);
  e6:	00 00       	nop
  e8:	00 ea       	ldi	r16, 0xA0	; 160
  ea:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
  ec:	00 06       	cpc	r0, r16
  ee:	00 6e       	ori	r16, 0xE0	; 224
  f0:	93 01       	movw	r18, r6
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  f2:	6f 93       	push	r22
  f4:	01 00       	.word	0x0001	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f6:	00 00       	nop
  f8:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
  fa:	00 00       	nop
  fc:	00 ea       	ldi	r16, 0xA0	; 160
  fe:	00 00       	nop
 100:	00 f0       	brcs	.+0      	; 0x102 <digitalWrite.constprop.0+0x22>
 102:	00 00       	nop
 104:	00 06       	cpc	r0, r16
 106:	00 6e       	ori	r16, 0xE0	; 224

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 108:	93 01       	movw	r18, r6
 10a:	6f 93       	push	r22
 10c:	01 00       	.word	0x0001	; ????
 10e:	00 00       	nop
 110:	00 00       	nop
 112:	00 00       	nop
 114:	00 f0       	brcs	.+0      	; 0x116 <digitalWrite.constprop.0+0x36>

	uint8_t oldSREG = SREG;
 116:	00 00       	nop
	cli();
 118:	00 f2       	brcs	.-128    	; 0x9a <digital_pin_to_bit_mask_PGM+0xa>

	if (val == LOW) {
		*out &= ~bit;
 11a:	00 00       	nop
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 11c:	00 06       	cpc	r0, r16
 11e:	00 6e       	ori	r16, 0xE0	; 224
		*out &= ~bit;
 120:	93 01       	movw	r18, r6
 122:	6f 93       	push	r22
	} else {
		*out |= bit;
 124:	01 00       	.word	0x0001	; ????
	}

	SREG = oldSREG;
 126:	00 00       	nop
}
 128:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 12a:	00 00       	nop
 12c:	00 fa       	bst	r0, 0
 12e:	00 00       	nop
 130:	00 08       	sbc	r0, r0
 132:	01 00       	.word	0x0001	; ????
 134:	00 01       	movw	r0, r0
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 136:	00 62       	ori	r16, 0x20	; 32
 138:	2a 01       	movw	r4, r20
 13a:	00 00       	nop
 13c:	3a 01       	movw	r6, r20
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 13e:	00 00       	nop
 140:	01 00       	.word	0x0001	; ????
 142:	62 3e       	cpi	r22, 0xE2	; 226
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 144:	01 00       	.word	0x0001	; ????
 146:	00 42       	sbci	r16, 0x20	; 32
 148:	01 00       	.word	0x0001	; ????
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 14a:	00 01       	movw	r0, r0
 14c:	00 62       	ori	r16, 0x20	; 32
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 14e:	4a 01       	movw	r8, r20
 150:	00 00       	nop
 152:	4c 01       	movw	r8, r24
 154:	00 00       	nop
 156:	01 00       	.word	0x0001	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 158:	62 52       	subi	r22, 0x22	; 34
 15a:	01 00       	.word	0x0001	; ????
 15c:	00 54       	subi	r16, 0x40	; 64
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 15e:	01 00       	.word	0x0001	; ????
 160:	00 01       	movw	r0, r0
 162:	00 62       	ori	r16, 0x20	; 32
 164:	58 01       	movw	r10, r16
 166:	00 00       	nop
 168:	5c 01       	movw	r10, r24
 16a:	00 00       	nop
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 16c:	01 00       	.word	0x0001	; ????
 16e:	62 64       	ori	r22, 0x42	; 66
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 170:	01 00       	.word	0x0001	; ????
 172:	00 68       	ori	r16, 0x80	; 128
 174:	01 00       	.word	0x0001	; ????
 176:	00 01       	movw	r0, r0
 178:	00 62       	ori	r16, 0x20	; 32
	...
 182:	12 01       	movw	r2, r4
 184:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 186:	16 01       	movw	r2, r12
 188:	00 00       	nop
 18a:	06 00       	.word	0x0006	; ????
 18c:	6e 93       	st	-X, r22
 18e:	01 6f       	ori	r16, 0xF1	; 241
 190:	93 01       	movw	r18, r6
	...
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
 19a:	70 01       	movw	r14, r0
 19c:	00 00       	nop
	if (f >= FRACT_MAX) {
 19e:	72 01       	movw	r14, r4
 1a0:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 1a2:	03 00       	.word	0x0003	; ????
 1a4:	92 20       	and	r9, r2
 1a6:	02 72       	andi	r16, 0x22	; 34
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 1a8:	01 00       	.word	0x0001	; ????
 1aa:	00 74       	andi	r16, 0x40	; 64
	timer0_millis = m;
 1ac:	01 00       	.word	0x0001	; ????
 1ae:	00 03       	mulsu	r16, r16
 1b0:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x217>
 1b4:	74 01       	movw	r14, r8
 1b6:	00 00       	nop
 1b8:	7c 01       	movw	r14, r24
 1ba:	00 00       	nop
	timer0_overflow_count++;
 1bc:	03 00       	.word	0x0003	; ????
 1be:	92 20       	and	r9, r2
 1c0:	04 7c       	andi	r16, 0xC4	; 196
 1c2:	01 00       	.word	0x0001	; ????
 1c4:	00 7e       	andi	r16, 0xE0	; 224
 1c6:	01 00       	.word	0x0001	; ????
 1c8:	00 03       	mulsu	r16, r16
 1ca:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x417>
 1ce:	7e 01       	movw	r14, r28
 1d0:	00 00       	nop
 1d2:	80 01       	movw	r16, r0
 1d4:	00 00       	nop
 1d6:	03 00       	.word	0x0003	; ????
 1d8:	92 20       	and	r9, r2
 1da:	06 80       	ldd	r0, Z+6	; 0x06
 1dc:	01 00       	.word	0x0001	; ????
 1de:	00 82       	st	Z, r0
 1e0:	01 00       	.word	0x0001	; ????
}
 1e2:	00 03       	mulsu	r16, r16
 1e4:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x617>
 1e8:	82 01       	movw	r16, r4
 1ea:	00 00       	nop
 1ec:	84 01       	movw	r16, r8
 1ee:	00 00       	nop
 1f0:	03 00       	.word	0x0003	; ????
 1f2:	92 20       	and	r9, r2
 1f4:	08 84       	ldd	r0, Y+8	; 0x08
 1f6:	01 00       	.word	0x0001	; ????
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 1f8:	00 86       	std	Z+8, r0	; 0x08
 1fa:	01 00       	.word	0x0001	; ????
		m += 1;
 1fc:	00 03       	mulsu	r16, r16
 1fe:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x817>
 202:	86 01       	movw	r16, r12

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 204:	00 00       	nop
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 206:	04 02       	muls	r16, r20
 208:	00 00       	nop
 20a:	03 00       	.word	0x0003	; ????
	sbi(TCCR0A, WGM00);
 20c:	92 20       	and	r9, r2
 20e:	0a 00       	.word	0x000a	; ????
 210:	00 00       	nop
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 212:	00 00       	nop
 214:	00 00       	nop
 216:	00 96       	adiw	r24, 0x00	; 0
	sbi(TCCR0B, CS00);
 218:	01 00       	.word	0x0001	; ????
 21a:	00 9a       	sbi	0x00, 0	; 0
 21c:	01 00       	.word	0x0001	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 21e:	00 0c       	add	r0, r0
 220:	00 68       	ori	r16, 0x80	; 128
 222:	93 01       	movw	r18, r6
 224:	69 93       	st	Y+, r22
 226:	01 6a       	ori	r16, 0xA1	; 161
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 228:	93 01       	movw	r18, r6
 22a:	6b 93       	.word	0x936b	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 22c:	01 9a       	sbi	0x00, 1	; 0
 22e:	01 00       	.word	0x0001	; ????
 230:	00 a8       	ldd	r0, Z+48	; 0x30
 232:	01 00       	.word	0x0001	; ????
 234:	00 03       	mulsu	r16, r16
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 236:	00 88       	ldd	r0, Z+16	; 0x10
 238:	01 9f       	mul	r16, r17
 23a:	a8 01       	movw	r20, r16
 23c:	00 00       	nop
 23e:	cc 01       	movw	r24, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 240:	00 00       	nop
 242:	0c 00       	.word	0x000c	; ????
 244:	68 93       	.word	0x9368	; ????
 246:	01 69       	ori	r16, 0x91	; 145
 248:	93 01       	movw	r18, r6

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 24a:	6a 93       	st	-Y, r22
 24c:	01 6b       	ori	r16, 0xB1	; 177
 24e:	93 01       	movw	r18, r6
 250:	cc 01       	movw	r24, r24
 252:	00 00       	nop

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 254:	e2 01       	movw	r28, r4
 256:	00 00       	nop
 258:	05 00       	.word	0x0005	; ????
 25a:	03 05       	cpc	r16, r3
 25c:	01 80       	ldd	r0, Z+1	; 0x01
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 25e:	00 f8       	bld	r0, 0
 260:	01 00       	.word	0x0001	; ????
 262:	00 02       	muls	r16, r16
 264:	02 00       	.word	0x0002	; ????
 266:	00 03       	mulsu	r16, r16
		sbi(ADCSRA, ADPS1);
 268:	00 88       	ldd	r0, Z+16	; 0x10
 26a:	01 9f       	mul	r16, r17
 26c:	02 02       	muls	r16, r18
 26e:	00 00       	nop
 270:	04 02       	muls	r16, r20
		sbi(ADCSRA, ADPS0);
 272:	00 00       	nop
 274:	0c 00       	.word	0x000c	; ????
 276:	68 93       	.word	0x9368	; ????
 278:	01 69       	ori	r16, 0x91	; 145
 27a:	93 01       	movw	r18, r6
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 27c:	6a 93       	st	-Y, r22
 27e:	01 6b       	ori	r16, 0xB1	; 177
 280:	93 01       	movw	r18, r6
	...
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28a:	9a 01       	movw	r18, r20
 28c:	00 00       	nop
 28e:	9e 01       	movw	r18, r28
	uint8_t port = digitalPinToPort(pin);
 290:	00 00       	nop
 292:	01 00       	.word	0x0001	; ????
 294:	63 9e       	mul	r6, r19
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 296:	01 00       	.word	0x0001	; ????
 298:	00 ee       	ldi	r16, 0xE0	; 224

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 29a:	01 00       	.word	0x0001	; ????
 29c:	00 01       	movw	r0, r0
 29e:	00 62       	ori	r16, 0x20	; 32
 2a0:	ee 01       	movw	r28, r28
 2a2:	00 00       	nop
 2a4:	f2 01       	movw	r30, r4
 2a6:	00 00       	nop
 2a8:	05 00       	.word	0x0005	; ????
	out = portOutputRegister(port);
 2aa:	03 04       	cpc	r0, r3
 2ac:	01 80       	ldd	r0, Z+1	; 0x01
 2ae:	00 f8       	bld	r0, 0
 2b0:	01 00       	.word	0x0001	; ????
 2b2:	00 fa       	bst	r0, 0
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 2b4:	01 00       	.word	0x0001	; ????
                cli();
 2b6:	00 01       	movw	r0, r0
		*reg |= bit;
 2b8:	00 62       	ori	r16, 0x20	; 32
 2ba:	fa 01       	movw	r30, r20
 2bc:	00 00       	nop
		SREG = oldSREG;
 2be:	fc 01       	movw	r30, r24
 2c0:	00 00       	nop
 2c2:	03 00       	.word	0x0003	; ????
}

void loop() {
  // put your main code here, to run repeatedly:
  // Create trigger
  noInterrupts();
 2c4:	83 03       	fmuls	r16, r19
  digitalWrite(LED_BUILTIN, LOW);   
 2c6:	9f fc       	.word	0xfc9f	; ????
 2c8:	01 00       	.word	0x0001	; ????
 2ca:	00 04       	cpc	r0, r0
  digitalWrite(LED_BUILTIN, HIGH);   // Trigger with LED
 2cc:	02 00       	.word	0x0002	; ????
 2ce:	00 01       	movw	r0, r0
 2d0:	00 62       	ori	r16, 0x20	; 32
	...
  
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2da:	90 02       	muls	r25, r16
 2dc:	00 00       	nop
 2de:	c4 02       	muls	r28, r20
 2e0:	00 00       	nop
 2e2:	01 00       	.word	0x0001	; ????
 2e4:	62 00       	.word	0x0062	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 2e6:	00 00       	nop
 2e8:	00 00       	nop
 2ea:	00 00       	nop
 2ec:	00 96       	adiw	r24, 0x00	; 0
 2ee:	02 00       	.word	0x0002	; ????
 2f0:	00 a0       	ldd	r0, Z+32	; 0x20
 2f2:	02 00       	.word	0x0002	; ????
 2f4:	00 01       	movw	r0, r0
 2f6:	00 68       	ori	r16, 0x80	; 128
	...
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 300:	aa 02       	muls	r26, r26
 302:	00 00       	nop
 304:	c0 02       	muls	r28, r16
 306:	00 00       	nop
 308:	06 00       	.word	0x0006	; ????
 30a:	6a 93       	st	-Y, r22
 30c:	01 6b       	ori	r16, 0xB1	; 177
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 30e:	93 01       	movw	r18, r6
	...
 318:	8e 02       	muls	r24, r30
 31a:	00 00       	nop
 31c:	94 02       	muls	r25, r20
 31e:	00 00       	nop
 320:	06 00       	.word	0x0006	; ????
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 322:	6e 93       	st	-X, r22
 324:	01 6f       	ori	r16, 0xF1	; 241
 326:	93 01       	movw	r18, r6
	...
 330:	94 02       	muls	r25, r20
 332:	00 00       	nop
 334:	a2 02       	muls	r26, r18
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 336:	00 00       	nop
 338:	06 00       	.word	0x0006	; ????
 33a:	6e 93       	st	-X, r22
 33c:	01 6f       	ori	r16, 0xF1	; 241
 33e:	93 01       	movw	r18, r6
	...
 348:	a6 02       	muls	r26, r22
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 34a:	00 00       	nop
 34c:	aa 02       	muls	r26, r26
 34e:	00 00       	nop
 350:	06 00       	.word	0x0006	; ????
 352:	6e 93       	st	-X, r22
 354:	01 6f       	ori	r16, 0xF1	; 241
 356:	93 01       	movw	r18, r6
	...
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 360:	b0 02       	muls	r27, r16
 362:	00 00       	nop
 364:	b4 02       	muls	r27, r20
 366:	00 00       	nop
 368:	06 00       	.word	0x0006	; ????
 36a:	6e 93       	st	-X, r22
 36c:	01 6f       	ori	r16, 0xF1	; 241
 36e:	93 01       	movw	r18, r6
	...
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 378:	b6 02       	muls	r27, r22
 37a:	00 00       	nop
 37c:	c0 02       	muls	r28, r16
 37e:	00 00       	nop
 380:	01 00       	.word	0x0001	; ????
 382:	68 00       	.word	0x0068	; ????
 384:	00 00       	nop
   asm("nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"); //delay
 386:	00 00       	nop
 388:	00 00       	nop
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	fa 00       	.word	0x00fa	; ????
   2:	00 00       	nop
   4:	08 01       	movw	r0, r16
   6:	00 00       	nop
   8:	2a 01       	movw	r4, r20
   a:	00 00       	nop
   c:	6c 01       	movw	r12, r24
	...
  16:	00 00       	nop
  18:	e0 00       	.word	0x00e0	; ????
  1a:	00 00       	nop
  1c:	04 02       	muls	r16, r20
  1e:	00 00       	nop
  20:	04 02       	muls	r16, r20
  22:	00 00       	nop
  24:	64 0f       	add	r22, r20
	...
